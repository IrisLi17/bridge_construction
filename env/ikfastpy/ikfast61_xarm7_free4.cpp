/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x10000049 generated on 2021-08-06 17:32:10.966704
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x10000049);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)1e-7)
#endif

// used to check input to atan2 for degenerate cases. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)1e-7)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.00001)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42,x43,x44,x45,x46,x47,x48,x49,x50,x51,x52,x53,x54,x55,x56,x57,x58,x59,x60,x61,x62,x63,x64,x65;
x0=IKcos(j[0]);
x1=IKcos(j[3]);
x2=IKsin(j[1]);
x3=IKsin(j[3]);
x4=IKcos(j[2]);
x5=IKsin(j[0]);
x6=IKcos(j[1]);
x7=IKsin(j[2]);
x8=IKcos(j[4]);
x9=IKsin(j[4]);
x10=IKcos(j[6]);
x11=IKsin(j[6]);
x12=IKcos(j[5]);
x13=IKsin(j[5]);
x14=((0.097)*x2);
x15=((0.0775)*x4);
x16=((0.3425)*x5);
x17=((1.0)*x1);
x18=((1.0)*x5);
x19=((0.3425)*x4);
x20=((1.0)*x2);
x21=((0.0525)*x4);
x22=((0.0775)*x5);
x23=((1.0)*x4);
x24=((0.293)*x2);
x25=((0.076)*x8);
x26=(x7*x9);
x27=(x1*x6);
x28=(x5*x6);
x29=(x1*x2);
x30=(x0*x7);
x31=((-1.0)*x12);
x32=(x3*x6);
x33=(x2*x3);
x34=((-1.0)*x13);
x35=(x0*x6);
x36=((-0.097)*x8);
x37=(x0*x33);
x38=(x17*x2*x4);
x39=(x20*x26);
x40=((((-1.0)*x18*x7))+((x35*x4)));
x41=(((x30*x6))+((x4*x5)));
x42=(x30+((x28*x4)));
x43=((((-1.0)*x0*x23))+((x28*x7)));
x44=((((-1.0)*x38))+x32);
x45=(x41*x8);
x46=(x3*x40);
x47=((((-1.0)*x20*x3*x4))+(((-1.0)*x17*x6)));
x48=(x41*x9);
x49=(x1*x40);
x50=(x3*x42);
x51=(x44*x8);
x52=(x43*x9);
x53=(x13*x47);
x54=(x37+x49);
x55=((((-1.0)*x0*x17*x2))+x46);
x56=((((-1.0)*x17*x2*x5))+x50);
x57=(((x33*x5))+((x1*x42)));
x58=((((-1.0)*x39))+x51);
x59=((((-1.0)*x20*x7*x8))+((x9*(((((-1.0)*x32))+x38)))));
x60=(x57*x8);
x61=(x12*x58);
x62=(x54*x8);
x63=(x48+x62);
x64=(x52+x60);
x65=(((x9*(((((-1.0)*x18*x33))+(((-1.0)*x17*x42))))))+((x43*x8)));
eerot[0]=(((x10*((((x12*x63))+((x13*x55))))))+((x11*((x45+((x9*(((((-1.0)*x37))+(((-1.0)*x49)))))))))));
IkReal x66=((1.0)*x0);
eerot[1]=(((x11*((((x31*x63))+((x34*((x46+(((-1.0)*x29*x66))))))))))+((x10*((((x9*(((((-1.0)*x20*x3*x66))+(((-1.0)*x17*x40))))))+x45)))));
eerot[2]=(((x13*(((((-1.0)*x48))+(((-1.0)*x62))))))+((x12*x55)));
IkReal x67=((1.0)*x7);
IkReal x68=(x0*x29);
eetrans[0]=(((x0*x24))+((x3*(((((-1.0)*x16*x67))+((x19*x35))))))+((x13*((((x36*x54))+(((-0.097)*x48))))))+((x13*(((((0.076)*x46))+(((-0.076)*x68))))))+((x21*x35))+((x12*(((((-0.097)*x68))+(((0.097)*x46))))))+((x1*((((x15*x35))+(((-1.0)*x22*x67))))))+(((-0.3425)*x68))+(((-0.0525)*x5*x7))+(((0.0775)*x37))+((x12*((((x25*x54))+(((0.076)*x48)))))));
eerot[3]=(((x11*x65))+((x10*((((x12*x64))+((x13*x56)))))));
eerot[4]=(((x10*x65))+((x11*((((x34*x56))+((x31*x64)))))));
eerot[5]=(((x12*x56))+((x13*(((((-1.0)*x52))+(((-1.0)*x60)))))));
eetrans[1]=(((x21*x28))+((x12*(((((0.076)*x52))+((x25*x57))))))+((x13*((((x36*x57))+(((-0.097)*x52))))))+(((-1.0)*x16*x29))+((x22*x33))+((x1*(((((0.0775)*x30))+((x15*x28))))))+((x12*(((((-1.0)*x1*x14*x5))+(((0.097)*x50))))))+((x13*(((((0.076)*x50))+(((-0.076)*x29*x5))))))+((x3*(((((0.3425)*x30))+((x16*x4*x6))))))+(((0.0525)*x30))+((x24*x5)));
eerot[6]=(((x10*((x53+x61))))+((x11*x59)));
eerot[7]=(((x10*x59))+((x11*(((((-1.0)*x53))+(((-1.0)*x61)))))));
eerot[8]=(((x13*((x39+(((-1.0)*x51))))))+((x12*x47)));
eetrans[2]=((0.267)+((x12*((((x25*x44))+(((-0.076)*x2*x26))))))+(((-1.0)*x15*x29))+((x13*((((x36*x44))+((x14*x26))))))+(((-1.0)*x2*x21))+(((-1.0)*x19*x33))+(((0.0775)*x32))+(((-0.3425)*x27))+((x13*(((((-0.076)*x27))+(((-0.076)*x33*x4))))))+(((0.293)*x6))+((x12*(((((-0.097)*x27))+(((-1.0)*x14*x3*x4)))))));
}

IKFAST_API int GetNumFreeParameters() { return 1; }
IKFAST_API int* GetFreeParameters() { static int freeparams[] = {4}; return freeparams; }
IKFAST_API int GetNumJoints() { return 7; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x67000001; }

class IKSolver {
public:
IkReal j0,cj0,sj0,htj0,j0mul,j1,cj1,sj1,htj1,j1mul,j2,cj2,sj2,htj2,j2mul,j3,cj3,sj3,htj3,j3mul,j5,cj5,sj5,htj5,j5mul,j6,cj6,sj6,htj6,j6mul,j4,cj4,sj4,htj4,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij0[2], _nj0,_ij1[2], _nj1,_ij2[2], _nj2,_ij3[2], _nj3,_ij5[2], _nj5,_ij6[2], _nj6,_ij4[2], _nj4;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j0=numeric_limits<IkReal>::quiet_NaN(); _ij0[0] = -1; _ij0[1] = -1; _nj0 = -1; j1=numeric_limits<IkReal>::quiet_NaN(); _ij1[0] = -1; _ij1[1] = -1; _nj1 = -1; j2=numeric_limits<IkReal>::quiet_NaN(); _ij2[0] = -1; _ij2[1] = -1; _nj2 = -1; j3=numeric_limits<IkReal>::quiet_NaN(); _ij3[0] = -1; _ij3[1] = -1; _nj3 = -1; j5=numeric_limits<IkReal>::quiet_NaN(); _ij5[0] = -1; _ij5[1] = -1; _nj5 = -1; j6=numeric_limits<IkReal>::quiet_NaN(); _ij6[0] = -1; _ij6[1] = -1; _nj6 = -1;  _ij4[0] = -1; _ij4[1] = -1; _nj4 = 0; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
j4=pfree[0]; cj4=cos(pfree[0]); sj4=sin(pfree[0]), htj4=tan(pfree[0]*0.5);
r00 = eerot[0*3+0];
r01 = eerot[0*3+1];
r02 = eerot[0*3+2];
r10 = eerot[1*3+0];
r11 = eerot[1*3+1];
r12 = eerot[1*3+2];
r20 = eerot[2*3+0];
r21 = eerot[2*3+1];
r22 = eerot[2*3+2];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_r00=r00;
new_r01=r01;
new_r02=r02;
new_px=((((-0.097)*r02))+px);
new_r10=r10;
new_r11=r11;
new_r12=r12;
new_py=((((-0.097)*r12))+py);
new_r20=r20;
new_r21=r21;
new_r22=r22;
new_pz=((-0.267)+(((-0.097)*r22))+pz);
r00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;
IkReal x69=((1.0)*px);
IkReal x70=((1.0)*pz);
IkReal x71=((1.0)*py);
pp=((px*px)+(py*py)+(pz*pz));
npx=(((px*r00))+((py*r10))+((pz*r20)));
npy=(((px*r01))+((py*r11))+((pz*r21)));
npz=(((px*r02))+((py*r12))+((pz*r22)));
rxp0_0=((((-1.0)*r20*x71))+((pz*r10)));
rxp0_1=(((px*r20))+(((-1.0)*r00*x70)));
rxp0_2=((((-1.0)*r10*x69))+((py*r00)));
rxp1_0=((((-1.0)*r21*x71))+((pz*r11)));
rxp1_1=(((px*r21))+(((-1.0)*r01*x70)));
rxp1_2=((((-1.0)*r11*x69))+((py*r01)));
rxp2_0=((((-1.0)*r22*x71))+((pz*r12)));
rxp2_1=(((px*r22))+(((-1.0)*r02*x70)));
rxp2_2=((((-1.0)*r12*x69))+((py*r02)));
IkReal op[8+1], zeror[8];
int numroots;
IkReal x72=((0.152)*npx);
IkReal x73=((1.0)*npy);
IkReal x74=((-0.01357425)+pp);
IkReal x75=((-0.39870925)+pp);
IkReal x76=((((-1.0)*x72))+x74);
IkReal x77=((((-1.0)*x72))+x75);
IkReal x78=(x74+x72);
IkReal x79=((((-1.0)*x73))+(((-0.13)*sj4)));
IkReal x80=(x75+x72);
IkReal x81=((((-1.0)*x73))+(((-0.025)*sj4)));
IkReal gconst0=x76;
IkReal gconst1=x78;
IkReal gconst2=x79;
IkReal gconst3=x76;
IkReal gconst4=x78;
IkReal gconst5=x79;
IkReal gconst6=x77;
IkReal gconst7=x80;
IkReal gconst8=x81;
IkReal gconst9=x77;
IkReal gconst10=x80;
IkReal gconst11=x81;
IkReal x82=npy*npy;
IkReal x83=npx*npx;
IkReal x84=sj4*sj4;
IkReal x85=npy*npy*npy;
IkReal x86=(gconst10*gconst8);
IkReal x87=((0.162755)*gconst11);
IkReal x88=(gconst10*npy);
IkReal x89=(gconst11*sj4);
IkReal x90=(gconst5*npy);
IkReal x91=((0.608)*npx);
IkReal x92=(gconst11*gconst7);
IkReal x93=(gconst9*npy);
IkReal x94=(gconst7*gconst8);
IkReal x95=((0.02115815)*sj4);
IkReal x96=(gconst4*gconst5);
IkReal x97=(gconst8*gconst9);
IkReal x98=((0.586)*gconst1);
IkReal x99=(gconst2*gconst3);
IkReal x100=(gconst6*sj4);
IkReal x101=((0.162755)*npy);
IkReal x102=(gconst1*gconst3);
IkReal x103=((0.09895504)*npx);
IkReal x104=(gconst10*gconst6);
IkReal x105=(gconst1*gconst2);
IkReal x106=(gconst5*sj4);
IkReal x107=(gconst1*sj4);
IkReal x108=(npx*npy);
IkReal x109=(gconst0*sj4);
IkReal x110=((0.004068875)*sj4);
IkReal x111=(gconst7*gconst9);
IkReal x112=((0.356288)*sj4);
IkReal x113=((0.092416)*x85);
IkReal x114=((0.586)*gconst7*sj4);
IkReal x115=(gconst3*npy*sj4);
IkReal x116=((0.054155776)*x82);
IkReal x117=(gconst9*x82);
IkReal x118=(gconst3*x82);
IkReal x119=((0.65102)*x83);
IkReal x120=((4.0)*x83);
IkReal x121=(gconst0*x84);
IkReal x122=((0.000101721875)*x84);
IkReal x123=((0.162755)*x82);
IkReal x124=((0.01465)*x84);
IkReal x125=((0.054155776)*sj4*x85);
IkReal x126=(x103*x82);
IkReal x127=(x82*x84);
IkReal x128=(gconst6*gconst9*x84);
IkReal x129=(x126+x125);
op[0]=(((gconst11*gconst6*x88))+(((-0.000625)*x128))+(((-1.0)*gconst11*x113))+(((-1.0)*x111*x120))+(((-1.0)*npy*x91*x92))+(((-1.0)*x86*x92))+(((0.0023104)*x82*x89))+(((-0.025)*x104*x89))+(((-0.025)*gconst9*sj4*x94))+(((0.0152)*npx*sj4*x93))+((x93*x94))+(((-1.0)*x117*x91))+(((0.05)*x100*x93))+(((-1.0)*gconst6*x117)));
op[1]=((((-1.0)*x114*x93))+((x87*x94))+(((-0.002473876)*sj4*x108))+((x111*x124))+(((-0.162755)*gconst8*x93))+((gconst7*x119))+((gconst9*x122))+(((-1.0)*gconst6*npy*x87))+((gconst7*x108*x112))+(((0.004068875)*gconst10*x89))+((gconst6*x122))+((gconst6*x123))+((x86*x87))+((x114*x86))+((gconst9*x119))+x129+((gconst11*npy*x103))+(((0.004068875)*gconst6*x89))+(((0.162755)*x117))+(((0.586)*gconst10*gconst7*x89))+(((-1.0)*x87*x88))+(((-0.586)*gconst9*sj4*x94))+(((1.172)*x100*x93))+((x104*x124))+(((-1.0)*x101*x94))+(((-0.586)*x100*x88))+((x116*x89))+(((-0.586)*x104*x89))+(((-0.00813775)*sj4*x93))+((npx*x112*x93))+(((-0.0293)*x128))+(((-0.00813775)*npy*x100))+(((-0.0013538944)*x127))+((x110*x94))+((x110*x97)));
op[2]=((((-0.000662229750625)*gconst11*sj4))+(((0.09537443)*gconst10*npy*sj4))+(((-1.216)*gconst11*gconst7*npx*npy))+(((-0.09537443)*gconst11*gconst7*sj4))+(((0.01663488)*gconst11*sj4*(npy*npy)))+((gconst10*gconst11*gconst6*npy))+(((-0.00238436075)*gconst7*(sj4*sj4)))+(((-1.6555743765625e-5)*(sj4*sj4)))+(((0.343396)*gconst7*gconst9*(sj4*sj4)))+(((0.0023104)*gconst5*sj4*(npy*npy)))+(((-0.349896)*gconst6*gconst9*(sj4*sj4)))+(((-0.608)*gconst3*npx*(npy*npy)))+(((-0.025)*gconst1*gconst8*gconst9*sj4))+(((0.00132445950125)*npy*sj4))+((gconst11*gconst4*gconst6*npy))+(((-0.000625)*gconst0*gconst9*(sj4*sj4)))+(((-1.0)*gconst1*gconst10*gconst11*gconst8))+(((-0.13)*gconst10*gconst11*gconst6*sj4))+((gconst3*gconst7*gconst8*npy))+(((-0.025)*gconst0*gconst10*gconst11*sj4))+(((-0.09537443)*gconst9*npy*sj4))+(((0.09537443)*gconst7*npy*sj4))+(((-0.026489190025)*gconst11*gconst8))+(((-0.025)*gconst3*gconst7*gconst8*sj4))+(((0.00238436075)*gconst9*(sj4*sj4)))+(((-0.09537443)*gconst6*npy*sj4))+(((-4.0)*gconst3*gconst7*(npx*npx)))+((gconst1*gconst8*gconst9*npy))+(((-0.00238436075)*gconst10*(sj4*sj4)))+(((-0.11597530688)*npx*npy*sj4))+(((-4.0)*gconst1*gconst9*(npx*npx)))+(((-0.092416)*gconst5*(npy*npy*npy)))+(((-8.0)*gconst7*gconst9*(npx*npx)))+(((-1.0)*gconst10*gconst11*gconst2*gconst7))+(((0.05)*gconst0*gconst9*npy*sj4))+(((-0.031735284736)*(npy*npy)*(sj4*sj4)))+(((-0.025)*gconst11*gconst4*gconst6*sj4))+(((-0.608)*gconst1*gconst11*npx*npy))+(((-0.343396)*gconst10*gconst7*(sj4*sj4)))+(((-1.0)*gconst10*gconst5*gconst7*gconst8))+(((-0.608)*gconst5*gconst7*npx*npy))+((gconst2*gconst7*gconst9*npy))+(((0.343396)*gconst10*gconst6*(sj4*sj4)))+(((0.05)*gconst3*gconst6*npy*sj4))+(((0.00238436075)*gconst6*(sj4*sj4)))+(((-1.0)*gconst3*gconst6*(npy*npy)))+(((0.026489190025)*gconst11*npy))+(((0.09537443)*gconst11*gconst6*sj4))+((gconst7*gconst8*gconst9*npy))+(((-0.026489190025)*(npy*npy)))+(((0.0152)*gconst3*npx*npy*sj4))+(((0.026489190025)*gconst8*npy))+(((-0.025)*gconst2*gconst7*gconst9*sj4))+(((-0.13)*gconst7*gconst8*gconst9*sj4))+((gconst10*gconst5*gconst6*npy))+(((-0.277248)*gconst11*(npy*npy*npy)))+((gconst0*gconst10*gconst11*npy))+(((-0.000625)*gconst3*gconst6*(sj4*sj4)))+(((0.10944)*gconst9*npx*npy*sj4))+(((0.09537443)*gconst8*gconst9*sj4))+(((-1.0)*gconst0*gconst9*(npy*npy)))+(((-0.1059567601)*(npx*npx)))+(((-1.824)*gconst9*npx*(npy*npy)))+(((-2.0)*gconst6*gconst9*(npy*npy)))+(((0.31)*gconst6*gconst9*npy*sj4))+(((-0.025)*gconst10*gconst5*gconst6*sj4))+(((-1.0)*gconst11*gconst4*gconst7*gconst8))+(((-0.09537443)*gconst10*gconst8*sj4))+(((-0.000662229750625)*gconst8*sj4)));
op[3]=((((-0.00813775)*gconst0*npy*sj4))+(((0.01465)*gconst1*gconst9*(sj4*sj4)))+(((0.0010579075)*gconst6*(sj4*sj4)))+(((0.586)*gconst10*gconst2*gconst7*sj4))+(((0.162467328)*sj4*(npy*npy*npy)))+(((0.004068875)*gconst10*gconst5*sj4))+(((0.07618)*gconst10*gconst6*(sj4*sj4)))+(((0.29686512)*npx*(npy*npy)))+(((-0.162755)*gconst7*gconst8*npy))+(((1.30204)*gconst9*(npx*npx)))+(((0.65102)*gconst3*(npx*npx)))+(((0.02115815)*gconst8*gconst9*sj4))+(((-0.586)*gconst3*gconst7*gconst8*sj4))+(((0.586)*gconst11*gconst4*gconst7*sj4))+(((0.02115815)*gconst11*gconst6*sj4))+(((0.004068875)*gconst2*gconst9*sj4))+(((-0.586)*gconst11*gconst4*gconst6*sj4))+(((0.000101721875)*gconst0*(sj4*sj4)))+(((0.162755)*gconst10*gconst11*gconst2))+(((0.586)*gconst10*gconst5*gconst7*sj4))+(((0.356288)*gconst1*npx*npy*sj4))+(((0.000101721875)*gconst3*(sj4*sj4)))+(((1.172)*gconst0*gconst9*npy*sj4))+(((-0.162755)*gconst11*gconst6*npy))+(((0.09895504)*gconst5*npx*npy))+(((0.586)*gconst4*gconst7*gconst8*sj4))+(((-0.0293)*gconst3*gconst6*(sj4*sj4)))+(((-0.586)*gconst1*gconst9*npy*sj4))+(((-0.586)*gconst3*gconst7*npy*sj4))+(((-0.162755)*gconst10*gconst5*npy))+(((0.02115815)*gconst10*gconst11*sj4))+(((0.004068875)*gconst1*gconst8*sj4))+(((-0.15236)*gconst6*gconst9*(sj4*sj4)))+(((0.162755)*gconst10*gconst5*gconst8))+(((0.32551)*gconst9*(npy*npy)))+(((0.01465)*gconst3*gconst7*(sj4*sj4)))+(((0.108311552)*gconst11*sj4*(npy*npy)))+(((-0.586)*gconst7*gconst9*npy*sj4))+(((0.586)*gconst1*gconst10*gconst11*sj4))+(((-0.0293)*gconst0*gconst9*(sj4*sj4)))+(((1.30204)*gconst7*(npx*npx)))+(((0.162755)*gconst0*(npy*npy)))+(((-0.0178119072)*npx*npy*sj4))+(((0.004068875)*gconst2*gconst7*sj4))+(((-0.00813775)*gconst3*npy*sj4))+(((-0.162755)*gconst2*gconst9*npy))+(((0.162755)*gconst1*gconst11*gconst8))+(((0.19791008)*gconst11*npx*npy))+(((0.162755)*gconst11*gconst4*gconst8))+(((0.0010579075)*gconst9*(sj4*sj4)))+(((-0.162755)*gconst5*gconst6*npy))+(((0.004068875)*gconst5*gconst6*sj4))+(((-0.162755)*gconst11*gconst4*npy))+(((-0.586)*gconst0*gconst10*npy*sj4))+(((-0.586)*gconst1*gconst8*gconst9*sj4))+(((-0.00974803968)*(npy*npy)*(sj4*sj4)))+(((0.712576)*gconst9*npx*npy*sj4))+(((0.01465)*gconst4*gconst6*(sj4*sj4)))+(((0.162755)*gconst3*(npy*npy)))+(((1.172)*gconst6*gconst9*npy*sj4))+(((0.712576)*gconst7*npx*npy*sj4))+(((-0.162755)*gconst3*gconst8*npy))+(((0.004068875)*gconst11*gconst4*sj4))+(((-0.586)*gconst2*gconst7*gconst9*sj4))+(((0.004068875)*gconst0*gconst11*sj4))+(((-0.05045405)*gconst9*npy*sj4))+(((0.162755)*gconst5*gconst7*gconst8))+(((0.02115815)*gconst7*gconst8*sj4))+(((-0.162755)*gconst8*gconst9*npy))+(((0.586)*gconst1*gconst10*gconst8*sj4))+(((-0.05045405)*gconst6*npy*sj4))+(((0.162755)*gconst11*gconst2*gconst7))+(((-0.586)*gconst10*gconst5*gconst6*sj4))+(((-0.162755)*gconst2*gconst7*npy))+(((0.07618)*gconst7*gconst9*(sj4*sj4)))+(((0.356288)*gconst3*npx*npy*sj4))+(((0.65102)*gconst1*(npx*npx)))+(((-0.586)*gconst4*gconst6*npy*sj4))+(((0.01465)*gconst0*gconst10*(sj4*sj4)))+(((-0.162755)*gconst10*gconst11*npy))+(((0.004068875)*gconst3*gconst8*sj4))+(((-0.162755)*gconst0*gconst11*npy))+(((-0.586)*gconst10*gconst6*npy*sj4))+(((0.32551)*gconst6*(npy*npy)))+(((0.054155776)*gconst5*sj4*(npy*npy)))+(((-0.162755)*gconst1*gconst8*npy))+(((1.172)*gconst3*gconst6*npy*sj4))+(((-0.586)*gconst0*gconst10*gconst11*sj4)));
op[4]=((((0.31)*gconst3*gconst6*npy*sj4))+(((0.00238436075)*gconst3*(sj4*sj4)))+(((-1.216)*gconst5*gconst7*npx*npy))+(((0.09537443)*gconst0*gconst11*sj4))+(((0.09537443)*gconst10*npy*sj4))+(((0.17328)*gconst9*npx*npy*sj4))+(((-0.05297838005)*(npy*npy)))+(((-0.09537443)*gconst5*gconst7*sj4))+(((-1.0)*gconst1*gconst10*gconst5*gconst8))+((gconst1*gconst3*gconst8*npy))+(((-1.0)*gconst10*gconst2*gconst5*gconst7))+((gconst2*gconst3*gconst7*npy))+(((0.00821164890775)*npy*sj4))+(((0.343396)*gconst4*gconst6*(sj4*sj4)))+(((-0.0169)*gconst6*gconst9*(sj4*sj4)))+((gconst0*gconst11*gconst4*npy))+(((-0.277248)*gconst5*(npy*npy*npy)))+((gconst11*gconst4*gconst6*npy))+(((0.09537443)*gconst1*npy*sj4))+(((0.026489190025)*gconst2*npy))+(((-1.0)*gconst0*gconst3*(npy*npy)))+(((-1.0)*gconst6*gconst9*(npy*npy)))+(((-0.343396)*gconst1*gconst10*(sj4*sj4)))+(((-1.0)*gconst1*gconst10*gconst11*gconst2))+(((-0.608)*gconst1*gconst5*npx*npy))+(((-0.0123986759)*gconst10*(sj4*sj4)))+(((-0.00344359470325)*gconst11*sj4))+(((-0.026489190025)*gconst5*gconst8))+(((-0.00344359470325)*gconst8*sj4))+(((-0.13)*gconst11*gconst4*gconst6*sj4))+((gconst3*gconst7*gconst8*npy))+(((-2.0)*gconst0*gconst9*(npy*npy)))+(((0.343396)*gconst1*gconst9*(sj4*sj4)))+(((-0.343396)*gconst4*gconst7*(sj4*sj4)))+(((-0.025)*gconst2*gconst3*gconst7*sj4))+(((-0.09537443)*gconst9*npy*sj4))+(((-0.349896)*gconst0*gconst9*(sj4*sj4)))+(((-0.09537443)*gconst3*npy*sj4))+(((0.09537443)*gconst7*npy*sj4))+(((-0.09537443)*gconst0*npy*sj4))+(((-0.026489190025)*gconst11*gconst2))+(((-0.0123986759)*gconst7*(sj4*sj4)))+(((0.0123986759)*gconst6*(sj4*sj4)))+(((-0.608)*gconst11*gconst7*npx*npy))+(((-0.23195061376)*npx*npy*sj4))+(((-0.09537443)*gconst6*npy*sj4))+(((0.343396)*gconst3*gconst7*(sj4*sj4)))+(((0.09537443)*gconst4*npy*sj4))+(((-0.000662229750625)*gconst2*sj4))+(((-0.13)*gconst3*gconst7*gconst8*sj4))+(((-8.0)*gconst3*gconst7*(npx*npx)))+(((-0.025)*gconst1*gconst2*gconst9*sj4))+((gconst1*gconst8*gconst9*npy))+(((-0.2119135202)*(npx*npx)))+(((-1.0)*gconst4*gconst5*gconst7*gconst8))+(((-0.13)*gconst1*gconst8*gconst9*sj4))+(((-0.025)*gconst0*gconst10*gconst5*sj4))+(((-0.09537443)*gconst1*gconst11*sj4))+(((-0.063470569472)*(npy*npy)*(sj4*sj4)))+(((0.026489190025)*gconst5*npy))+(((-0.09537443)*gconst4*gconst8*sj4))+(((0.0123986759)*gconst9*(sj4*sj4)))+(((-2.0)*gconst3*gconst6*(npy*npy)))+(((-0.09537443)*gconst10*gconst2*sj4))+((gconst1*gconst2*gconst9*npy))+(((0.09537443)*gconst2*gconst9*sj4))+(((-0.13)*gconst0*gconst10*gconst11*sj4))+((gconst2*gconst7*gconst9*npy))+(((0.02633856)*gconst11*sj4*(npy*npy)))+(((0.343396)*gconst0*gconst10*(sj4*sj4)))+(((-4.0)*gconst7*gconst9*(npx*npx)))+(((-0.025)*gconst0*gconst11*gconst4*sj4))+(((-0.025)*gconst1*gconst3*gconst8*sj4))+(((-0.0001721797351625)*(sj4*sj4)))+(((0.10944)*gconst3*npx*npy*sj4))+(((-0.13)*gconst2*gconst7*gconst9*sj4))+(((-0.000625)*gconst0*gconst3*(sj4*sj4)))+(((0.31)*gconst0*gconst9*npy*sj4))+(((0.26)*gconst6*gconst9*npy*sj4))+(((-1.216)*gconst1*gconst11*npx*npy))+(((0.026489190025)*gconst11*npy))+(((0.09537443)*gconst3*gconst8*sj4))+(((-1.824)*gconst3*npx*(npy*npy)))+(((-0.000662229750625)*gconst5*sj4))+(((0.026489190025)*gconst8*npy))+((gconst4*gconst5*gconst6*npy))+((gconst0*gconst10*gconst5*npy))+(((-0.13)*gconst10*gconst5*gconst6*sj4))+(((0.09537443)*gconst5*gconst6*sj4))+(((0.05)*gconst0*gconst3*npy*sj4))+(((-0.00238436075)*gconst4*(sj4*sj4)))+(((0.01663488)*gconst5*sj4*(npy*npy)))+((gconst10*gconst5*gconst6*npy))+(((-8.0)*gconst1*gconst9*(npx*npx)))+(((-0.277248)*gconst11*(npy*npy*npy)))+(((0.00238436075)*gconst0*(sj4*sj4)))+((gconst0*gconst10*gconst11*npy))+(((-1.0)*gconst1*gconst11*gconst4*gconst8))+(((-1.0)*gconst11*gconst2*gconst4*gconst7))+(((-1.824)*gconst9*npx*(npy*npy)))+(((-0.025)*gconst4*gconst5*gconst6*sj4))+(((-0.349896)*gconst3*gconst6*(sj4*sj4)))+(((-4.0)*gconst1*gconst3*(npx*npx)))+(((-0.00238436075)*gconst1*(sj4*sj4))));
op[5]=((((0.02115815)*gconst0*gconst11*sj4))+(((0.02115815)*gconst5*gconst6*sj4))+(((0.356288)*gconst7*npx*npy*sj4))+(((0.0010579075)*gconst0*(sj4*sj4)))+(((0.162467328)*sj4*(npy*npy*npy)))+(((0.19791008)*gconst5*npx*npy))+(((0.65102)*gconst7*(npx*npx)))+(((0.586)*gconst1*gconst10*gconst5*sj4))+(((0.356288)*gconst9*npx*npy*sj4))+(((-0.586)*gconst0*gconst4*npy*sj4))+(((0.004068875)*gconst1*gconst2*sj4))+(((0.29686512)*npx*(npy*npy)))+(((0.586)*gconst4*gconst5*gconst7*sj4))+(((0.004068875)*gconst0*gconst5*sj4))+(((0.162755)*gconst6*(npy*npy)))+(((0.162755)*gconst2*gconst5*gconst7))+(((-0.0423163)*gconst6*npy*sj4))+(((0.32551)*gconst3*(npy*npy)))+(((0.162755)*gconst4*gconst5*gconst8))+(((-0.586)*gconst2*gconst3*gconst7*sj4))+(((0.02115815)*gconst10*gconst5*sj4))+(((-0.15236)*gconst0*gconst9*(sj4*sj4)))+(((0.02115815)*gconst3*gconst8*sj4))+(((0.32551)*gconst0*(npy*npy)))+(((0.586)*gconst1*gconst11*gconst4*sj4))+(((0.65102)*gconst9*(npx*npx)))+(((0.02115815)*gconst11*gconst4*sj4))+(((1.172)*gconst0*gconst9*npy*sj4))+(((-0.162755)*gconst1*gconst2*npy))+(((-0.586)*gconst4*gconst5*gconst6*sj4))+(((0.162755)*gconst1*gconst5*gconst8))+(((0.586)*gconst1*gconst4*gconst8*sj4))+(((-0.586)*gconst1*gconst9*npy*sj4))+(((0.09895504)*gconst11*npx*npy))+(((-0.586)*gconst3*gconst7*npy*sj4))+(((-0.162755)*gconst10*gconst5*npy))+(((-0.0282021864)*npx*npy*sj4))+(((1.30204)*gconst3*(npx*npx)))+(((-0.162755)*gconst2*gconst3*npy))+(((0.07618)*gconst4*gconst6*(sj4*sj4)))+(((-0.15236)*gconst3*gconst6*(sj4*sj4)))+(((0.01465)*gconst1*gconst3*(sj4*sj4)))+(((-0.162755)*gconst2*gconst9*npy))+(((0.02115815)*gconst1*gconst8*sj4))+(((0.162755)*gconst1*gconst11*gconst2))+(((0.004068875)*gconst2*gconst3*sj4))+(((0.586)*gconst2*gconst4*gconst7*sj4))+(((0.0027505595)*gconst6*(sj4*sj4)))+(((-0.586)*gconst1*gconst3*npy*sj4))+(((-0.01543439616)*(npy*npy)*(sj4*sj4)))+(((-0.162755)*gconst5*gconst6*npy))+(((0.712576)*gconst3*npx*npy*sj4))+(((-0.162755)*gconst11*gconst4*npy))+(((-0.586)*gconst0*gconst10*npy*sj4))+(((0.108311552)*gconst5*sj4*(npy*npy)))+(((1.30204)*gconst1*(npx*npx)))+(((-0.162755)*gconst0*gconst5*npy))+(((0.01465)*gconst0*gconst4*(sj4*sj4)))+(((1.172)*gconst0*gconst3*npy*sj4))+(((-0.162755)*gconst4*gconst5*npy))+(((-0.05045405)*gconst3*npy*sj4))+(((0.07618)*gconst1*gconst9*(sj4*sj4)))+(((-0.162755)*gconst3*gconst8*npy))+(((0.07618)*gconst3*gconst7*(sj4*sj4)))+(((-0.0423163)*gconst9*npy*sj4))+(((-0.05045405)*gconst0*npy*sj4))+(((-0.586)*gconst1*gconst3*gconst8*sj4))+(((-0.586)*gconst1*gconst2*gconst9*sj4))+(((0.712576)*gconst1*npx*npy*sj4))+(((0.162755)*gconst11*gconst2*gconst4))+(((-0.162755)*gconst2*gconst7*npy))+(((-0.586)*gconst0*gconst10*gconst5*sj4))+(((0.162755)*gconst10*gconst2*gconst5))+(((0.586)*gconst1*gconst10*gconst2*sj4))+(((-0.586)*gconst4*gconst6*npy*sj4))+(((0.0027505595)*gconst9*(sj4*sj4)))+(((0.02115815)*gconst2*gconst7*sj4))+(((-0.162755)*gconst0*gconst11*npy))+(((0.02115815)*gconst2*gconst9*sj4))+(((0.07618)*gconst0*gconst10*(sj4*sj4)))+(((-0.0293)*gconst0*gconst3*(sj4*sj4)))+(((0.004068875)*gconst4*gconst5*sj4))+(((-0.586)*gconst0*gconst11*gconst4*sj4))+(((-0.162755)*gconst1*gconst8*npy))+(((0.162755)*gconst9*(npy*npy)))+(((0.0010579075)*gconst3*(sj4*sj4)))+(((1.172)*gconst3*gconst6*npy*sj4))+(((0.054155776)*gconst11*sj4*(npy*npy))));
op[6]=((((-0.0123986759)*gconst4*(sj4*sj4)))+(((-0.025)*gconst0*gconst4*gconst5*sj4))+(((-0.025)*gconst1*gconst2*gconst3*sj4))+(((-0.026489190025)*gconst2*gconst5))+(((0.0123986759)*gconst0*(sj4*sj4)))+(((-0.13)*gconst0*gconst10*gconst5*sj4))+((gconst1*gconst3*gconst8*npy))+((gconst2*gconst3*gconst7*npy))+((gconst1*gconst2*gconst3*npy))+((gconst0*gconst11*gconst4*npy))+(((-0.277248)*gconst5*(npy*npy*npy)))+(((-1.0)*gconst1*gconst4*gconst5*gconst8))+(((0.09537443)*gconst1*npy*sj4))+(((0.026489190025)*gconst2*npy))+(((0.26)*gconst3*gconst6*npy*sj4))+(((-0.00344359470325)*gconst5*sj4))+(((-0.092416)*gconst11*(npy*npy*npy)))+(((-0.0123986759)*gconst1*(sj4*sj4)))+(((-0.09537443)*gconst1*gconst5*sj4))+((gconst0*gconst4*gconst5*npy))+(((-0.09537443)*gconst3*npy*sj4))+(((-0.09537443)*gconst0*npy*sj4))+(((-0.343396)*gconst1*gconst4*(sj4*sj4)))+(((0.17328)*gconst3*npx*npy*sj4))+(((-1.0)*gconst1*gconst11*gconst2*gconst4))+(((-0.13)*gconst0*gconst11*gconst4*sj4))+(((0.09537443)*gconst4*npy*sj4))+(((-4.0)*gconst3*gconst7*(npx*npx)))+(((-0.13)*gconst2*gconst3*gconst7*sj4))+(((-0.0004476673114225)*(sj4*sj4)))+(((-0.13)*gconst4*gconst5*gconst6*sj4))+(((-0.11597530688)*npx*npy*sj4))+(((-4.0)*gconst1*gconst9*(npx*npx)))+(((-0.13)*gconst1*gconst2*gconst9*sj4))+(((0.026489190025)*gconst5*npy))+(((-0.031735284736)*(npy*npy)*(sj4*sj4)))+(((0.0068871894065)*npy*sj4))+(((-0.608)*gconst9*npx*(npy*npy)))+(((-1.0)*gconst1*gconst10*gconst2*gconst5))+(((-0.0169)*gconst3*gconst6*(sj4*sj4)))+(((-0.0169)*gconst0*gconst9*(sj4*sj4)))+(((0.26)*gconst0*gconst9*npy*sj4))+((gconst1*gconst2*gconst9*npy))+(((-0.608)*gconst1*gconst11*npx*npy))+(((-0.608)*gconst5*gconst7*npx*npy))+(((-0.13)*gconst1*gconst3*gconst8*sj4))+(((0.09537443)*gconst2*gconst3*sj4))+(((0.01201408)*gconst11*sj4*(npy*npy)))+(((0.02633856)*gconst5*sj4*(npy*npy)))+(((-2.0)*gconst0*gconst3*(npy*npy)))+(((0.31)*gconst0*gconst3*npy*sj4))+(((-1.0)*gconst3*gconst6*(npy*npy)))+(((0.343396)*gconst0*gconst4*(sj4*sj4)))+(((-1.824)*gconst3*npx*(npy*npy)))+(((-0.026489190025)*(npy*npy)))+((gconst4*gconst5*gconst6*npy))+(((-8.0)*gconst1*gconst3*(npx*npx)))+(((-1.216)*gconst1*gconst5*npx*npy))+((gconst0*gconst10*gconst5*npy))+(((0.343396)*gconst1*gconst3*(sj4*sj4)))+(((0.09537443)*gconst0*gconst5*sj4))+(((-1.0)*gconst0*gconst9*(npy*npy)))+(((-0.09537443)*gconst2*gconst4*sj4))+(((-0.1059567601)*(npx*npx)))+(((0.07904)*gconst9*npx*npy*sj4))+(((0.0123986759)*gconst3*(sj4*sj4)))+(((-0.00344359470325)*gconst2*sj4))+(((-1.0)*gconst2*gconst4*gconst5*gconst7))+(((-0.349896)*gconst0*gconst3*(sj4*sj4))));
op[7]=(((gconst3*x108*x112))+(((-1.0)*sj4*x98*x99))+(((-1.0)*x115*x98))+(((-1.0)*x101*x105))+(((0.162755)*gconst2*x96))+(((0.0027505595)*gconst3*x84))+(((-0.0128641552)*sj4*x108))+((x106*x116))+((gconst1*x119))+(((0.07618)*gconst4*x121))+((x103*x90))+(((0.0027505595)*x121))+(((-0.586)*gconst4*npy*x109))+(((1.172)*gconst3*npy*x109))+x129+(((-0.15236)*gconst3*x121))+((sj4*x96*x98))+(((0.162755)*x118))+(((-0.0423163)*npy*x109))+(((0.07618)*x102*x84))+(((0.356288)*x107*x108))+(((-0.162755)*gconst4*x90))+(((-0.0423163)*x115))+(((-1.0)*x101*x99))+((gconst0*x123))+((x95*x96))+((x95*x99))+((gconst3*x119))+((x105*x95))+(((-0.586)*x109*x96))+(((-0.162755)*gconst0*x90))+(((-0.00704025088)*x127))+(((0.162755)*gconst5*x105))+((gconst0*gconst5*x95))+((gconst2*gconst4*sj4*x98)));
op[8]=(((gconst0*gconst4*x90))+(((-0.0169)*gconst3*x121))+(((0.01201408)*x106*x82))+(((-1.0)*gconst0*x118))+((gconst1*npy*x99))+(((-0.13)*x107*x99))+(((-1.0)*x118*x91))+(((-1.0)*gconst1*x90*x91))+(((0.07904)*gconst3*sj4*x108))+(((-0.13)*x109*x96))+(((0.26)*gconst3*npy*x109))+(((-1.0)*gconst5*x113))+(((-1.0)*x102*x120))+(((-1.0)*x105*x96)));
polyroots8(op,zeror,numroots);
IkReal j3array[8], cj3array[8], sj3array[8], tempj3array[1];
int numsolutions = 0;
for(int ij3 = 0; ij3 < numroots; ++ij3)
{
IkReal htj3 = zeror[ij3];
tempj3array[0]=((2.0)*(atan(htj3)));
for(int kj3 = 0; kj3 < 1; ++kj3)
{
j3array[numsolutions] = tempj3array[kj3];
if( j3array[numsolutions] > IKPI )
{
    j3array[numsolutions]-=IK2PI;
}
else if( j3array[numsolutions] < -IKPI )
{
    j3array[numsolutions]+=IK2PI;
}
sj3array[numsolutions] = IKsin(j3array[numsolutions]);
cj3array[numsolutions] = IKcos(j3array[numsolutions]);
numsolutions++;
}
}
bool j3valid[8]={true,true,true,true,true,true,true,true};
_nj3 = 8;
for(int ij3 = 0; ij3 < numsolutions; ++ij3)
    {
if( !j3valid[ij3] )
{
    continue;
}
    j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
htj3 = IKtan(j3/2);

_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < numsolutions; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
{
IkReal j6eval[2];
IkReal x130=npx*npx;
IkReal x131=npy*npy;
j6eval[0]=(x131+x130);
j6eval[1]=IKsign(((((19.0)*x130))+(((19.0)*x131))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )
{
{
IkReal j5eval[2];
IkReal x132=cj4*cj4;
IkReal x133=cj3*cj3;
IkReal x134=((0.00467628)*cj3);
IkReal x135=((3.78064516129032)*cj3);
IkReal x136=(sj3*x132);
IkReal x137=(cj3*x132);
IkReal x138=(x132*x133);
j5eval[0]=((-14.7542242703533)+(((-1.0)*x135*x136))+(((-10.2110906298003)*x133))+((sj3*x135))+(((-4.41935483870968)*sj3))+(((24.6642089093702)*cj3))+(((10.2110906298003)*x138))+(((-1.0)*x137))+(((-5.58095238095238)*x136))+(((-11.2878955453149)*x132)));
j5eval[1]=IKsign(((-0.0182495)+(((-0.013961998)*x132))+(((-1.0)*x134*x136))+((sj3*x134))+(((0.03050716)*cj3))+(((-0.00690308)*x136))+(((-0.0054663)*sj3))+(((0.012630098)*x138))+(((-0.0012369)*x137))+(((-0.012630098)*x133))));
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j5, j6]

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x139=cj3*cj3;
IkReal x140=cj4*cj4;
IkReal x141=(cj4*npz);
IkReal x142=(cj4*pp);
IkReal x143=(cj4*sj3);
IkReal x144=((0.00467628)*cj3*sj3);
IkReal x145=((0.012630098)*x139);
CheckValue<IkReal> x146 = IKatan2WithCheck(IkReal(((0.078832428125)+(((-0.1297386375)*cj3))+(((0.044536)*sj3*x141))+(((0.293)*cj3*pp))+(((0.00798)*cj3*x141))+(((0.039300715625)*sj3))+(((-0.3425)*pp))+(((-0.0525)*pp*sj3))+(((0.05214995875)*x139))+(((0.01178)*x141))+(((-0.03395340125)*cj3*sj3)))),IkReal(((((-0.0775)*x142))+(((-0.03395340125)*cj4*x139))+(((0.044536)*cj3*npz))+(((-0.00798)*npz*sj3))+(((-0.293)*sj3*x142))+(((-0.003495059375)*cj3*cj4))+(((-0.05206)*npz))+(((-0.0525)*cj3*x142))+(((-0.05214995875)*cj3*x143))+(((0.070091025)*x143))+(((0.040714873125)*cj4)))),IKFAST_ATAN2_MAGTHRESH);
if(!x146.valid){
continue;
}
CheckValue<IkReal> x147=IKPowWithIntegerCheck(IKsign(((-0.0182495)+(((-1.0)*x145))+((x140*x145))+(((-1.0)*x140*x144))+(((-0.00690308)*sj3*x140))+(((0.03050716)*cj3))+(((-0.013961998)*x140))+x144+(((-0.0054663)*sj3))+(((-0.0012369)*cj3*x140)))),-1);
if(!x147.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(x146.value)+(((1.5707963267949)*(x147.value))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[2];
IkReal x148=IKcos(j5);
IkReal x149=IKsin(j5);
IkReal x150=(cj3*x149);
IkReal x151=(sj3*x148);
IkReal x152=(sj3*x149);
IkReal x153=(cj4*x148);
evalcond[0]=((((0.0525)*x151))+(((-0.293)*cj3*x148))+(((-1.0)*npz))+(((-0.0525)*cj4*x150))+(((-0.293)*cj4*x152))+(((-0.0775)*cj4*x149))+(((0.3425)*x148)));
evalcond[1]=((-0.21769375)+(((0.044536)*x150))+(((-0.01178)*x153))+(((0.1925675)*cj3))+(((-0.00798)*x152))+(((-0.044536)*cj4*x151))+pp+(((-0.05206)*x149))+(((-0.00798)*cj3*x153))+(((-0.0813775)*sj3)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j6eval[2];
IkReal x154=npx*npx;
IkReal x155=npy*npy;
j6eval[0]=(x155+x154);
j6eval[1]=IKsign(((((19.0)*x154))+(((19.0)*x155))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )
{
{
IkReal j6eval[2];
IkReal x156=(((sj5*(npy*npy)))+((sj5*(npx*npx))));
j6eval[0]=x156;
j6eval[1]=IKsign(x156);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )
{
{
IkReal j6eval[2];
IkReal x157=(((cj5*(npx*npx)))+((cj5*(npy*npy))));
j6eval[0]=x157;
j6eval[1]=IKsign(x157);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[3];
sj5=1.0;
cj5=0;
j5=1.5707963267949;
IkReal x158=((0.587527627787259)*pp);
IkReal x159=(cj3*npy);
IkReal x160=((0.807012757742775)*sj4);
IkReal x161=((0.829953772766696)*sj4);
IkReal x162=(cj3*npx);
IkReal x163=((3.27896371317461)*pp*sj4);
IkReal x164=((npx*npx)+(npy*npy));
j6eval[0]=x164;
j6eval[1]=((IKabs(((((-0.260012219175783)*npy))+(((-1.0)*x161*x162))+(((-1.0)*npx*x163))+(((0.153695143104944)*x159))+((npx*x160))+(((-1.0)*npy*x158)))))+(IKabs(((((-0.153695143104944)*x162))+(((-1.0)*x159*x161))+(((0.260012219175783)*npx))+(((-1.0)*npy*x163))+((npx*x158))+((npy*x160))))));
j6eval[2]=IKsign(x164);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
sj5=1.0;
cj5=0;
j5=1.5707963267949;
IkReal x165=npx*npx;
IkReal x166=npy*npy;
IkReal x167=(cj3*npx);
IkReal x168=((15.7691216825672)*sj4);
IkReal x169=((11.1630249279579)*pp);
IkReal x170=(cj3*npy);
IkReal x171=(npx*sj4);
IkReal x172=((62.3003105503175)*pp);
IkReal x173=(npy*sj4);
j6eval[0]=(x166+x165);
j6eval[1]=IKsign(((((19.0)*x165))+(((19.0)*x166))));
j6eval[2]=((IKabs(((((-4.94023216433987)*npy))+(((-1.0)*npy*x169))+(((-1.0)*x171*x172))+(((2.92020771899393)*x170))+(((-1.0)*x167*x168))+(((15.3332423971127)*x171)))))+(IKabs(((((4.94023216433987)*npx))+(((-2.92020771899393)*x167))+(((-1.0)*x168*x170))+((npx*x169))+(((-1.0)*x172*x173))+(((15.3332423971127)*x173))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j6]

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x174=(cj3*npx);
IkReal x175=((15.7691216825672)*sj4);
IkReal x176=((11.1630249279579)*pp);
IkReal x177=(cj3*npy);
IkReal x178=(npx*sj4);
IkReal x179=((62.3003105503175)*pp);
IkReal x180=(npy*sj4);
CheckValue<IkReal> x181=IKPowWithIntegerCheck(IKsign(((((19.0)*(npx*npx)))+(((19.0)*(npy*npy))))),-1);
if(!x181.valid){
continue;
}
CheckValue<IkReal> x182 = IKatan2WithCheck(IkReal(((((-1.0)*x174*x175))+(((-4.94023216433987)*npy))+(((-1.0)*npy*x176))+(((2.92020771899393)*x177))+(((-1.0)*x178*x179))+(((15.3332423971127)*x178)))),IkReal(((((15.3332423971127)*x180))+(((-1.0)*x175*x177))+(((4.94023216433987)*npx))+(((-2.92020771899393)*x174))+(((-1.0)*x179*x180))+((npx*x176)))),IKFAST_ATAN2_MAGTHRESH);
if(!x182.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x181.value)))+(x182.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[3];
IkReal x183=IKsin(j6);
IkReal x184=IKcos(j6);
IkReal x185=((1.0)*npx);
IkReal x186=(npy*x183);
evalcond[0]=((0.260012219175783)+x186+(((-1.0)*x184*x185))+(((0.587527627787259)*pp))+(((-0.153695143104944)*cj3)));
evalcond[1]=((0.039521857314719)+(((-0.0233616617519514)*cj3))+(((0.0893041994236634)*pp))+(((0.152)*x186))+(((-0.152)*npx*x184)));
evalcond[2]=((((-3.27896371317461)*pp*sj4))+(((-0.829953772766696)*cj3*sj4))+(((0.807012757742775)*sj4))+(((-1.0)*x183*x185))+(((-1.0)*npy*x184)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x725=((0.587527627787259)*pp);
IkReal x726=(cj3*npy);
IkReal x727=((0.807012757742775)*sj4);
IkReal x728=((0.829953772766696)*sj4);
IkReal x729=(cj3*npx);
IkReal x730=((3.27896371317461)*pp*sj4);
CheckValue<IkReal> x731 = IKatan2WithCheck(IkReal(((((0.153695143104944)*x726))+(((-0.260012219175783)*npy))+(((-1.0)*npy*x725))+(((-1.0)*npx*x730))+((npx*x727))+(((-1.0)*x728*x729)))),IkReal(((((-0.153695143104944)*x729))+((npy*x727))+(((0.260012219175783)*npx))+(((-1.0)*npy*x730))+(((-1.0)*x726*x728))+((npx*x725)))),IKFAST_ATAN2_MAGTHRESH);
if(!x731.valid){
continue;
}
CheckValue<IkReal> x732=IKPowWithIntegerCheck(IKsign(((npx*npx)+(npy*npy))),-1);
if(!x732.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x731.value)+(((1.5707963267949)*(x732.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[3];
IkReal x733=IKsin(j6);
IkReal x734=IKcos(j6);
IkReal x735=((1.0)*npx);
IkReal x736=(npy*x733);
evalcond[0]=((0.260012219175783)+(((-1.0)*x734*x735))+(((0.587527627787259)*pp))+(((-0.153695143104944)*cj3))+x736);
evalcond[1]=((0.039521857314719)+(((0.152)*x736))+(((-0.0233616617519514)*cj3))+(((-0.152)*npx*x734))+(((0.0893041994236634)*pp)));
evalcond[2]=((((-3.27896371317461)*pp*sj4))+(((-0.829953772766696)*cj3*sj4))+(((-1.0)*npy*x734))+(((-1.0)*x733*x735))+(((0.807012757742775)*sj4)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[3];
sj5=-1.0;
cj5=0;
j5=-1.5707963267949;
IkReal x737=((0.187115552300828)*cj3);
IkReal x738=(npy*pp);
IkReal x739=((3.99196157907286)*sj4);
IkReal x740=(npx*pp);
IkReal x741=((0.583703566197759)*sj4);
IkReal x742=((0.643436060492524)*cj3*sj4);
IkReal x743=((npx*npx)+(npy*npy));
j6eval[0]=x743;
j6eval[1]=((IKabs(((((0.715283218093259)*x738))+(((-1.0)*npx*x742))+((npx*x741))+(((-1.0)*npy*x737))+(((0.148024958275146)*npy))+(((-1.0)*x739*x740)))))+(IKabs((((npy*x741))+(((-1.0)*npy*x742))+(((-0.715283218093259)*x740))+(((-1.0)*x738*x739))+(((-0.148024958275146)*npx))+((npx*x737))))));
j6eval[2]=IKsign(x743);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
sj5=-1.0;
cj5=0;
j5=-1.5707963267949;
IkReal x744=npx*npx;
IkReal x745=npy*npy;
IkReal x746=(npx*sj4);
IkReal x747=((75.8472700023843)*pp);
IkReal x748=(npy*sj4);
IkReal x749=((13.5903811437719)*pp);
IkReal x750=((3.55519549371573)*cj3);
IkReal x751=((12.2252851493579)*cj3);
j6eval[0]=(x744+x745);
j6eval[1]=IKsign(((((19.0)*x745))+(((19.0)*x744))));
j6eval[2]=((IKabs(((((-1.0)*npx*x749))+((npx*x750))+(((-2.81247420722777)*npx))+(((-1.0)*x747*x748))+(((11.0903677577574)*x748))+(((-1.0)*x748*x751)))))+(IKabs((((npy*x749))+(((2.81247420722777)*npy))+(((-1.0)*x746*x747))+(((-1.0)*x746*x751))+(((11.0903677577574)*x746))+(((-1.0)*npy*x750))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j6]

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x752=(npx*sj4);
IkReal x753=((75.8472700023843)*pp);
IkReal x754=((13.5903811437719)*pp);
IkReal x755=(npy*sj4);
IkReal x756=((3.55519549371573)*cj3);
IkReal x757=((12.2252851493579)*cj3);
CheckValue<IkReal> x758=IKPowWithIntegerCheck(IKsign(((((19.0)*(npx*npx)))+(((19.0)*(npy*npy))))),-1);
if(!x758.valid){
continue;
}
CheckValue<IkReal> x759 = IKatan2WithCheck(IkReal(((((2.81247420722777)*npy))+(((11.0903677577574)*x752))+(((-1.0)*x752*x757))+(((-1.0)*x752*x753))+((npy*x754))+(((-1.0)*npy*x756)))),IkReal(((((-1.0)*npx*x754))+((npx*x756))+(((-2.81247420722777)*npx))+(((-1.0)*x755*x757))+(((-1.0)*x753*x755))+(((11.0903677577574)*x755)))),IKFAST_ATAN2_MAGTHRESH);
if(!x759.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x758.value)))+(x759.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[3];
IkReal x760=IKsin(j6);
IkReal x761=IKcos(j6);
IkReal x762=(npy*x760);
IkReal x763=(npx*x761);
evalcond[0]=((0.148024958275146)+(((-0.187115552300828)*cj3))+(((-1.0)*x762))+(((0.715283218093259)*pp))+x763);
evalcond[1]=((-0.0224997936578221)+(((-0.152)*x763))+(((0.0284415639497258)*cj3))+(((-0.108723049150175)*pp))+(((0.152)*x762)));
evalcond[2]=((((-3.99196157907286)*pp*sj4))+(((-0.643436060492524)*cj3*sj4))+(((0.583703566197759)*sj4))+(((-1.0)*npx*x760))+(((-1.0)*npy*x761)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x764=((0.187115552300828)*cj3);
IkReal x765=(npy*pp);
IkReal x766=((3.99196157907286)*sj4);
IkReal x767=(npx*pp);
IkReal x768=((0.583703566197759)*sj4);
IkReal x769=((0.643436060492524)*cj3*sj4);
CheckValue<IkReal> x770 = IKatan2WithCheck(IkReal(((((-1.0)*x766*x767))+(((-1.0)*npx*x769))+(((0.715283218093259)*x765))+(((-1.0)*npy*x764))+(((0.148024958275146)*npy))+((npx*x768)))),IkReal((((npy*x768))+(((-1.0)*x765*x766))+(((-0.715283218093259)*x767))+(((-1.0)*npy*x769))+((npx*x764))+(((-0.148024958275146)*npx)))),IKFAST_ATAN2_MAGTHRESH);
if(!x770.valid){
continue;
}
CheckValue<IkReal> x771=IKPowWithIntegerCheck(IKsign(((npx*npx)+(npy*npy))),-1);
if(!x771.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x770.value)+(((1.5707963267949)*(x771.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[3];
IkReal x772=IKsin(j6);
IkReal x773=IKcos(j6);
IkReal x774=(npy*x772);
IkReal x775=(npx*x773);
evalcond[0]=((0.148024958275146)+(((-0.187115552300828)*cj3))+(((0.715283218093259)*pp))+x775+(((-1.0)*x774)));
evalcond[1]=((-0.0224997936578221)+(((0.0284415639497258)*cj3))+(((0.152)*x774))+(((-0.108723049150175)*pp))+(((-0.152)*x775)));
evalcond[2]=((((-1.0)*npy*x773))+(((-1.0)*npx*x772))+(((-3.99196157907286)*pp*sj4))+(((-0.643436060492524)*cj3*sj4))+(((0.583703566197759)*sj4)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[2];
sj5=0;
cj5=1.0;
j5=0;
IkReal x776=npx*npx;
IkReal x777=npy*npy;
j6eval[0]=(x777+x776);
j6eval[1]=IKsign(((((19.0)*x776))+(((19.0)*x777))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j6]

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x778=((34.8455476190476)*sj4);
IkReal x779=((125.0)*pp);
IkReal x780=(cj3*npy);
IkReal x781=((10.1721875)*sj3);
IkReal x782=((32.0666619047619)*sj4);
IkReal x783=(cj3*npx);
IkReal x784=((106.038095238095)*npz*sj4);
CheckValue<IkReal> x785=IKPowWithIntegerCheck(IKsign(((((19.0)*(npx*npx)))+(((19.0)*(npy*npy))))),-1);
if(!x785.valid){
continue;
}
CheckValue<IkReal> x786 = IKatan2WithCheck(IkReal((((npx*x778))+(((-1.0)*npy*x779))+((npy*x781))+(((-24.0709375)*x780))+(((-1.0)*x782*x783))+(((-1.0)*npx*x784))+(((25.76771875)*npy)))),IkReal((((npy*x778))+(((24.0709375)*x783))+((npx*x779))+(((-1.0)*npx*x781))+(((-1.0)*npy*x784))+(((-25.76771875)*npx))+(((-1.0)*x780*x782)))),IKFAST_ATAN2_MAGTHRESH);
if(!x786.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x785.value)))+(x786.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[3];
IkReal x787=IKsin(j6);
IkReal x788=IKcos(j6);
IkReal x789=((1.0)*npx);
IkReal x790=(npy*x787);
evalcond[0]=((-0.20614175)+(((0.1925675)*cj3))+(((-0.152)*npx*x788))+pp+(((-0.0813775)*sj3))+(((0.152)*x790)));
evalcond[1]=((((-5.58095238095238)*npz*sj4))+(((-1.68771904761905)*cj3*sj4))+(((-1.0)*x787*x789))+(((1.83397619047619)*sj4))+(((-1.0)*npy*x788)));
evalcond[2]=((0.076)+(((0.293)*cj4*sj3))+(((-1.0)*x788*x789))+(((0.0525)*cj3*cj4))+x790+(((0.0775)*cj4)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[2];
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
IkReal x791=npx*npx;
IkReal x792=npy*npy;
j6eval[0]=(x791+x792);
j6eval[1]=IKsign(((((19.0)*x792))+(((19.0)*x791))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j6]

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x793=((34.8455476190476)*sj4);
IkReal x794=((125.0)*pp);
IkReal x795=(cj3*npy);
IkReal x796=((10.1721875)*sj3);
IkReal x797=((32.0666619047619)*sj4);
IkReal x798=(cj3*npx);
IkReal x799=((106.038095238095)*npz*sj4);
CheckValue<IkReal> x800=IKPowWithIntegerCheck(IKsign(((((19.0)*(npx*npx)))+(((19.0)*(npy*npy))))),-1);
if(!x800.valid){
continue;
}
CheckValue<IkReal> x801 = IKatan2WithCheck(IkReal((((npy*x796))+(((-1.0)*x797*x798))+(((-24.0709375)*x795))+(((-1.0)*npy*x794))+(((25.76771875)*npy))+((npx*x793))+((npx*x799)))),IkReal((((npy*x799))+((npy*x793))+(((24.0709375)*x798))+(((-1.0)*x795*x797))+(((-1.0)*npx*x796))+((npx*x794))+(((-25.76771875)*npx)))),IKFAST_ATAN2_MAGTHRESH);
if(!x801.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x800.value)))+(x801.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[3];
IkReal x802=IKsin(j6);
IkReal x803=IKcos(j6);
IkReal x804=((1.0)*x802);
IkReal x805=(npx*x803);
evalcond[0]=((-0.20614175)+(((-0.152)*x805))+(((0.1925675)*cj3))+(((0.152)*npy*x802))+pp+(((-0.0813775)*sj3)));
evalcond[1]=((((-1.0)*npy*x803))+(((-1.68771904761905)*cj3*sj4))+(((1.83397619047619)*sj4))+(((5.58095238095238)*npz*sj4))+(((-1.0)*npx*x804)));
evalcond[2]=((-0.076)+(((0.293)*cj4*sj3))+(((0.0525)*cj3*cj4))+(((-1.0)*npy*x804))+x805+(((0.0775)*cj4)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x806=((0.0775)*cj4);
IkReal x807=((0.076)*cj5);
IkReal x808=(cj5*sj4);
IkReal x809=((0.293)*sj3);
IkReal x810=(npz*sj5);
IkReal x811=((0.0525)*cj3);
IkReal x812=(cj4*x809);
IkReal x813=(cj4*x811);
CheckValue<IkReal> x814 = IKatan2WithCheck(IkReal(((((-1.0)*npx*x808*x809))+(((-1.0)*npy*x812))+(((-1.0)*npy*x813))+(((-0.0775)*npx*x808))+(((-1.0)*npy*x810))+(((-1.0)*npx*x808*x811))+(((-1.0)*npy*x807))+(((-1.0)*npy*x806)))),IkReal((((npx*x807))+((npx*x806))+(((-1.0)*npy*x808*x811))+(((-1.0)*npy*x808*x809))+((npx*x812))+((npx*x810))+((npx*x813))+(((-0.0775)*npy*x808)))),IKFAST_ATAN2_MAGTHRESH);
if(!x814.valid){
continue;
}
CheckValue<IkReal> x815=IKPowWithIntegerCheck(IKsign((((cj5*(npx*npx)))+((cj5*(npy*npy))))),-1);
if(!x815.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x814.value)+(((1.5707963267949)*(x815.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[5];
IkReal x816=IKsin(j6);
IkReal x817=IKcos(j6);
IkReal x818=(cj4*cj5);
IkReal x819=((0.293)*sj3);
IkReal x820=((1.0)*cj5);
IkReal x821=((0.293)*cj3);
IkReal x822=((0.0525)*cj3);
IkReal x823=((0.0525)*sj3);
IkReal x824=(npy*x816);
IkReal x825=(npx*x817);
evalcond[0]=((-0.20614175)+(((0.152)*x824))+(((-0.152)*x825))+(((0.1925675)*cj3))+pp+(((-0.0813775)*sj3)));
evalcond[1]=((((-0.0775)*sj4))+(((-1.0)*sj4*x822))+(((-1.0)*sj4*x819))+(((-1.0)*npy*x817))+(((-1.0)*npx*x816)));
evalcond[2]=((0.3425)+(((-1.0)*sj5*x825))+(((-1.0)*npz*x820))+(((0.076)*sj5))+(((-1.0)*x821))+((sj5*x824))+x823);
evalcond[3]=(((npz*sj5))+((cj5*x824))+((cj4*x822))+((cj4*x819))+(((-1.0)*x820*x825))+(((0.076)*cj5))+(((0.0775)*cj4)));
evalcond[4]=((0.076)+((sj5*x823))+(((-1.0)*x825))+(((0.0775)*x818))+((x818*x822))+(((0.3425)*sj5))+((x818*x819))+x824+(((-1.0)*sj5*x821)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x826=(cj5*npz);
IkReal x827=(sj4*sj5);
IkReal x828=((0.0525)*npy);
IkReal x829=((0.0525)*npx);
IkReal x830=((0.293)*npy);
IkReal x831=((0.293)*npx);
IkReal x832=((0.076)*sj5);
CheckValue<IkReal> x833 = IKatan2WithCheck(IkReal(((((-1.0)*npy*x832))+(((-1.0)*sj3*x827*x831))+(((-0.3425)*npy))+(((-1.0)*cj3*x827*x829))+(((-1.0)*sj3*x828))+((npy*x826))+((cj3*x830))+(((-0.0775)*npx*x827)))),IkReal(((((-0.0775)*npy*x827))+(((0.3425)*npx))+((npx*x832))+((sj3*x829))+(((-1.0)*sj3*x827*x830))+(((-1.0)*cj3*x827*x828))+(((-1.0)*npx*x826))+(((-1.0)*cj3*x831)))),IKFAST_ATAN2_MAGTHRESH);
if(!x833.valid){
continue;
}
CheckValue<IkReal> x834=IKPowWithIntegerCheck(IKsign((((sj5*(npy*npy)))+((sj5*(npx*npx))))),-1);
if(!x834.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x833.value)+(((1.5707963267949)*(x834.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[5];
IkReal x835=IKsin(j6);
IkReal x836=IKcos(j6);
IkReal x837=(cj4*cj5);
IkReal x838=((0.293)*sj3);
IkReal x839=((1.0)*cj5);
IkReal x840=((0.293)*cj3);
IkReal x841=((0.0525)*cj3);
IkReal x842=((0.0525)*sj3);
IkReal x843=(npy*x835);
IkReal x844=(npx*x836);
evalcond[0]=((-0.20614175)+(((-0.152)*x844))+(((0.152)*x843))+(((0.1925675)*cj3))+pp+(((-0.0813775)*sj3)));
evalcond[1]=((((-1.0)*npx*x835))+(((-1.0)*npy*x836))+(((-0.0775)*sj4))+(((-1.0)*sj4*x841))+(((-1.0)*sj4*x838)));
evalcond[2]=((0.3425)+(((-1.0)*sj5*x844))+(((0.076)*sj5))+(((-1.0)*npz*x839))+(((-1.0)*x840))+((sj5*x843))+x842);
evalcond[3]=(((npz*sj5))+((cj4*x841))+((cj5*x843))+((cj4*x838))+(((-1.0)*x839*x844))+(((0.076)*cj5))+(((0.0775)*cj4)));
evalcond[4]=((0.076)+((x837*x841))+((x837*x838))+((sj5*x842))+(((0.3425)*sj5))+(((-1.0)*x844))+(((-1.0)*sj5*x840))+x843+(((0.0775)*x837)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x845=((1.4725)*sj4);
IkReal x846=((125.0)*pp);
IkReal x847=((24.0709375)*cj3);
IkReal x848=(npy*sj3);
IkReal x849=((5.567)*sj4);
IkReal x850=(npx*sj3);
IkReal x851=((0.9975)*cj3*sj4);
CheckValue<IkReal> x852 = IKatan2WithCheck(IkReal(((((-1.0)*npy*x847))+(((-1.0)*npy*x846))+(((-1.0)*npx*x845))+(((-1.0)*x849*x850))+(((-1.0)*npx*x851))+(((25.76771875)*npy))+(((10.1721875)*x848)))),IkReal(((((-1.0)*npy*x845))+((npx*x847))+((npx*x846))+(((-1.0)*npy*x851))+(((-10.1721875)*x850))+(((-25.76771875)*npx))+(((-1.0)*x848*x849)))),IKFAST_ATAN2_MAGTHRESH);
if(!x852.valid){
continue;
}
CheckValue<IkReal> x853=IKPowWithIntegerCheck(IKsign(((((19.0)*(npx*npx)))+(((19.0)*(npy*npy))))),-1);
if(!x853.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x852.value)+(((1.5707963267949)*(x853.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[5];
IkReal x854=IKsin(j6);
IkReal x855=IKcos(j6);
IkReal x856=(cj4*cj5);
IkReal x857=((0.293)*sj3);
IkReal x858=((1.0)*cj5);
IkReal x859=((0.293)*cj3);
IkReal x860=((0.0525)*cj3);
IkReal x861=((0.0525)*sj3);
IkReal x862=(npy*x854);
IkReal x863=(npx*x855);
evalcond[0]=((-0.20614175)+(((0.1925675)*cj3))+(((-0.152)*x863))+pp+(((-0.0813775)*sj3))+(((0.152)*x862)));
evalcond[1]=((((-1.0)*sj4*x860))+(((-1.0)*sj4*x857))+(((-0.0775)*sj4))+(((-1.0)*npx*x854))+(((-1.0)*npy*x855)));
evalcond[2]=((0.3425)+(((-1.0)*x859))+(((0.076)*sj5))+((sj5*x862))+(((-1.0)*npz*x858))+x861+(((-1.0)*sj5*x863)));
evalcond[3]=(((npz*sj5))+(((-1.0)*x858*x863))+((cj5*x862))+((cj4*x860))+(((0.076)*cj5))+((cj4*x857))+(((0.0775)*cj4)));
evalcond[4]=((0.076)+((sj5*x861))+(((-1.0)*x863))+(((0.0775)*x856))+(((-1.0)*sj5*x859))+((x856*x860))+((x856*x857))+(((0.3425)*sj5))+x862);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x864=((1.4725)*sj4);
IkReal x865=((125.0)*pp);
IkReal x866=((24.0709375)*cj3);
IkReal x867=(npy*sj3);
IkReal x868=((5.567)*sj4);
IkReal x869=(npx*sj3);
IkReal x870=((0.9975)*cj3*sj4);
CheckValue<IkReal> x871=IKPowWithIntegerCheck(IKsign(((((19.0)*(npx*npx)))+(((19.0)*(npy*npy))))),-1);
if(!x871.valid){
continue;
}
CheckValue<IkReal> x872 = IKatan2WithCheck(IkReal(((((-1.0)*x868*x869))+(((10.1721875)*x867))+(((-1.0)*npx*x864))+(((25.76771875)*npy))+(((-1.0)*npx*x870))+(((-1.0)*npy*x865))+(((-1.0)*npy*x866)))),IkReal((((npx*x865))+((npx*x866))+(((-10.1721875)*x869))+(((-1.0)*npy*x870))+(((-1.0)*npy*x864))+(((-1.0)*x867*x868))+(((-25.76771875)*npx)))),IKFAST_ATAN2_MAGTHRESH);
if(!x872.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x871.value)))+(x872.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[2];
IkReal x873=IKsin(j6);
IkReal x874=IKcos(j6);
evalcond[0]=((-0.20614175)+(((0.1925675)*cj3))+pp+(((-0.152)*npx*x874))+(((0.152)*npy*x873))+(((-0.0813775)*sj3)));
evalcond[1]=((((-0.293)*sj3*sj4))+(((-0.0775)*sj4))+(((-0.0525)*cj3*sj4))+(((-1.0)*npx*x873))+(((-1.0)*npy*x874)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5eval[2];
IkReal x875=(cj4*npz);
IkReal x876=(cj6*npx);
IkReal x877=((73.4335839598997)*cj3);
IkReal x878=((13.1578947368421)*sj3);
IkReal x879=((0.0525)*sj3);
IkReal x880=((0.293)*cj3);
IkReal x881=(npy*sj6);
j5eval[0]=((6.52380952380952)+((x876*x877))+(((-85.8395989974937)*x876))+(((-5.58095238095238)*cj3))+(((-1.0)*x876*x878))+sj3+(((-73.4335839598997)*sj3*x875))+(((-13.1578947368421)*cj3*x875))+(((-1.0)*x877*x881))+(((-19.4235588972431)*x875))+((x878*x881))+(((85.8395989974937)*x881)));
j5eval[1]=IKsign(((0.02603)+(((-0.0775)*x875))+(((-0.0525)*cj3*x875))+(((-0.293)*sj3*x875))+(((-1.0)*x876*x879))+((x879*x881))+(((0.3425)*x881))+((x876*x880))+(((0.00399)*sj3))+(((-0.3425)*x876))+(((-0.022268)*cj3))+(((-1.0)*x880*x881))));
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  )
{
{
IkReal j5eval[2];
IkReal x882=(cj4*sj3);
IkReal x883=(cj3*cj4);
IkReal x884=(npy*sj6);
IkReal x885=(cj6*npx);
IkReal x886=(cj3*npz);
IkReal x887=((0.0775)*cj4);
IkReal x888=(npz*sj3);
IkReal x889=((19.4235588972431)*cj4);
j5eval[0]=((((73.4335839598997)*x882*x885))+(((73.4335839598997)*x886))+(((-1.0)*x883))+(((-5.58095238095238)*x882))+(((13.1578947368421)*x883*x885))+(((-85.8395989974937)*npz))+(((-1.47619047619048)*cj4))+(((-73.4335839598997)*x882*x884))+(((-13.1578947368421)*x888))+(((-13.1578947368421)*x883*x884))+((x885*x889))+(((-1.0)*x884*x889)));
j5eval[1]=IKsign(((((0.293)*x882*x885))+(((-0.293)*x882*x884))+(((-0.0525)*x883*x884))+(((-0.022268)*x882))+(((-0.3425)*npz))+(((-0.00399)*x883))+(((0.293)*x886))+(((-0.00589)*cj4))+(((-0.0525)*x888))+((x885*x887))+(((0.0525)*x883*x885))+(((-1.0)*x884*x887))));
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  )
{
{
IkReal j5eval[2];
IkReal x890=cj6*cj6;
IkReal x891=npy*npy;
IkReal x892=npz*npz;
IkReal x893=npx*npx;
IkReal x894=(npy*sj6);
IkReal x895=(cj6*npx);
IkReal x896=((173.130193905817)*x891);
IkReal x897=(x890*x893);
j5eval[0]=((-1.0)+(((-1.0)*x896))+(((-173.130193905817)*x892))+(((-173.130193905817)*x897))+(((26.3157894736842)*x895))+((x890*x896))+(((346.260387811634)*x894*x895))+(((-26.3157894736842)*x894)));
j5eval[1]=IKsign(((-0.005776)+(((0.152)*x895))+(((-1.0)*x892))+(((-1.0)*x891))+(((-1.0)*x897))+(((-0.152)*x894))+((x890*x891))+(((2.0)*x894*x895))));
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j5]

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x898=cj6*cj6;
IkReal x899=npy*npy;
IkReal x900=(cj4*sj3);
IkReal x901=(cj3*cj4);
IkReal x902=(npy*sj6);
IkReal x903=(cj6*npx);
IkReal x904=((0.293)*cj3);
IkReal x905=((0.0775)*cj4);
IkReal x906=((0.0525)*npz);
IkReal x907=((0.0525)*sj3);
CheckValue<IkReal> x908=IKPowWithIntegerCheck(IKsign(((-0.005776)+((x898*x899))+(((2.0)*x902*x903))+(((-1.0)*(npz*npz)))+(((-0.152)*x902))+(((-1.0)*x899))+(((0.152)*x903))+(((-1.0)*x898*(npx*npx))))),-1);
if(!x908.valid){
continue;
}
CheckValue<IkReal> x909 = IKatan2WithCheck(IkReal(((0.02603)+(((-1.0)*x903*x907))+((x903*x904))+(((-0.3425)*x903))+(((-1.0)*x902*x904))+((x901*x906))+(((0.293)*npz*x900))+((x902*x907))+(((0.3425)*x902))+((npz*x905))+(((0.00399)*sj3))+(((-0.022268)*cj3)))),IkReal(((((0.293)*x900*x902))+(((-1.0)*x903*x905))+(((-0.0525)*x901*x903))+(((0.00399)*x901))+(((0.0525)*x901*x902))+(((0.022268)*x900))+(((-0.293)*x900*x903))+((x902*x905))+(((-1.0)*sj3*x906))+(((-0.3425)*npz))+((npz*x904))+(((0.00589)*cj4)))),IKFAST_ATAN2_MAGTHRESH);
if(!x909.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(((1.5707963267949)*(x908.value)))+(x909.value));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[5];
IkReal x910=IKsin(j5);
IkReal x911=IKcos(j5);
IkReal x912=(npy*sj6);
IkReal x913=((0.293)*sj3);
IkReal x914=((0.293)*cj3);
IkReal x915=((0.0525)*cj4);
IkReal x916=((0.0775)*cj4);
IkReal x917=((1.0)*npz);
IkReal x918=((0.0525)*sj3);
IkReal x919=(cj3*x910);
IkReal x920=(cj4*x911);
IkReal x921=(sj3*x910);
IkReal x922=((1.0)*cj6*npx);
evalcond[0]=((0.3425)+((x910*x912))+(((-1.0)*x914))+(((-1.0)*x910*x922))+(((0.076)*x910))+x918+(((-1.0)*x911*x917)));
evalcond[1]=(((cj3*x915))+((x911*x912))+((cj4*x913))+(((0.076)*x911))+((npz*x910))+x916+(((-1.0)*x911*x922)));
evalcond[2]=((((-1.0)*cj4*x910*x913))+(((0.3425)*x911))+(((-1.0)*x917))+((x911*x918))+(((-1.0)*x910*x916))+(((-1.0)*x911*x914))+(((-1.0)*x915*x919)));
evalcond[3]=((0.076)+(((-1.0)*x922))+((x910*x918))+(((0.3425)*x910))+((x911*x916))+(((-1.0)*x910*x914))+((cj3*x911*x915))+x912+((x913*x920)));
evalcond[4]=((-0.21769375)+(((-0.01178)*x920))+(((-0.00798)*x921))+(((-0.044536)*sj3*x920))+(((0.1925675)*cj3))+(((-0.05206)*x910))+pp+(((-0.0813775)*sj3))+(((-0.00798)*cj3*x920))+(((0.044536)*x919)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x923=cj4*cj4;
IkReal x924=cj3*cj3;
IkReal x925=(npy*sj6);
IkReal x926=(cj4*sj3);
IkReal x927=(cj3*cj4);
IkReal x928=(cj6*npx);
IkReal x929=((0.0775)*cj4);
IkReal x930=(sj3*x923);
CheckValue<IkReal> x931 = IKatan2WithCheck(IkReal(((((-1.0)*npz*x928))+((npz*x925))+(((-0.08309275)*cj3*x926))+(((-0.030765)*cj4*x924))+(((-0.00472625)*x927))+(((0.04192625)*cj4))+(((0.10442125)*x926))+(((0.076)*npz)))),IkReal(((((0.030765)*cj3*x930))+(((-1.0)*(npz*npz)))+(((-0.08309275)*x923*x924))+(((0.0081375)*cj3*x923))+(((0.09185525)*x923))+(((0.045415)*x930)))),IKFAST_ATAN2_MAGTHRESH);
if(!x931.valid){
continue;
}
CheckValue<IkReal> x932=IKPowWithIntegerCheck(IKsign(((((-1.0)*x925*x929))+((x928*x929))+(((0.293)*x926*x928))+(((0.293)*cj3*npz))+(((-0.022268)*x926))+(((-0.3425)*npz))+(((-0.00399)*x927))+(((-0.293)*x925*x926))+(((-0.00589)*cj4))+(((0.0525)*x927*x928))+(((-0.0525)*x925*x927))+(((-0.0525)*npz*sj3)))),-1);
if(!x932.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(x931.value)+(((1.5707963267949)*(x932.value))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[5];
IkReal x933=IKsin(j5);
IkReal x934=IKcos(j5);
IkReal x935=(npy*sj6);
IkReal x936=((0.293)*sj3);
IkReal x937=((0.293)*cj3);
IkReal x938=((0.0525)*cj4);
IkReal x939=((0.0775)*cj4);
IkReal x940=((1.0)*npz);
IkReal x941=((0.0525)*sj3);
IkReal x942=(cj3*x933);
IkReal x943=(cj4*x934);
IkReal x944=(sj3*x933);
IkReal x945=((1.0)*cj6*npx);
evalcond[0]=((0.3425)+(((0.076)*x933))+(((-1.0)*x933*x945))+x941+((x933*x935))+(((-1.0)*x934*x940))+(((-1.0)*x937)));
evalcond[1]=(((npz*x933))+(((0.076)*x934))+((cj3*x938))+((cj4*x936))+((x934*x935))+x939+(((-1.0)*x934*x945)));
evalcond[2]=((((-1.0)*x940))+(((-1.0)*x938*x942))+(((-1.0)*x934*x937))+(((-1.0)*cj4*x933*x936))+((x934*x941))+(((0.3425)*x934))+(((-1.0)*x933*x939)));
evalcond[3]=((0.076)+(((-1.0)*x945))+((x933*x941))+((x936*x943))+(((0.3425)*x933))+((cj3*x934*x938))+(((-1.0)*x933*x937))+((x934*x939))+x935);
evalcond[4]=((-0.21769375)+(((0.044536)*x942))+(((-0.00798)*cj3*x943))+(((-0.01178)*x943))+(((-0.044536)*sj3*x943))+(((-0.05206)*x933))+(((0.1925675)*cj3))+(((-0.00798)*x944))+pp+(((-0.0813775)*sj3)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x946=cj3*cj3;
IkReal x947=(npy*sj6);
IkReal x948=(cj3*sj3);
IkReal x949=(cj6*npx);
IkReal x950=(cj4*sj3);
IkReal x951=((0.293)*cj3);
IkReal x952=(cj4*npz);
IkReal x953=((0.0525)*sj3);
CheckValue<IkReal> x954=IKPowWithIntegerCheck(IKsign(((0.02603)+(((-0.3425)*x949))+(((-0.293)*npz*x950))+((x949*x951))+(((-0.0775)*x952))+(((-1.0)*x947*x951))+((x947*x953))+(((0.00399)*sj3))+(((0.3425)*x947))+(((-1.0)*x949*x953))+(((-0.0525)*cj3*x952))+(((-0.022268)*cj3)))),-1);
if(!x954.valid){
continue;
}
CheckValue<IkReal> x955 = IKatan2WithCheck(IkReal(((-0.1200625)+(((0.200705)*cj3))+(((0.030765)*x948))+(((-0.0359625)*sj3))+(((-0.08309275)*x946))+(npz*npz))),IkReal(((((-0.04192625)*cj4))+((npz*x947))+(((0.030765)*cj4*x946))+(((0.00472625)*cj3*cj4))+(((0.08309275)*cj4*x948))+(((-0.10442125)*x950))+(((-1.0)*npz*x949))+(((0.076)*npz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x955.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(((1.5707963267949)*(x954.value)))+(x955.value));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[5];
IkReal x956=IKsin(j5);
IkReal x957=IKcos(j5);
IkReal x958=(npy*sj6);
IkReal x959=((0.293)*sj3);
IkReal x960=((0.293)*cj3);
IkReal x961=((0.0525)*cj4);
IkReal x962=((0.0775)*cj4);
IkReal x963=((1.0)*npz);
IkReal x964=((0.0525)*sj3);
IkReal x965=(cj3*x956);
IkReal x966=(cj4*x957);
IkReal x967=(sj3*x956);
IkReal x968=((1.0)*cj6*npx);
evalcond[0]=((0.3425)+(((0.076)*x956))+(((-1.0)*x956*x968))+((x956*x958))+(((-1.0)*x957*x963))+x964+(((-1.0)*x960)));
evalcond[1]=(((npz*x956))+(((0.076)*x957))+((cj3*x961))+(((-1.0)*x957*x968))+((x957*x958))+x962+((cj4*x959)));
evalcond[2]=((((-1.0)*x961*x965))+(((-1.0)*x956*x962))+(((-1.0)*cj4*x956*x959))+((x957*x964))+(((-1.0)*x957*x960))+(((-1.0)*x963))+(((0.3425)*x957)));
evalcond[3]=((0.076)+(((-1.0)*x956*x960))+((cj3*x957*x961))+((x957*x962))+((x956*x964))+((x959*x966))+x958+(((-1.0)*x968))+(((0.3425)*x956)));
evalcond[4]=((-0.21769375)+(((-0.044536)*sj3*x966))+(((-0.05206)*x956))+(((0.044536)*x965))+(((0.1925675)*cj3))+pp+(((-0.00798)*x967))+(((-0.00798)*cj3*x966))+(((-0.0813775)*sj3))+(((-0.01178)*x966)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}
    }
}
return solutions.GetNumSolutions()>0;
}
inline void rotationfunction0(IkSolutionListBase<IkReal>& solutions) {
for(int rotationiter = 0; rotationiter < 1; ++rotationiter) {
IkReal x187=((1.0)*sj4);
IkReal x188=((1.0)*sj5);
IkReal x189=((1.0)*sj3);
IkReal x190=((1.0)*cj5);
IkReal x191=((1.0)*cj4);
IkReal x192=((1.0)*sj6);
IkReal x193=((-1.0)*sj4);
IkReal x194=((-1.0)*sj5);
IkReal x195=((-1.0)*cj5);
IkReal x196=((((-1.0)*r01*x192))+((cj6*r00)));
IkReal x197=(((r00*sj6))+((cj6*r01)));
IkReal x198=((((-1.0)*r11*x192))+((cj6*r10)));
IkReal x199=(((r10*sj6))+((cj6*r11)));
IkReal x200=(((cj6*r20))+(((-1.0)*r21*x192)));
IkReal x201=(((cj6*r21))+((r20*sj6)));
IkReal x202=(cj5*x196);
IkReal x203=(cj5*x198);
IkReal x204=(cj5*x200);
IkReal x205=((((-1.0)*r02*x188))+x202);
IkReal x206=((((-1.0)*r12*x188))+x203);
IkReal x207=((((-1.0)*r22*x188))+x204);
new_r00=((((-1.0)*x189*((((x194*x196))+((r02*x195))))))+((cj3*(((((-1.0)*x187*x197))+((cj4*x205)))))));
new_r01=((((-1.0)*x187*x205))+(((-1.0)*x191*x197)));
new_r02=(((sj3*((((cj4*((x202+((r02*x194))))))+((x193*x197))))))+((cj3*(((((-1.0)*x188*x196))+(((-1.0)*r02*x190)))))));
new_r10=(((cj3*(((((-1.0)*x187*x199))+((cj4*x206))))))+(((-1.0)*x189*((((x194*x198))+((r12*x195)))))));
new_r11=((((-1.0)*x187*x206))+(((-1.0)*x191*x199)));
new_r12=(((cj3*(((((-1.0)*x188*x198))+(((-1.0)*r12*x190))))))+((sj3*((((x193*x199))+((cj4*((x203+((r12*x194)))))))))));
new_r20=(((cj3*((((cj4*((x204+((r22*x194))))))+((x193*x201))))))+(((-1.0)*x189*(((((-1.0)*r22*x190))+(((-1.0)*x188*x200)))))));
new_r21=((((-1.0)*x191*x201))+(((-1.0)*x187*x207)));
new_r22=(((cj3*((((x194*x200))+((r22*x195))))))+((sj3*(((((-1.0)*x187*x201))+((cj4*x207)))))));
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
cj1array[0]=new_r22;
if( cj1array[0] >= -1-IKFAST_SINCOS_THRESH && cj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKacos(cj1array[0]);
    sj1array[0] = IKsin(j1array[0]);
    cj1array[1] = cj1array[0];
    j1array[1] = -j1array[0];
    sj1array[1] = -sj1array[0];
}
else if( isnan(cj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

{
IkReal j0eval[3];
j0eval[0]=sj1;
j0eval[1]=((IKabs(new_r12))+(IKabs(new_r02)));
j0eval[2]=IKsign(sj1);
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[3];
j2eval[0]=sj1;
j2eval[1]=IKsign(sj1);
j2eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[2];
j0eval[0]=new_r12;
j0eval[1]=sj1;
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j1))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
IkReal j2mul = 1;
j2=0;
j0mul=-1.0;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0=IKatan2(((-1.0)*new_r01), new_r00);
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].fmul = j0mul;
vinfos[0].freeind = 0;
vinfos[0].maxsolutions = 0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].fmul = j2mul;
vinfos[2].freeind = 0;
vinfos[2].maxsolutions = 0;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(1);
vfree[0] = 2;
solutions.AddSolution(vinfos,vfree);
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j1)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
IkReal j2mul = 1;
j2=0;
j0mul=1.0;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(((-1.0)*new_r00))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0=IKatan2(((-1.0)*new_r01), ((-1.0)*new_r00));
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].fmul = j0mul;
vinfos[0].freeind = 0;
vinfos[0].maxsolutions = 0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].fmul = j2mul;
vinfos[2].freeind = 0;
vinfos[2].maxsolutions = 0;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(1);
vfree[0] = 2;
solutions.AddSolution(vinfos,vfree);
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r12))+(IKabs(new_r02)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
IkReal x208=new_r22*new_r22;
IkReal x209=((16.0)*new_r10);
IkReal x210=((16.0)*new_r01);
IkReal x211=((16.0)*new_r22);
IkReal x212=((8.0)*new_r11);
IkReal x213=((8.0)*new_r00);
IkReal x214=(x208*x209);
IkReal x215=(x208*x210);
j0eval[0]=((IKabs((((new_r22*x212))+(((-1.0)*x213)))))+(IKabs((x210+(((-1.0)*x215)))))+(IKabs(((((-1.0)*x209))+x214)))+(IKabs(((((-32.0)*new_r00*x208))+(((16.0)*new_r00))+((new_r11*x211)))))+(IKabs((((x208*x212))+(((-1.0)*new_r22*x213)))))+(IKabs((x209+(((-1.0)*x214)))))+(IKabs(((((32.0)*new_r11))+(((-16.0)*new_r11*x208))+(((-1.0)*new_r00*x211)))))+(IKabs((x215+(((-1.0)*x210))))));
if( IKabs(j0eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j0, j2]

} else
{
IkReal op[4+1], zeror[4];
int numroots;
IkReal j0evalpoly[1];
IkReal x216=new_r22*new_r22;
IkReal x217=((16.0)*new_r10);
IkReal x218=(new_r11*new_r22);
IkReal x219=(x216*x217);
IkReal x220=((((8.0)*x218))+(((-8.0)*new_r00)));
op[0]=x220;
op[1]=(x217+(((-1.0)*x219)));
op[2]=((((-32.0)*new_r00*x216))+(((16.0)*x218))+(((16.0)*new_r00)));
op[3]=(x219+(((-1.0)*x217)));
op[4]=x220;
polyroots4(op,zeror,numroots);
IkReal j0array[4], cj0array[4], sj0array[4], tempj0array[1];
int numsolutions = 0;
for(int ij0 = 0; ij0 < numroots; ++ij0)
{
IkReal htj0 = zeror[ij0];
tempj0array[0]=((2.0)*(atan(htj0)));
for(int kj0 = 0; kj0 < 1; ++kj0)
{
j0array[numsolutions] = tempj0array[kj0];
if( j0array[numsolutions] > IKPI )
{
    j0array[numsolutions]-=IK2PI;
}
else if( j0array[numsolutions] < -IKPI )
{
    j0array[numsolutions]+=IK2PI;
}
sj0array[numsolutions] = IKsin(j0array[numsolutions]);
cj0array[numsolutions] = IKcos(j0array[numsolutions]);
numsolutions++;
}
}
bool j0valid[4]={true,true,true,true};
_nj0 = 4;
for(int ij0 = 0; ij0 < numsolutions; ++ij0)
    {
if( !j0valid[ij0] )
{
    continue;
}
    j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
htj0 = IKtan(j0/2);

IkReal x221=((16.0)*new_r01);
IkReal x222=new_r22*new_r22;
IkReal x223=(new_r00*new_r22);
IkReal x224=((8.0)*x223);
IkReal x225=(new_r11*x222);
IkReal x226=(x221*x222);
IkReal x227=((8.0)*x225);
j0evalpoly[0]=((((htj0*htj0*htj0*htj0)*((x227+(((-1.0)*x224))))))+(((htj0*htj0*htj0)*((x226+(((-1.0)*x221))))))+(((htj0*htj0)*(((((32.0)*new_r11))+(((-16.0)*x225))+(((-16.0)*x223))))))+((htj0*((x221+(((-1.0)*x226))))))+x227+(((-1.0)*x224)));
if( IKabs(j0evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < numsolutions; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
{
IkReal j2eval[3];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
IkReal x228=cj0*cj0;
IkReal x229=(cj0*new_r22);
IkReal x230=((-1.0)+x228+(((-1.0)*x228*(new_r22*new_r22))));
j2eval[0]=x230;
j2eval[1]=IKsign(x230);
j2eval[2]=((IKabs((((new_r01*sj0))+(((-1.0)*new_r00*x229)))))+(IKabs((((new_r01*x229))+((new_r00*sj0))))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j2eval[0]=new_r22;
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
IkReal x231=new_r22*new_r22;
j2eval[0]=(((cj0*x231))+(((-1.0)*cj0)));
j2eval[1]=((((-1.0)*sj0))+((sj0*x231)));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j0)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x232=IKsin(j2);
IkReal x233=IKcos(j2);
evalcond[0]=x232;
evalcond[1]=((-1.0)*x233);
evalcond[2]=((((-1.0)*new_r00))+(((-1.0)*x232)));
evalcond[3]=((((-1.0)*new_r01))+(((-1.0)*x233)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j0)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(new_r00, new_r01);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x234=IKsin(j2);
IkReal x235=IKcos(j2);
evalcond[0]=x234;
evalcond[1]=((-1.0)*x235);
evalcond[2]=(new_r00+(((-1.0)*x234)));
evalcond[3]=(new_r01+(((-1.0)*x235)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j0))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(new_r10, new_r11);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x236=IKsin(j2);
IkReal x237=IKcos(j2);
evalcond[0]=x236;
evalcond[1]=((-1.0)*x237);
evalcond[2]=(new_r10+(((-1.0)*x236)));
evalcond[3]=(new_r11+(((-1.0)*x237)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j0)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r11));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x238=IKsin(j2);
IkReal x239=IKcos(j2);
evalcond[0]=x238;
evalcond[1]=((-1.0)*x239);
evalcond[2]=((((-1.0)*new_r10))+(((-1.0)*x238)));
evalcond[3]=((((-1.0)*new_r11))+(((-1.0)*x239)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
CheckValue<IkReal> x240=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x240.valid){
continue;
}
if((x240.value) < -0.00001)
continue;
IkReal gconst28=((-1.0)*(IKsqrt(x240.value)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((cj0+(((-1.0)*gconst28)))))+(IKabs(((-1.0)+(IKsign(sj0)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
if((((1.0)+(((-1.0)*(gconst28*gconst28))))) < -0.00001)
continue;
sj0=IKsqrt(((1.0)+(((-1.0)*(gconst28*gconst28)))));
cj0=gconst28;
if( (gconst28) < -1-IKFAST_SINCOS_THRESH || (gconst28) > 1+IKFAST_SINCOS_THRESH )
    continue;
j0=IKacos(gconst28);
CheckValue<IkReal> x241=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x241.valid){
continue;
}
if((x241.value) < -0.00001)
continue;
IkReal gconst28=((-1.0)*(IKsqrt(x241.value)));
j2eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if((((1.0)+(((-1.0)*(gconst28*gconst28))))) < -0.00001)
continue;
CheckValue<IkReal> x242=IKPowWithIntegerCheck(gconst28,-1);
if(!x242.valid){
continue;
}
if( IKabs((((gconst28*new_r10))+(((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst28*gconst28)))))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r11*(x242.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((gconst28*new_r10))+(((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst28*gconst28))))))))))+IKsqr((new_r11*(x242.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((((gconst28*new_r10))+(((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst28*gconst28))))))))), (new_r11*(x242.value)));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x243=IKcos(j2);
IkReal x244=IKsin(j2);
IkReal x245=((1.0)*gconst28);
if((((1.0)+(((-1.0)*gconst28*x245)))) < -0.00001)
continue;
IkReal x246=IKsqrt(((1.0)+(((-1.0)*gconst28*x245))));
IkReal x247=((1.0)*x246);
evalcond[0]=x244;
evalcond[1]=((-1.0)*x243);
evalcond[2]=((((-1.0)*x243*x245))+new_r11);
evalcond[3]=(new_r10+(((-1.0)*x244*x245)));
evalcond[4]=(new_r01+((x243*x246)));
evalcond[5]=(((x244*x246))+new_r00);
evalcond[6]=((((-1.0)*x244))+((gconst28*new_r10))+(((-1.0)*new_r00*x247)));
evalcond[7]=((((-1.0)*new_r01*x247))+(((-1.0)*x243))+((gconst28*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x248 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x248.valid){
continue;
}
CheckValue<IkReal> x249=IKPowWithIntegerCheck(IKsign(gconst28),-1);
if(!x249.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x248.value)+(((1.5707963267949)*(x249.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x250=IKcos(j2);
IkReal x251=IKsin(j2);
IkReal x252=((1.0)*gconst28);
if((((1.0)+(((-1.0)*gconst28*x252)))) < -0.00001)
continue;
IkReal x253=IKsqrt(((1.0)+(((-1.0)*gconst28*x252))));
IkReal x254=((1.0)*x253);
evalcond[0]=x251;
evalcond[1]=((-1.0)*x250);
evalcond[2]=((((-1.0)*x250*x252))+new_r11);
evalcond[3]=((((-1.0)*x251*x252))+new_r10);
evalcond[4]=(((x250*x253))+new_r01);
evalcond[5]=(((x251*x253))+new_r00);
evalcond[6]=(((gconst28*new_r10))+(((-1.0)*new_r00*x254))+(((-1.0)*x251)));
evalcond[7]=((((-1.0)*new_r01*x254))+((gconst28*new_r11))+(((-1.0)*x250)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
CheckValue<IkReal> x255=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x255.valid){
continue;
}
if((x255.value) < -0.00001)
continue;
IkReal gconst28=((-1.0)*(IKsqrt(x255.value)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.0)+(IKsign(sj0)))))+(IKabs((cj0+(((-1.0)*gconst28)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
if((((1.0)+(((-1.0)*(gconst28*gconst28))))) < -0.00001)
continue;
sj0=((-1.0)*(IKsqrt(((1.0)+(((-1.0)*(gconst28*gconst28)))))));
cj0=gconst28;
if( (gconst28) < -1-IKFAST_SINCOS_THRESH || (gconst28) > 1+IKFAST_SINCOS_THRESH )
    continue;
j0=((-1.0)*(IKacos(gconst28)));
CheckValue<IkReal> x256=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x256.valid){
continue;
}
if((x256.value) < -0.00001)
continue;
IkReal gconst28=((-1.0)*(IKsqrt(x256.value)));
j2eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if((((1.0)+(((-1.0)*(gconst28*gconst28))))) < -0.00001)
continue;
CheckValue<IkReal> x257=IKPowWithIntegerCheck(gconst28,-1);
if(!x257.valid){
continue;
}
if( IKabs((((gconst28*new_r10))+((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst28*gconst28)))))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r11*(x257.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((gconst28*new_r10))+((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst28*gconst28))))))))))+IKsqr((new_r11*(x257.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((((gconst28*new_r10))+((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst28*gconst28))))))))), (new_r11*(x257.value)));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x258=IKcos(j2);
IkReal x259=IKsin(j2);
IkReal x260=((1.0)*x258);
IkReal x261=((1.0)*x259);
if((((1.0)+(((-1.0)*(gconst28*gconst28))))) < -0.00001)
continue;
IkReal x262=IKsqrt(((1.0)+(((-1.0)*(gconst28*gconst28)))));
evalcond[0]=x259;
evalcond[1]=((-1.0)*x258);
evalcond[2]=((((-1.0)*gconst28*x260))+new_r11);
evalcond[3]=((((-1.0)*gconst28*x261))+new_r10);
evalcond[4]=(new_r01+(((-1.0)*x260*x262)));
evalcond[5]=((((-1.0)*x261*x262))+new_r00);
evalcond[6]=(((gconst28*new_r10))+((new_r00*x262))+(((-1.0)*x261)));
evalcond[7]=(((gconst28*new_r11))+((new_r01*x262))+(((-1.0)*x260)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x263 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x263.valid){
continue;
}
CheckValue<IkReal> x264=IKPowWithIntegerCheck(IKsign(gconst28),-1);
if(!x264.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x263.value)+(((1.5707963267949)*(x264.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x265=IKcos(j2);
IkReal x266=IKsin(j2);
IkReal x267=((1.0)*x265);
IkReal x268=((1.0)*x266);
if((((1.0)+(((-1.0)*(gconst28*gconst28))))) < -0.00001)
continue;
IkReal x269=IKsqrt(((1.0)+(((-1.0)*(gconst28*gconst28)))));
evalcond[0]=x266;
evalcond[1]=((-1.0)*x265);
evalcond[2]=((((-1.0)*gconst28*x267))+new_r11);
evalcond[3]=((((-1.0)*gconst28*x268))+new_r10);
evalcond[4]=((((-1.0)*x267*x269))+new_r01);
evalcond[5]=((((-1.0)*x268*x269))+new_r00);
evalcond[6]=(((gconst28*new_r10))+((new_r00*x269))+(((-1.0)*x268)));
evalcond[7]=(((gconst28*new_r11))+((new_r01*x269))+(((-1.0)*x267)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
CheckValue<IkReal> x270=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x270.valid){
continue;
}
if((x270.value) < -0.00001)
continue;
IkReal gconst29=IKsqrt(x270.value);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((cj0+(((-1.0)*gconst29)))))+(IKabs(((-1.0)+(IKsign(sj0)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
if((((1.0)+(((-1.0)*(gconst29*gconst29))))) < -0.00001)
continue;
sj0=IKsqrt(((1.0)+(((-1.0)*(gconst29*gconst29)))));
cj0=gconst29;
if( (gconst29) < -1-IKFAST_SINCOS_THRESH || (gconst29) > 1+IKFAST_SINCOS_THRESH )
    continue;
j0=IKacos(gconst29);
CheckValue<IkReal> x271=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x271.valid){
continue;
}
if((x271.value) < -0.00001)
continue;
IkReal gconst29=IKsqrt(x271.value);
j2eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if((((1.0)+(((-1.0)*(gconst29*gconst29))))) < -0.00001)
continue;
CheckValue<IkReal> x272=IKPowWithIntegerCheck(gconst29,-1);
if(!x272.valid){
continue;
}
if( IKabs((((gconst29*new_r10))+(((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst29*gconst29)))))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r11*(x272.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((gconst29*new_r10))+(((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst29*gconst29))))))))))+IKsqr((new_r11*(x272.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((((gconst29*new_r10))+(((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst29*gconst29))))))))), (new_r11*(x272.value)));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x273=IKcos(j2);
IkReal x274=IKsin(j2);
IkReal x275=((1.0)*gconst29);
if((((1.0)+(((-1.0)*gconst29*x275)))) < -0.00001)
continue;
IkReal x276=IKsqrt(((1.0)+(((-1.0)*gconst29*x275))));
IkReal x277=((1.0)*x276);
evalcond[0]=x274;
evalcond[1]=((-1.0)*x273);
evalcond[2]=((((-1.0)*x273*x275))+new_r11);
evalcond[3]=((((-1.0)*x274*x275))+new_r10);
evalcond[4]=(((x273*x276))+new_r01);
evalcond[5]=(((x274*x276))+new_r00);
evalcond[6]=(((gconst29*new_r10))+(((-1.0)*x274))+(((-1.0)*new_r00*x277)));
evalcond[7]=((((-1.0)*new_r01*x277))+((gconst29*new_r11))+(((-1.0)*x273)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x278 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x278.valid){
continue;
}
CheckValue<IkReal> x279=IKPowWithIntegerCheck(IKsign(gconst29),-1);
if(!x279.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x278.value)+(((1.5707963267949)*(x279.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x280=IKcos(j2);
IkReal x281=IKsin(j2);
IkReal x282=((1.0)*gconst29);
if((((1.0)+(((-1.0)*gconst29*x282)))) < -0.00001)
continue;
IkReal x283=IKsqrt(((1.0)+(((-1.0)*gconst29*x282))));
IkReal x284=((1.0)*x283);
evalcond[0]=x281;
evalcond[1]=((-1.0)*x280);
evalcond[2]=((((-1.0)*x280*x282))+new_r11);
evalcond[3]=((((-1.0)*x281*x282))+new_r10);
evalcond[4]=(new_r01+((x280*x283)));
evalcond[5]=(new_r00+((x281*x283)));
evalcond[6]=(((gconst29*new_r10))+(((-1.0)*new_r00*x284))+(((-1.0)*x281)));
evalcond[7]=(((gconst29*new_r11))+(((-1.0)*x280))+(((-1.0)*new_r01*x284)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
CheckValue<IkReal> x285=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x285.valid){
continue;
}
if((x285.value) < -0.00001)
continue;
IkReal gconst29=IKsqrt(x285.value);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.0)+(IKsign(sj0)))))+(IKabs((cj0+(((-1.0)*gconst29)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
if((((1.0)+(((-1.0)*(gconst29*gconst29))))) < -0.00001)
continue;
sj0=((-1.0)*(IKsqrt(((1.0)+(((-1.0)*(gconst29*gconst29)))))));
cj0=gconst29;
if( (gconst29) < -1-IKFAST_SINCOS_THRESH || (gconst29) > 1+IKFAST_SINCOS_THRESH )
    continue;
j0=((-1.0)*(IKacos(gconst29)));
CheckValue<IkReal> x286=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x286.valid){
continue;
}
if((x286.value) < -0.00001)
continue;
IkReal gconst29=IKsqrt(x286.value);
j2eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if((((1.0)+(((-1.0)*(gconst29*gconst29))))) < -0.00001)
continue;
CheckValue<IkReal> x287=IKPowWithIntegerCheck(gconst29,-1);
if(!x287.valid){
continue;
}
if( IKabs((((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst29*gconst29))))))))+((gconst29*new_r10)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r11*(x287.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst29*gconst29))))))))+((gconst29*new_r10))))+IKsqr((new_r11*(x287.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst29*gconst29))))))))+((gconst29*new_r10))), (new_r11*(x287.value)));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x288=IKcos(j2);
IkReal x289=IKsin(j2);
IkReal x290=((1.0)*x289);
IkReal x291=((1.0)*x288);
if((((1.0)+(((-1.0)*(gconst29*gconst29))))) < -0.00001)
continue;
IkReal x292=IKsqrt(((1.0)+(((-1.0)*(gconst29*gconst29)))));
evalcond[0]=x289;
evalcond[1]=((-1.0)*x288);
evalcond[2]=((((-1.0)*gconst29*x291))+new_r11);
evalcond[3]=((((-1.0)*gconst29*x290))+new_r10);
evalcond[4]=((((-1.0)*x291*x292))+new_r01);
evalcond[5]=((((-1.0)*x290*x292))+new_r00);
evalcond[6]=(((gconst29*new_r10))+(((-1.0)*x290))+((new_r00*x292)));
evalcond[7]=(((gconst29*new_r11))+(((-1.0)*x291))+((new_r01*x292)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x293 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x293.valid){
continue;
}
CheckValue<IkReal> x294=IKPowWithIntegerCheck(IKsign(gconst29),-1);
if(!x294.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x293.value)+(((1.5707963267949)*(x294.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x295=IKcos(j2);
IkReal x296=IKsin(j2);
IkReal x297=((1.0)*x296);
IkReal x298=((1.0)*x295);
if((((1.0)+(((-1.0)*(gconst29*gconst29))))) < -0.00001)
continue;
IkReal x299=IKsqrt(((1.0)+(((-1.0)*(gconst29*gconst29)))));
evalcond[0]=x296;
evalcond[1]=((-1.0)*x295);
evalcond[2]=((((-1.0)*gconst29*x298))+new_r11);
evalcond[3]=((((-1.0)*gconst29*x297))+new_r10);
evalcond[4]=((((-1.0)*x298*x299))+new_r01);
evalcond[5]=((((-1.0)*x297*x299))+new_r00);
evalcond[6]=(((gconst29*new_r10))+(((-1.0)*x297))+((new_r00*x299)));
evalcond[7]=(((gconst29*new_r11))+(((-1.0)*x298))+((new_r01*x299)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j2]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x300=new_r22*new_r22;
CheckValue<IkReal> x301=IKPowWithIntegerCheck((((cj0*x300))+(((-1.0)*cj0))),-1);
if(!x301.valid){
continue;
}
CheckValue<IkReal> x302=IKPowWithIntegerCheck(((((-1.0)*sj0))+((sj0*x300))),-1);
if(!x302.valid){
continue;
}
if( IKabs(((x301.value)*(((((-1.0)*new_r01*new_r22))+(((-1.0)*new_r10)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x302.value)*((((new_r10*new_r22))+new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x301.value)*(((((-1.0)*new_r01*new_r22))+(((-1.0)*new_r10))))))+IKsqr(((x302.value)*((((new_r10*new_r22))+new_r01))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((x301.value)*(((((-1.0)*new_r01*new_r22))+(((-1.0)*new_r10))))), ((x302.value)*((((new_r10*new_r22))+new_r01))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[10];
IkReal x303=IKsin(j2);
IkReal x304=IKcos(j2);
IkReal x305=(cj0*new_r22);
IkReal x306=(new_r22*sj0);
IkReal x307=((1.0)*sj0);
IkReal x308=((1.0)*x304);
IkReal x309=((1.0)*x303);
evalcond[0]=(((new_r11*sj0))+((new_r22*x303))+((cj0*new_r01)));
evalcond[1]=(((new_r01*x305))+((new_r11*x306))+x303);
evalcond[2]=((((-1.0)*new_r00*x307))+((cj0*new_r10))+(((-1.0)*x309)));
evalcond[3]=((((-1.0)*new_r01*x307))+((cj0*new_r11))+(((-1.0)*x308)));
evalcond[4]=(((x303*x305))+((sj0*x304))+new_r01);
evalcond[5]=(((new_r10*sj0))+(((-1.0)*new_r22*x308))+((cj0*new_r00)));
evalcond[6]=((((-1.0)*x305*x308))+((sj0*x303))+new_r00);
evalcond[7]=((((-1.0)*cj0*x308))+((x303*x306))+new_r11);
evalcond[8]=(((new_r00*x305))+((new_r10*x306))+(((-1.0)*x308)));
evalcond[9]=((((-1.0)*cj0*x309))+(((-1.0)*x306*x308))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x310=((1.0)*new_r01);
CheckValue<IkReal> x311=IKPowWithIntegerCheck(new_r22,-1);
if(!x311.valid){
continue;
}
if( IKabs(((x311.value)*(((((-1.0)*cj0*x310))+(((-1.0)*new_r11*sj0)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*sj0*x310))+((cj0*new_r11)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x311.value)*(((((-1.0)*cj0*x310))+(((-1.0)*new_r11*sj0))))))+IKsqr(((((-1.0)*sj0*x310))+((cj0*new_r11))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((x311.value)*(((((-1.0)*cj0*x310))+(((-1.0)*new_r11*sj0))))), ((((-1.0)*sj0*x310))+((cj0*new_r11))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[10];
IkReal x312=IKsin(j2);
IkReal x313=IKcos(j2);
IkReal x314=(cj0*new_r22);
IkReal x315=(new_r22*sj0);
IkReal x316=((1.0)*sj0);
IkReal x317=((1.0)*x313);
IkReal x318=((1.0)*x312);
evalcond[0]=(((new_r11*sj0))+((cj0*new_r01))+((new_r22*x312)));
evalcond[1]=(((new_r01*x314))+x312+((new_r11*x315)));
evalcond[2]=((((-1.0)*new_r00*x316))+(((-1.0)*x318))+((cj0*new_r10)));
evalcond[3]=((((-1.0)*x317))+((cj0*new_r11))+(((-1.0)*new_r01*x316)));
evalcond[4]=(((x312*x314))+((sj0*x313))+new_r01);
evalcond[5]=(((new_r10*sj0))+(((-1.0)*new_r22*x317))+((cj0*new_r00)));
evalcond[6]=(((sj0*x312))+(((-1.0)*x314*x317))+new_r00);
evalcond[7]=((((-1.0)*cj0*x317))+((x312*x315))+new_r11);
evalcond[8]=(((new_r00*x314))+(((-1.0)*x317))+((new_r10*x315)));
evalcond[9]=((((-1.0)*cj0*x318))+(((-1.0)*x315*x317))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x319=cj0*cj0;
IkReal x320=(cj0*new_r22);
CheckValue<IkReal> x321 = IKatan2WithCheck(IkReal((((new_r01*x320))+((new_r00*sj0)))),IkReal((((new_r01*sj0))+(((-1.0)*new_r00*x320)))),IKFAST_ATAN2_MAGTHRESH);
if(!x321.valid){
continue;
}
CheckValue<IkReal> x322=IKPowWithIntegerCheck(IKsign(((-1.0)+x319+(((-1.0)*x319*(new_r22*new_r22))))),-1);
if(!x322.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x321.value)+(((1.5707963267949)*(x322.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[10];
IkReal x323=IKsin(j2);
IkReal x324=IKcos(j2);
IkReal x325=(cj0*new_r22);
IkReal x326=(new_r22*sj0);
IkReal x327=((1.0)*sj0);
IkReal x328=((1.0)*x324);
IkReal x329=((1.0)*x323);
evalcond[0]=(((new_r22*x323))+((new_r11*sj0))+((cj0*new_r01)));
evalcond[1]=(((new_r01*x325))+x323+((new_r11*x326)));
evalcond[2]=((((-1.0)*x329))+(((-1.0)*new_r00*x327))+((cj0*new_r10)));
evalcond[3]=((((-1.0)*x328))+(((-1.0)*new_r01*x327))+((cj0*new_r11)));
evalcond[4]=(((x323*x325))+((sj0*x324))+new_r01);
evalcond[5]=((((-1.0)*new_r22*x328))+((new_r10*sj0))+((cj0*new_r00)));
evalcond[6]=((((-1.0)*x325*x328))+((sj0*x323))+new_r00);
evalcond[7]=(((x323*x326))+(((-1.0)*cj0*x328))+new_r11);
evalcond[8]=(((new_r00*x325))+(((-1.0)*x328))+((new_r10*x326)));
evalcond[9]=((((-1.0)*x326*x328))+(((-1.0)*cj0*x329))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0, j2]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
CheckValue<IkReal> x331=IKPowWithIntegerCheck(sj1,-1);
if(!x331.valid){
continue;
}
IkReal x330=x331.value;
CheckValue<IkReal> x332=IKPowWithIntegerCheck(new_r12,-1);
if(!x332.valid){
continue;
}
if( IKabs((x330*(x332.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj1*cj1))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r02*x330)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x330*(x332.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj1*cj1)))))))+IKsqr((new_r02*x330))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0array[0]=IKatan2((x330*(x332.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj1*cj1)))))), (new_r02*x330));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[8];
IkReal x333=IKcos(j0);
IkReal x334=IKsin(j0);
IkReal x335=((1.0)*cj1);
IkReal x336=((1.0)*sj1);
IkReal x337=(new_r12*x334);
IkReal x338=(new_r02*x333);
evalcond[0]=((((-1.0)*x333*x336))+new_r02);
evalcond[1]=(new_r12+(((-1.0)*x334*x336)));
evalcond[2]=(((new_r12*x333))+(((-1.0)*new_r02*x334)));
evalcond[3]=(x338+x337+(((-1.0)*x336)));
evalcond[4]=((((-1.0)*new_r22*x336))+((cj1*x338))+((cj1*x337)));
evalcond[5]=((((-1.0)*new_r20*x335))+(((-1.0)*new_r00*x333*x336))+(((-1.0)*new_r10*x334*x336)));
evalcond[6]=((((-1.0)*new_r11*x334*x336))+(((-1.0)*new_r21*x335))+(((-1.0)*new_r01*x333*x336)));
evalcond[7]=((1.0)+(((-1.0)*new_r22*x335))+(((-1.0)*x336*x337))+(((-1.0)*x336*x338)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j2eval[3];
j2eval[0]=sj1;
j2eval[1]=IKsign(sj1);
j2eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
j2eval[0]=sj0;
j2eval[1]=sj1;
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal j2eval[3];
j2eval[0]=cj0;
j2eval[1]=cj1;
j2eval[2]=sj1;
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j0)))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[3];
sj0=1.0;
cj0=0;
j0=1.5707963267949;
j2eval[0]=sj1;
j2eval[1]=IKsign(sj1);
j2eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[3];
sj0=1.0;
cj0=0;
j0=1.5707963267949;
j2eval[0]=cj1;
j2eval[1]=IKsign(cj1);
j2eval[2]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[1];
sj0=1.0;
cj0=0;
j0=1.5707963267949;
j2eval[0]=sj1;
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j1))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r12;
evalcond[3]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r11))+IKsqr(new_r10)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r11), new_r10);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x339=IKsin(j2);
IkReal x340=((1.0)*(IKcos(j2)));
evalcond[0]=(x339+new_r11);
evalcond[1]=(new_r10+(((-1.0)*x340)));
evalcond[2]=((((-1.0)*x339))+(((-1.0)*new_r00)));
evalcond[3]=((((-1.0)*new_r01))+(((-1.0)*x340)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j1)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r12;
evalcond[3]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r11)+IKsqr(((-1.0)*new_r10))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(new_r11, ((-1.0)*new_r10));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x341=IKcos(j2);
IkReal x342=((1.0)*(IKsin(j2)));
evalcond[0]=(x341+new_r10);
evalcond[1]=(new_r11+(((-1.0)*x342)));
evalcond[2]=((((-1.0)*new_r00))+(((-1.0)*x342)));
evalcond[3]=((((-1.0)*new_r01))+(((-1.0)*x341)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j1)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r11;
evalcond[3]=new_r10;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x343=IKcos(j2);
IkReal x344=((1.0)*(IKsin(j2)));
evalcond[0]=(x343+new_r20);
evalcond[1]=(new_r21+(((-1.0)*x344)));
evalcond[2]=((((-1.0)*new_r00))+(((-1.0)*x344)));
evalcond[3]=((((-1.0)*new_r01))+(((-1.0)*x343)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j1)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r11;
evalcond[3]=new_r10;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x345=IKsin(j2);
IkReal x346=((1.0)*(IKcos(j2)));
evalcond[0]=(x345+new_r21);
evalcond[1]=(new_r20+(((-1.0)*x346)));
evalcond[2]=((((-1.0)*new_r00))+(((-1.0)*x345)));
evalcond[3]=((((-1.0)*new_r01))+(((-1.0)*x346)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x347=IKsin(j2);
IkReal x348=IKcos(j2);
IkReal x349=((-1.0)*x348);
evalcond[0]=x347;
evalcond[1]=(new_r22*x347);
evalcond[2]=x349;
evalcond[3]=(new_r22*x349);
evalcond[4]=((((-1.0)*new_r00))+(((-1.0)*x347)));
evalcond[5]=((((-1.0)*new_r01))+(((-1.0)*x348)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j2]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x350=IKPowWithIntegerCheck(sj1,-1);
if(!x350.valid){
continue;
}
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*(x350.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r20*(x350.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r20*(x350.value)));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x351=IKsin(j2);
IkReal x352=IKcos(j2);
IkReal x353=((1.0)*sj1);
IkReal x354=((1.0)*x352);
evalcond[0]=(((sj1*x352))+new_r20);
evalcond[1]=(((cj1*x351))+new_r11);
evalcond[2]=((((-1.0)*x351*x353))+new_r21);
evalcond[3]=((((-1.0)*cj1*x354))+new_r10);
evalcond[4]=((((-1.0)*x351))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x354))+(((-1.0)*new_r01)));
evalcond[6]=(((cj1*new_r11))+x351+(((-1.0)*new_r21*x353)));
evalcond[7]=((((-1.0)*x354))+((cj1*new_r10))+(((-1.0)*new_r20*x353)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x355=IKPowWithIntegerCheck(IKsign(cj1),-1);
if(!x355.valid){
continue;
}
CheckValue<IkReal> x356 = IKatan2WithCheck(IkReal(((-1.0)*new_r11)),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x356.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x355.value)))+(x356.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x357=IKsin(j2);
IkReal x358=IKcos(j2);
IkReal x359=((1.0)*sj1);
IkReal x360=((1.0)*x358);
evalcond[0]=(((sj1*x358))+new_r20);
evalcond[1]=(((cj1*x357))+new_r11);
evalcond[2]=((((-1.0)*x357*x359))+new_r21);
evalcond[3]=((((-1.0)*cj1*x360))+new_r10);
evalcond[4]=((((-1.0)*x357))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x360))+(((-1.0)*new_r01)));
evalcond[6]=(((cj1*new_r11))+x357+(((-1.0)*new_r21*x359)));
evalcond[7]=((((-1.0)*x360))+((cj1*new_r10))+(((-1.0)*new_r20*x359)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x361=IKPowWithIntegerCheck(IKsign(sj1),-1);
if(!x361.valid){
continue;
}
CheckValue<IkReal> x362 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x362.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x361.value)))+(x362.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x363=IKsin(j2);
IkReal x364=IKcos(j2);
IkReal x365=((1.0)*sj1);
IkReal x366=((1.0)*x364);
evalcond[0]=(((sj1*x364))+new_r20);
evalcond[1]=(((cj1*x363))+new_r11);
evalcond[2]=((((-1.0)*x363*x365))+new_r21);
evalcond[3]=((((-1.0)*cj1*x366))+new_r10);
evalcond[4]=((((-1.0)*x363))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x366))+(((-1.0)*new_r01)));
evalcond[6]=(((cj1*new_r11))+x363+(((-1.0)*new_r21*x365)));
evalcond[7]=((((-1.0)*new_r20*x365))+(((-1.0)*x366))+((cj1*new_r10)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j0)))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(new_r00, new_r01);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x367=IKcos(j2);
IkReal x368=IKsin(j2);
IkReal x369=((1.0)*sj1);
IkReal x370=((1.0)*new_r11);
IkReal x371=((1.0)*new_r10);
IkReal x372=((1.0)*x367);
evalcond[0]=(((sj1*x367))+new_r20);
evalcond[1]=((((-1.0)*x368))+new_r00);
evalcond[2]=((((-1.0)*x372))+new_r01);
evalcond[3]=(new_r21+(((-1.0)*x368*x369)));
evalcond[4]=((((-1.0)*x370))+((cj1*x368)));
evalcond[5]=((((-1.0)*cj1*x372))+(((-1.0)*x371)));
evalcond[6]=((((-1.0)*cj1*x370))+x368+(((-1.0)*new_r21*x369)));
evalcond[7]=((((-1.0)*new_r20*x369))+(((-1.0)*cj1*x371))+(((-1.0)*x372)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j1)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x373=IKcos(j2);
IkReal x374=IKsin(j2);
IkReal x375=((1.0)*sj0);
IkReal x376=((1.0)*x374);
IkReal x377=((1.0)*x373);
evalcond[0]=(x373+new_r20);
evalcond[1]=((((-1.0)*x376))+new_r21);
evalcond[2]=(((sj0*x373))+new_r01);
evalcond[3]=(((sj0*x374))+new_r00);
evalcond[4]=(new_r11+(((-1.0)*cj0*x377)));
evalcond[5]=(new_r10+(((-1.0)*new_r02*x376)));
evalcond[6]=((((-1.0)*new_r00*x375))+(((-1.0)*x376))+((cj0*new_r10)));
evalcond[7]=((((-1.0)*x377))+((cj0*new_r11))+(((-1.0)*new_r01*x375)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j1)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x378=IKcos(j2);
IkReal x379=IKsin(j2);
IkReal x380=((1.0)*sj0);
IkReal x381=((1.0)*x378);
evalcond[0]=(x379+new_r21);
evalcond[1]=((((-1.0)*x381))+new_r20);
evalcond[2]=(((sj0*x378))+new_r01);
evalcond[3]=(((sj0*x379))+new_r00);
evalcond[4]=(new_r10+((new_r02*x379)));
evalcond[5]=((((-1.0)*cj0*x381))+new_r11);
evalcond[6]=((((-1.0)*x379))+(((-1.0)*new_r00*x380))+((cj0*new_r10)));
evalcond[7]=((((-1.0)*new_r01*x380))+(((-1.0)*x381))+((cj0*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j1))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x382=((1.0)*new_r01);
if( IKabs(((((-1.0)*cj0*x382))+(((-1.0)*new_r00*sj0)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*sj0*x382))+((cj0*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj0*x382))+(((-1.0)*new_r00*sj0))))+IKsqr(((((-1.0)*sj0*x382))+((cj0*new_r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*cj0*x382))+(((-1.0)*new_r00*sj0))), ((((-1.0)*sj0*x382))+((cj0*new_r00))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x383=IKsin(j2);
IkReal x384=IKcos(j2);
IkReal x385=((1.0)*sj0);
IkReal x386=((1.0)*x384);
IkReal x387=(sj0*x383);
IkReal x388=(cj0*x383);
IkReal x389=(cj0*x386);
evalcond[0]=(((new_r11*sj0))+x383+((cj0*new_r01)));
evalcond[1]=(x388+new_r01+((sj0*x384)));
evalcond[2]=(((new_r10*sj0))+(((-1.0)*x386))+((cj0*new_r00)));
evalcond[3]=((((-1.0)*new_r00*x385))+(((-1.0)*x383))+((cj0*new_r10)));
evalcond[4]=((((-1.0)*new_r01*x385))+(((-1.0)*x386))+((cj0*new_r11)));
evalcond[5]=(x387+(((-1.0)*x389))+new_r00);
evalcond[6]=(x387+(((-1.0)*x389))+new_r11);
evalcond[7]=((((-1.0)*x384*x385))+(((-1.0)*x388))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j1)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x390=((1.0)*sj0);
if( IKabs((((cj0*new_r01))+(((-1.0)*new_r00*x390)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*x390))+(((-1.0)*cj0*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj0*new_r01))+(((-1.0)*new_r00*x390))))+IKsqr(((((-1.0)*new_r01*x390))+(((-1.0)*cj0*new_r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((((cj0*new_r01))+(((-1.0)*new_r00*x390))), ((((-1.0)*new_r01*x390))+(((-1.0)*cj0*new_r00))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x391=IKsin(j2);
IkReal x392=IKcos(j2);
IkReal x393=((1.0)*sj0);
IkReal x394=((1.0)*x391);
IkReal x395=(sj0*x392);
IkReal x396=((1.0)*x392);
IkReal x397=(cj0*x394);
evalcond[0]=(((new_r10*sj0))+x392+((cj0*new_r00)));
evalcond[1]=((((-1.0)*x394))+((new_r11*sj0))+((cj0*new_r01)));
evalcond[2]=(((cj0*x392))+((sj0*x391))+new_r00);
evalcond[3]=((((-1.0)*x394))+(((-1.0)*new_r00*x393))+((cj0*new_r10)));
evalcond[4]=((((-1.0)*new_r01*x393))+(((-1.0)*x396))+((cj0*new_r11)));
evalcond[5]=((((-1.0)*x397))+x395+new_r01);
evalcond[6]=((((-1.0)*x397))+x395+new_r10);
evalcond[7]=((((-1.0)*cj0*x396))+(((-1.0)*x391*x393))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j0))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(new_r10, new_r11);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x398=IKcos(j2);
IkReal x399=IKsin(j2);
IkReal x400=((1.0)*sj1);
IkReal x401=((1.0)*x398);
evalcond[0]=(((sj1*x398))+new_r20);
evalcond[1]=((((-1.0)*x399))+new_r10);
evalcond[2]=(new_r11+(((-1.0)*x401)));
evalcond[3]=(((cj1*x399))+new_r01);
evalcond[4]=((((-1.0)*x399*x400))+new_r21);
evalcond[5]=((((-1.0)*cj1*x401))+new_r00);
evalcond[6]=(((cj1*new_r01))+x399+(((-1.0)*new_r21*x400)));
evalcond[7]=(((cj1*new_r00))+(((-1.0)*new_r20*x400))+(((-1.0)*x401)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j0)))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[3];
sj0=0;
cj0=-1.0;
j0=3.14159265358979;
j2eval[0]=sj1;
j2eval[1]=IKsign(sj1);
j2eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[1];
sj0=0;
cj0=-1.0;
j0=3.14159265358979;
j2eval[0]=sj1;
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
sj0=0;
cj0=-1.0;
j0=3.14159265358979;
j2eval[0]=cj1;
j2eval[1]=sj1;
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j1)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r01;
evalcond[3]=new_r00;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x402=IKcos(j2);
IkReal x403=((1.0)*(IKsin(j2)));
evalcond[0]=(x402+new_r20);
evalcond[1]=(new_r21+(((-1.0)*x403)));
evalcond[2]=((((-1.0)*new_r10))+(((-1.0)*x403)));
evalcond[3]=((((-1.0)*new_r11))+(((-1.0)*x402)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j1)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r01;
evalcond[3]=new_r00;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x404=IKsin(j2);
IkReal x405=((1.0)*(IKcos(j2)));
evalcond[0]=(x404+new_r21);
evalcond[1]=(new_r20+(((-1.0)*x405)));
evalcond[2]=((((-1.0)*new_r10))+(((-1.0)*x404)));
evalcond[3]=((((-1.0)*new_r11))+(((-1.0)*x405)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j1))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(new_r01, ((-1.0)*new_r11));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x406=IKsin(j2);
IkReal x407=((1.0)*(IKcos(j2)));
evalcond[0]=(x406+(((-1.0)*new_r01)));
evalcond[1]=((((-1.0)*new_r10))+(((-1.0)*x406)));
evalcond[2]=((((-1.0)*new_r11))+(((-1.0)*x407)));
evalcond[3]=((((-1.0)*new_r00))+(((-1.0)*x407)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j1)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r10), new_r00);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x408=IKcos(j2);
IkReal x409=((1.0)*(IKsin(j2)));
evalcond[0]=(x408+(((-1.0)*new_r00)));
evalcond[1]=((((-1.0)*new_r10))+(((-1.0)*x409)));
evalcond[2]=((((-1.0)*new_r11))+(((-1.0)*x408)));
evalcond[3]=((((-1.0)*new_r01))+(((-1.0)*x409)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r11));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x410=IKsin(j2);
IkReal x411=IKcos(j2);
IkReal x412=((-1.0)*x411);
evalcond[0]=x410;
evalcond[1]=(new_r22*x410);
evalcond[2]=x412;
evalcond[3]=(new_r22*x412);
evalcond[4]=((((-1.0)*new_r10))+(((-1.0)*x410)));
evalcond[5]=((((-1.0)*new_r11))+(((-1.0)*x411)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j2]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x413=IKPowWithIntegerCheck(cj1,-1);
if(!x413.valid){
continue;
}
CheckValue<IkReal> x414=IKPowWithIntegerCheck(sj1,-1);
if(!x414.valid){
continue;
}
if( IKabs((new_r01*(x413.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*(x414.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r01*(x413.value)))+IKsqr(((-1.0)*new_r20*(x414.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((new_r01*(x413.value)), ((-1.0)*new_r20*(x414.value)));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x415=IKsin(j2);
IkReal x416=IKcos(j2);
IkReal x417=((1.0)*new_r00);
IkReal x418=((1.0)*sj1);
IkReal x419=((1.0)*new_r01);
IkReal x420=((1.0)*x416);
evalcond[0]=(((sj1*x416))+new_r20);
evalcond[1]=((((-1.0)*x415*x418))+new_r21);
evalcond[2]=((((-1.0)*new_r10))+(((-1.0)*x415)));
evalcond[3]=((((-1.0)*x420))+(((-1.0)*new_r11)));
evalcond[4]=((((-1.0)*x419))+((cj1*x415)));
evalcond[5]=((((-1.0)*cj1*x420))+(((-1.0)*x417)));
evalcond[6]=((((-1.0)*cj1*x419))+x415+(((-1.0)*new_r21*x418)));
evalcond[7]=((((-1.0)*cj1*x417))+(((-1.0)*x420))+(((-1.0)*new_r20*x418)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x421=IKPowWithIntegerCheck(sj1,-1);
if(!x421.valid){
continue;
}
if( IKabs((new_r21*(x421.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r21*(x421.value)))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((new_r21*(x421.value)), ((-1.0)*new_r11));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x422=IKsin(j2);
IkReal x423=IKcos(j2);
IkReal x424=((1.0)*new_r00);
IkReal x425=((1.0)*sj1);
IkReal x426=((1.0)*new_r01);
IkReal x427=((1.0)*x423);
evalcond[0]=(new_r20+((sj1*x423)));
evalcond[1]=((((-1.0)*x422*x425))+new_r21);
evalcond[2]=((((-1.0)*x422))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x427))+(((-1.0)*new_r11)));
evalcond[4]=((((-1.0)*x426))+((cj1*x422)));
evalcond[5]=((((-1.0)*cj1*x427))+(((-1.0)*x424)));
evalcond[6]=((((-1.0)*cj1*x426))+x422+(((-1.0)*new_r21*x425)));
evalcond[7]=((((-1.0)*cj1*x424))+(((-1.0)*x427))+(((-1.0)*new_r20*x425)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x428=IKPowWithIntegerCheck(IKsign(sj1),-1);
if(!x428.valid){
continue;
}
CheckValue<IkReal> x429 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x429.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x428.value)))+(x429.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x430=IKsin(j2);
IkReal x431=IKcos(j2);
IkReal x432=((1.0)*new_r00);
IkReal x433=((1.0)*sj1);
IkReal x434=((1.0)*new_r01);
IkReal x435=((1.0)*x431);
evalcond[0]=(new_r20+((sj1*x431)));
evalcond[1]=((((-1.0)*x430*x433))+new_r21);
evalcond[2]=((((-1.0)*x430))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x435))+(((-1.0)*new_r11)));
evalcond[4]=((((-1.0)*x434))+((cj1*x430)));
evalcond[5]=((((-1.0)*x432))+(((-1.0)*cj1*x435)));
evalcond[6]=((((-1.0)*cj1*x434))+x430+(((-1.0)*new_r21*x433)));
evalcond[7]=((((-1.0)*x435))+(((-1.0)*cj1*x432))+(((-1.0)*new_r20*x433)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[1];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
j2eval[0]=IKabs(new_r22);
if( IKabs(j2eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j2]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
op[0]=new_r22;
op[1]=0;
op[2]=((-1.0)*new_r22);
polyroots2(op,zeror,numroots);
IkReal j2array[2], cj2array[2], sj2array[2], tempj2array[1];
int numsolutions = 0;
for(int ij2 = 0; ij2 < numroots; ++ij2)
{
IkReal htj2 = zeror[ij2];
tempj2array[0]=((2.0)*(atan(htj2)));
for(int kj2 = 0; kj2 < 1; ++kj2)
{
j2array[numsolutions] = tempj2array[kj2];
if( j2array[numsolutions] > IKPI )
{
    j2array[numsolutions]-=IK2PI;
}
else if( j2array[numsolutions] < -IKPI )
{
    j2array[numsolutions]+=IK2PI;
}
sj2array[numsolutions] = IKsin(j2array[numsolutions]);
cj2array[numsolutions] = IKcos(j2array[numsolutions]);
numsolutions++;
}
}
bool j2valid[2]={true,true};
_nj2 = 2;
for(int ij2 = 0; ij2 < numsolutions; ++ij2)
    {
if( !j2valid[ij2] )
{
    continue;
}
    j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
htj2 = IKtan(j2/2);

_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < numsolutions; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j2]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x437=IKPowWithIntegerCheck(sj1,-1);
if(!x437.valid){
continue;
}
IkReal x436=x437.value;
CheckValue<IkReal> x438=IKPowWithIntegerCheck(cj0,-1);
if(!x438.valid){
continue;
}
CheckValue<IkReal> x439=IKPowWithIntegerCheck(cj1,-1);
if(!x439.valid){
continue;
}
if( IKabs((x436*(x438.value)*(x439.value)*((((new_r20*sj0))+(((-1.0)*new_r01*sj1)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x436)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x436*(x438.value)*(x439.value)*((((new_r20*sj0))+(((-1.0)*new_r01*sj1))))))+IKsqr(((-1.0)*new_r20*x436))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((x436*(x438.value)*(x439.value)*((((new_r20*sj0))+(((-1.0)*new_r01*sj1))))), ((-1.0)*new_r20*x436));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[12];
IkReal x440=IKsin(j2);
IkReal x441=IKcos(j2);
IkReal x442=((1.0)*sj1);
IkReal x443=((1.0)*sj0);
IkReal x444=(cj0*new_r00);
IkReal x445=(cj0*cj1);
IkReal x446=(new_r11*sj0);
IkReal x447=(new_r10*sj0);
IkReal x448=((1.0)*x441);
IkReal x449=(cj1*x440);
IkReal x450=((1.0)*x440);
evalcond[0]=(((sj1*x441))+new_r20);
evalcond[1]=(new_r21+(((-1.0)*x440*x442)));
evalcond[2]=(x449+x446+((cj0*new_r01)));
evalcond[3]=((((-1.0)*new_r00*x443))+(((-1.0)*x450))+((cj0*new_r10)));
evalcond[4]=((((-1.0)*x448))+(((-1.0)*new_r01*x443))+((cj0*new_r11)));
evalcond[5]=(((sj0*x441))+((x440*x445))+new_r01);
evalcond[6]=((((-1.0)*cj1*x448))+x444+x447);
evalcond[7]=(((sj0*x440))+(((-1.0)*x445*x448))+new_r00);
evalcond[8]=(((sj0*x449))+new_r11+(((-1.0)*cj0*x448)));
evalcond[9]=((((-1.0)*cj0*x450))+new_r10+(((-1.0)*cj1*x441*x443)));
evalcond[10]=(((new_r01*x445))+((cj1*x446))+x440+(((-1.0)*new_r21*x442)));
evalcond[11]=((((-1.0)*x448))+((cj1*x447))+((cj1*x444))+(((-1.0)*new_r20*x442)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x452=IKPowWithIntegerCheck(sj1,-1);
if(!x452.valid){
continue;
}
IkReal x451=x452.value;
CheckValue<IkReal> x453=IKPowWithIntegerCheck(sj0,-1);
if(!x453.valid){
continue;
}
if( IKabs((x451*(x453.value)*(((((-1.0)*cj0*cj1*new_r20))+(((-1.0)*new_r00*sj1)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x451)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x451*(x453.value)*(((((-1.0)*cj0*cj1*new_r20))+(((-1.0)*new_r00*sj1))))))+IKsqr(((-1.0)*new_r20*x451))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((x451*(x453.value)*(((((-1.0)*cj0*cj1*new_r20))+(((-1.0)*new_r00*sj1))))), ((-1.0)*new_r20*x451));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[12];
IkReal x454=IKsin(j2);
IkReal x455=IKcos(j2);
IkReal x456=((1.0)*sj1);
IkReal x457=((1.0)*sj0);
IkReal x458=(cj0*new_r00);
IkReal x459=(cj0*cj1);
IkReal x460=(new_r11*sj0);
IkReal x461=(new_r10*sj0);
IkReal x462=((1.0)*x455);
IkReal x463=(cj1*x454);
IkReal x464=((1.0)*x454);
evalcond[0]=(((sj1*x455))+new_r20);
evalcond[1]=((((-1.0)*x454*x456))+new_r21);
evalcond[2]=(x463+x460+((cj0*new_r01)));
evalcond[3]=((((-1.0)*x464))+(((-1.0)*new_r00*x457))+((cj0*new_r10)));
evalcond[4]=((((-1.0)*new_r01*x457))+(((-1.0)*x462))+((cj0*new_r11)));
evalcond[5]=(((x454*x459))+((sj0*x455))+new_r01);
evalcond[6]=((((-1.0)*cj1*x462))+x458+x461);
evalcond[7]=((((-1.0)*x459*x462))+((sj0*x454))+new_r00);
evalcond[8]=((((-1.0)*cj0*x462))+((sj0*x463))+new_r11);
evalcond[9]=((((-1.0)*cj0*x464))+(((-1.0)*cj1*x455*x457))+new_r10);
evalcond[10]=((((-1.0)*new_r21*x456))+((new_r01*x459))+((cj1*x460))+x454);
evalcond[11]=((((-1.0)*new_r20*x456))+((cj1*x458))+((cj1*x461))+(((-1.0)*x462)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x465=IKPowWithIntegerCheck(IKsign(sj1),-1);
if(!x465.valid){
continue;
}
CheckValue<IkReal> x466 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x466.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x465.value)))+(x466.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[12];
IkReal x467=IKsin(j2);
IkReal x468=IKcos(j2);
IkReal x469=((1.0)*sj1);
IkReal x470=((1.0)*sj0);
IkReal x471=(cj0*new_r00);
IkReal x472=(cj0*cj1);
IkReal x473=(new_r11*sj0);
IkReal x474=(new_r10*sj0);
IkReal x475=((1.0)*x468);
IkReal x476=(cj1*x467);
IkReal x477=((1.0)*x467);
evalcond[0]=(((sj1*x468))+new_r20);
evalcond[1]=(new_r21+(((-1.0)*x467*x469)));
evalcond[2]=(x476+x473+((cj0*new_r01)));
evalcond[3]=((((-1.0)*new_r00*x470))+(((-1.0)*x477))+((cj0*new_r10)));
evalcond[4]=((((-1.0)*x475))+(((-1.0)*new_r01*x470))+((cj0*new_r11)));
evalcond[5]=(((x467*x472))+((sj0*x468))+new_r01);
evalcond[6]=((((-1.0)*cj1*x475))+x474+x471);
evalcond[7]=((((-1.0)*x472*x475))+((sj0*x467))+new_r00);
evalcond[8]=((((-1.0)*cj0*x475))+new_r11+((sj0*x476)));
evalcond[9]=((((-1.0)*cj0*x477))+(((-1.0)*cj1*x468*x470))+new_r10);
evalcond[10]=((((-1.0)*new_r21*x469))+((new_r01*x472))+((cj1*x473))+x467);
evalcond[11]=((((-1.0)*new_r20*x469))+(((-1.0)*x475))+((cj1*x474))+((cj1*x471)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x478=IKPowWithIntegerCheck(IKsign(sj1),-1);
if(!x478.valid){
continue;
}
CheckValue<IkReal> x479 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x479.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x478.value)))+(x479.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[2];
evalcond[0]=(((sj1*(IKcos(j2))))+new_r20);
evalcond[1]=((((-1.0)*sj1*(IKsin(j2))))+new_r21);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0eval[3];
j0eval[0]=sj1;
j0eval[1]=((IKabs(new_r12))+(IKabs(new_r02)));
j0eval[2]=IKsign(sj1);
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[2];
j0eval[0]=cj2;
j0eval[1]=sj1;
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j2)))), 6.28318530717959)));
evalcond[1]=new_r20;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(new_r10)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0array[0]=IKatan2(((-1.0)*new_r00), new_r10);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[18];
IkReal x480=IKsin(j0);
IkReal x481=IKcos(j0);
IkReal x482=((1.0)*sj1);
IkReal x483=((1.0)*cj1);
IkReal x484=(new_r10*x480);
IkReal x485=(new_r01*x481);
IkReal x486=(new_r00*x481);
IkReal x487=((1.0)*x480);
IkReal x488=(new_r11*x480);
IkReal x489=(new_r12*x480);
IkReal x490=(cj1*x481);
IkReal x491=(new_r02*x481);
evalcond[0]=(x480+new_r00);
evalcond[1]=(x490+new_r01);
evalcond[2]=(((cj1*x480))+new_r11);
evalcond[3]=((((-1.0)*x481))+new_r10);
evalcond[4]=((((-1.0)*x481*x482))+new_r02);
evalcond[5]=((((-1.0)*x480*x482))+new_r12);
evalcond[6]=(x484+x486);
evalcond[7]=(((new_r12*x481))+(((-1.0)*new_r02*x487)));
evalcond[8]=((((-1.0)*new_r01*x487))+((new_r11*x481)));
evalcond[9]=(cj1+x488+x485);
evalcond[10]=((-1.0)+(((-1.0)*new_r00*x487))+((new_r10*x481)));
evalcond[11]=(((cj1*x484))+((cj1*x486)));
evalcond[12]=((((-1.0)*x482))+x489+x491);
evalcond[13]=((((-1.0)*x482*x484))+(((-1.0)*x482*x486)));
evalcond[14]=(((new_r02*x490))+((cj1*x489))+(((-1.0)*new_r22*x482)));
evalcond[15]=((1.0)+(((-1.0)*new_r21*x482))+((cj1*x488))+((cj1*x485)));
evalcond[16]=((((-1.0)*new_r21*x483))+(((-1.0)*x482*x485))+(((-1.0)*x482*x488)));
evalcond[17]=((1.0)+(((-1.0)*x482*x491))+(((-1.0)*x482*x489))+(((-1.0)*new_r22*x483)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j2)))), 6.28318530717959)));
evalcond[1]=new_r20;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(((-1.0)*new_r10))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0array[0]=IKatan2(new_r00, ((-1.0)*new_r10));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[18];
IkReal x492=IKcos(j0);
IkReal x493=IKsin(j0);
IkReal x494=((1.0)*sj1);
IkReal x495=((1.0)*cj1);
IkReal x496=(new_r10*x493);
IkReal x497=(new_r01*x492);
IkReal x498=(new_r00*x492);
IkReal x499=((1.0)*x493);
IkReal x500=(new_r11*x493);
IkReal x501=(new_r12*x493);
IkReal x502=(new_r02*x492);
evalcond[0]=(x492+new_r10);
evalcond[1]=((((-1.0)*x499))+new_r00);
evalcond[2]=(new_r02+(((-1.0)*x492*x494)));
evalcond[3]=((((-1.0)*x493*x494))+new_r12);
evalcond[4]=(new_r01+(((-1.0)*x492*x495)));
evalcond[5]=((((-1.0)*x493*x495))+new_r11);
evalcond[6]=(x498+x496);
evalcond[7]=((((-1.0)*new_r02*x499))+((new_r12*x492)));
evalcond[8]=((((-1.0)*new_r01*x499))+((new_r11*x492)));
evalcond[9]=((1.0)+(((-1.0)*new_r00*x499))+((new_r10*x492)));
evalcond[10]=(((cj1*x498))+((cj1*x496)));
evalcond[11]=((((-1.0)*x494))+x501+x502);
evalcond[12]=((((-1.0)*x495))+x497+x500);
evalcond[13]=((((-1.0)*x494*x498))+(((-1.0)*x494*x496)));
evalcond[14]=(((cj1*x501))+((cj1*x502))+(((-1.0)*new_r22*x494)));
evalcond[15]=((-1.0)+((cj1*x500))+(sj1*sj1)+((cj1*x497)));
evalcond[16]=((((-1.0)*x494*x497))+(((-1.0)*new_r21*x495))+(((-1.0)*x494*x500)));
evalcond[17]=((1.0)+(((-1.0)*x494*x501))+(((-1.0)*x494*x502))+(((-1.0)*new_r22*x495)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j1))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x503=((1.0)*sj2);
if( IKabs(((((-1.0)*new_r00*x503))+(((-1.0)*cj2*new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*x503))+((cj2*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r00*x503))+(((-1.0)*cj2*new_r01))))+IKsqr(((((-1.0)*new_r01*x503))+((cj2*new_r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0array[0]=IKatan2(((((-1.0)*new_r00*x503))+(((-1.0)*cj2*new_r01))), ((((-1.0)*new_r01*x503))+((cj2*new_r00))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[8];
IkReal x504=IKcos(j0);
IkReal x505=IKsin(j0);
IkReal x506=((1.0)*cj2);
IkReal x507=((1.0)*sj2);
IkReal x508=(sj2*x505);
IkReal x509=((1.0)*x505);
IkReal x510=(x504*x506);
evalcond[0]=(sj2+((new_r11*x505))+((new_r01*x504)));
evalcond[1]=(((sj2*x504))+((cj2*x505))+new_r01);
evalcond[2]=(x508+new_r00+(((-1.0)*x510)));
evalcond[3]=(x508+new_r11+(((-1.0)*x510)));
evalcond[4]=((((-1.0)*x506))+((new_r10*x505))+((new_r00*x504)));
evalcond[5]=((((-1.0)*x505*x506))+(((-1.0)*x504*x507))+new_r10);
evalcond[6]=((((-1.0)*new_r00*x509))+(((-1.0)*x507))+((new_r10*x504)));
evalcond[7]=((((-1.0)*new_r01*x509))+(((-1.0)*x506))+((new_r11*x504)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j1)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x511=((1.0)*new_r00);
if( IKabs(((((-1.0)*sj2*x511))+(((-1.0)*cj2*new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((new_r01*sj2))+(((-1.0)*cj2*x511)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*sj2*x511))+(((-1.0)*cj2*new_r01))))+IKsqr((((new_r01*sj2))+(((-1.0)*cj2*x511))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0array[0]=IKatan2(((((-1.0)*sj2*x511))+(((-1.0)*cj2*new_r01))), (((new_r01*sj2))+(((-1.0)*cj2*x511))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[8];
IkReal x512=IKcos(j0);
IkReal x513=IKsin(j0);
IkReal x514=((1.0)*sj2);
IkReal x515=(cj2*x513);
IkReal x516=(sj2*x513);
IkReal x517=((1.0)*x512);
IkReal x518=((1.0)*x513);
IkReal x519=(x512*x514);
evalcond[0]=(((new_r00*x512))+((new_r10*x513))+cj2);
evalcond[1]=(x516+((cj2*x512))+new_r00);
evalcond[2]=(x515+new_r01+(((-1.0)*x519)));
evalcond[3]=(x515+new_r10+(((-1.0)*x519)));
evalcond[4]=(((new_r01*x512))+((new_r11*x513))+(((-1.0)*x514)));
evalcond[5]=((((-1.0)*cj2*x517))+(((-1.0)*x513*x514))+new_r11);
evalcond[6]=(((new_r10*x512))+(((-1.0)*new_r00*x518))+(((-1.0)*x514)));
evalcond[7]=(((new_r11*x512))+(((-1.0)*new_r01*x518))+(((-1.0)*cj2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r12))+(IKabs(new_r02)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j0eval[0]=((IKabs(new_r11))+(IKabs(new_r01)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal j0eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j0eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal j0eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j0eval[0]=((IKabs((new_r11*new_r22)))+(IKabs((new_r01*new_r22))));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j0]

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x521 = IKatan2WithCheck(IkReal((new_r01*new_r22)),IkReal((new_r11*new_r22)),IKFAST_ATAN2_MAGTHRESH);
if(!x521.valid){
continue;
}
IkReal x520=x521.value;
j0array[0]=((-1.0)*x520);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x520)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x522=IKcos(j0);
IkReal x523=IKsin(j0);
IkReal x524=(new_r10*x523);
IkReal x525=((1.0)*x523);
IkReal x526=(new_r00*x522);
evalcond[0]=(((new_r01*x522))+((new_r11*x523)));
evalcond[1]=(x526+x524);
evalcond[2]=((((-1.0)*new_r00*x525))+((new_r10*x522)));
evalcond[3]=(((new_r11*x522))+(((-1.0)*new_r01*x525)));
evalcond[4]=(((new_r22*x524))+((new_r22*x526)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x528 = IKatan2WithCheck(IkReal(new_r00),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x528.valid){
continue;
}
IkReal x527=x528.value;
j0array[0]=((-1.0)*x527);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x527)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x529=IKcos(j0);
IkReal x530=IKsin(j0);
IkReal x531=((1.0)*x530);
IkReal x532=(new_r11*x530);
IkReal x533=(new_r22*x529);
evalcond[0]=(((new_r01*x529))+x532);
evalcond[1]=((((-1.0)*new_r00*x531))+((new_r10*x529)));
evalcond[2]=(((new_r11*x529))+(((-1.0)*new_r01*x531)));
evalcond[3]=(((new_r01*x533))+((new_r22*x532)));
evalcond[4]=(((new_r10*new_r22*x530))+((new_r00*x533)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x535 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x535.valid){
continue;
}
IkReal x534=x535.value;
j0array[0]=((-1.0)*x534);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x534)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x536=IKcos(j0);
IkReal x537=IKsin(j0);
IkReal x538=(new_r10*x537);
IkReal x539=((1.0)*x537);
IkReal x540=(new_r00*x536);
evalcond[0]=(x540+x538);
evalcond[1]=((((-1.0)*new_r00*x539))+((new_r10*x536)));
evalcond[2]=(((new_r11*x536))+(((-1.0)*new_r01*x539)));
evalcond[3]=(((new_r11*new_r22*x537))+((new_r01*new_r22*x536)));
evalcond[4]=(((new_r22*x540))+((new_r22*x538)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
CheckValue<IkReal> x542=IKPowWithIntegerCheck(sj1,-1);
if(!x542.valid){
continue;
}
IkReal x541=x542.value;
CheckValue<IkReal> x543=IKPowWithIntegerCheck(cj2,-1);
if(!x543.valid){
continue;
}
if( IKabs((x541*(x543.value)*(((((-1.0)*new_r01*sj1))+(((-1.0)*cj1*new_r02*sj2)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r02*x541)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x541*(x543.value)*(((((-1.0)*new_r01*sj1))+(((-1.0)*cj1*new_r02*sj2))))))+IKsqr((new_r02*x541))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0array[0]=IKatan2((x541*(x543.value)*(((((-1.0)*new_r01*sj1))+(((-1.0)*cj1*new_r02*sj2))))), (new_r02*x541));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[18];
IkReal x544=IKcos(j0);
IkReal x545=IKsin(j0);
IkReal x546=((1.0)*cj2);
IkReal x547=((1.0)*sj1);
IkReal x548=((1.0)*cj1);
IkReal x549=((1.0)*sj2);
IkReal x550=(new_r10*x545);
IkReal x551=(new_r01*x544);
IkReal x552=(new_r00*x544);
IkReal x553=((1.0)*x545);
IkReal x554=(new_r11*x545);
IkReal x555=(new_r12*x545);
IkReal x556=(sj2*x545);
IkReal x557=(cj1*x544);
IkReal x558=(cj2*x545);
IkReal x559=(new_r02*x544);
evalcond[0]=((((-1.0)*x544*x547))+new_r02);
evalcond[1]=((((-1.0)*x545*x547))+new_r12);
evalcond[2]=(((new_r12*x544))+(((-1.0)*new_r02*x553)));
evalcond[3]=(((sj2*x557))+x558+new_r01);
evalcond[4]=((((-1.0)*x547))+x559+x555);
evalcond[5]=(((cj1*sj2))+x551+x554);
evalcond[6]=(x556+new_r00+(((-1.0)*x546*x557)));
evalcond[7]=((((-1.0)*x544*x546))+((cj1*x556))+new_r11);
evalcond[8]=(((new_r10*x544))+(((-1.0)*x549))+(((-1.0)*new_r00*x553)));
evalcond[9]=((((-1.0)*new_r01*x553))+((new_r11*x544))+(((-1.0)*x546)));
evalcond[10]=((((-1.0)*cj1*x546))+x552+x550);
evalcond[11]=((((-1.0)*x544*x549))+(((-1.0)*cj1*x545*x546))+new_r10);
evalcond[12]=((((-1.0)*new_r22*x547))+((new_r02*x557))+((cj1*x555)));
evalcond[13]=(sj2+((cj1*x551))+((cj1*x554))+(((-1.0)*new_r21*x547)));
evalcond[14]=((((-1.0)*new_r20*x548))+(((-1.0)*x547*x550))+(((-1.0)*x547*x552)));
evalcond[15]=((((-1.0)*x547*x554))+(((-1.0)*x547*x551))+(((-1.0)*new_r21*x548)));
evalcond[16]=((1.0)+(((-1.0)*new_r22*x548))+(((-1.0)*x547*x555))+(((-1.0)*x547*x559)));
evalcond[17]=((((-1.0)*new_r20*x547))+(((-1.0)*x546))+((cj1*x550))+((cj1*x552)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
CheckValue<IkReal> x560=IKPowWithIntegerCheck(IKsign(sj1),-1);
if(!x560.valid){
continue;
}
CheckValue<IkReal> x561 = IKatan2WithCheck(IkReal(new_r12),IkReal(new_r02),IKFAST_ATAN2_MAGTHRESH);
if(!x561.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x560.value)))+(x561.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[18];
IkReal x562=IKcos(j0);
IkReal x563=IKsin(j0);
IkReal x564=((1.0)*cj2);
IkReal x565=((1.0)*sj1);
IkReal x566=((1.0)*cj1);
IkReal x567=((1.0)*sj2);
IkReal x568=(new_r10*x563);
IkReal x569=(new_r01*x562);
IkReal x570=(new_r00*x562);
IkReal x571=((1.0)*x563);
IkReal x572=(new_r11*x563);
IkReal x573=(new_r12*x563);
IkReal x574=(sj2*x563);
IkReal x575=(cj1*x562);
IkReal x576=(cj2*x563);
IkReal x577=(new_r02*x562);
evalcond[0]=((((-1.0)*x562*x565))+new_r02);
evalcond[1]=((((-1.0)*x563*x565))+new_r12);
evalcond[2]=((((-1.0)*new_r02*x571))+((new_r12*x562)));
evalcond[3]=(((sj2*x575))+x576+new_r01);
evalcond[4]=(x577+x573+(((-1.0)*x565)));
evalcond[5]=(((cj1*sj2))+x572+x569);
evalcond[6]=((((-1.0)*x564*x575))+x574+new_r00);
evalcond[7]=((((-1.0)*x562*x564))+new_r11+((cj1*x574)));
evalcond[8]=((((-1.0)*new_r00*x571))+((new_r10*x562))+(((-1.0)*x567)));
evalcond[9]=(((new_r11*x562))+(((-1.0)*new_r01*x571))+(((-1.0)*x564)));
evalcond[10]=((((-1.0)*cj1*x564))+x570+x568);
evalcond[11]=((((-1.0)*x562*x567))+(((-1.0)*cj1*x563*x564))+new_r10);
evalcond[12]=((((-1.0)*new_r22*x565))+((cj1*x573))+((new_r02*x575)));
evalcond[13]=(((cj1*x569))+sj2+((cj1*x572))+(((-1.0)*new_r21*x565)));
evalcond[14]=((((-1.0)*new_r20*x566))+(((-1.0)*x565*x570))+(((-1.0)*x565*x568)));
evalcond[15]=((((-1.0)*x565*x572))+(((-1.0)*new_r21*x566))+(((-1.0)*x565*x569)));
evalcond[16]=((1.0)+(((-1.0)*x565*x573))+(((-1.0)*x565*x577))+(((-1.0)*new_r22*x566)));
evalcond[17]=(((cj1*x568))+(((-1.0)*new_r20*x565))+((cj1*x570))+(((-1.0)*x564)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
CheckValue<IkReal> x578=IKPowWithIntegerCheck(IKsign(sj1),-1);
if(!x578.valid){
continue;
}
CheckValue<IkReal> x579 = IKatan2WithCheck(IkReal(new_r12),IkReal(new_r02),IKFAST_ATAN2_MAGTHRESH);
if(!x579.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x578.value)))+(x579.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[8];
IkReal x580=IKcos(j0);
IkReal x581=IKsin(j0);
IkReal x582=((1.0)*cj1);
IkReal x583=((1.0)*sj1);
IkReal x584=(new_r12*x581);
IkReal x585=(new_r02*x580);
evalcond[0]=((((-1.0)*x580*x583))+new_r02);
evalcond[1]=(new_r12+(((-1.0)*x581*x583)));
evalcond[2]=((((-1.0)*new_r02*x581))+((new_r12*x580)));
evalcond[3]=(x584+x585+(((-1.0)*x583)));
evalcond[4]=((((-1.0)*new_r22*x583))+((cj1*x585))+((cj1*x584)));
evalcond[5]=((((-1.0)*new_r00*x580*x583))+(((-1.0)*new_r20*x582))+(((-1.0)*new_r10*x581*x583)));
evalcond[6]=((((-1.0)*new_r01*x580*x583))+(((-1.0)*new_r11*x581*x583))+(((-1.0)*new_r21*x582)));
evalcond[7]=((1.0)+(((-1.0)*new_r22*x582))+(((-1.0)*x583*x585))+(((-1.0)*x583*x584)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j2eval[3];
j2eval[0]=sj1;
j2eval[1]=IKsign(sj1);
j2eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
j2eval[0]=sj0;
j2eval[1]=sj1;
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal j2eval[3];
j2eval[0]=cj0;
j2eval[1]=cj1;
j2eval[2]=sj1;
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j0)))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[3];
sj0=1.0;
cj0=0;
j0=1.5707963267949;
j2eval[0]=sj1;
j2eval[1]=IKsign(sj1);
j2eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[3];
sj0=1.0;
cj0=0;
j0=1.5707963267949;
j2eval[0]=cj1;
j2eval[1]=IKsign(cj1);
j2eval[2]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[1];
sj0=1.0;
cj0=0;
j0=1.5707963267949;
j2eval[0]=sj1;
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j1))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r12;
evalcond[3]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r11))+IKsqr(new_r10)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r11), new_r10);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x586=IKsin(j2);
IkReal x587=((1.0)*(IKcos(j2)));
evalcond[0]=(x586+new_r11);
evalcond[1]=(new_r10+(((-1.0)*x587)));
evalcond[2]=((((-1.0)*x586))+(((-1.0)*new_r00)));
evalcond[3]=((((-1.0)*new_r01))+(((-1.0)*x587)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j1)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r12;
evalcond[3]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r11)+IKsqr(((-1.0)*new_r10))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(new_r11, ((-1.0)*new_r10));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x588=IKcos(j2);
IkReal x589=((1.0)*(IKsin(j2)));
evalcond[0]=(x588+new_r10);
evalcond[1]=(new_r11+(((-1.0)*x589)));
evalcond[2]=((((-1.0)*new_r00))+(((-1.0)*x589)));
evalcond[3]=((((-1.0)*x588))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j1)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r11;
evalcond[3]=new_r10;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x590=IKcos(j2);
IkReal x591=((1.0)*(IKsin(j2)));
evalcond[0]=(x590+new_r20);
evalcond[1]=((((-1.0)*x591))+new_r21);
evalcond[2]=((((-1.0)*x591))+(((-1.0)*new_r00)));
evalcond[3]=((((-1.0)*x590))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j1)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r11;
evalcond[3]=new_r10;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x592=IKsin(j2);
IkReal x593=((1.0)*(IKcos(j2)));
evalcond[0]=(x592+new_r21);
evalcond[1]=((((-1.0)*x593))+new_r20);
evalcond[2]=((((-1.0)*x592))+(((-1.0)*new_r00)));
evalcond[3]=((((-1.0)*x593))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x594=IKsin(j2);
IkReal x595=IKcos(j2);
IkReal x596=((-1.0)*x595);
evalcond[0]=x594;
evalcond[1]=(new_r22*x594);
evalcond[2]=x596;
evalcond[3]=(new_r22*x596);
evalcond[4]=((((-1.0)*x594))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x595))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j2]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x597=IKPowWithIntegerCheck(sj1,-1);
if(!x597.valid){
continue;
}
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*(x597.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r20*(x597.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r20*(x597.value)));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x598=IKsin(j2);
IkReal x599=IKcos(j2);
IkReal x600=((1.0)*sj1);
IkReal x601=((1.0)*x599);
evalcond[0]=(((sj1*x599))+new_r20);
evalcond[1]=(((cj1*x598))+new_r11);
evalcond[2]=((((-1.0)*x598*x600))+new_r21);
evalcond[3]=((((-1.0)*cj1*x601))+new_r10);
evalcond[4]=((((-1.0)*x598))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x601))+(((-1.0)*new_r01)));
evalcond[6]=(((cj1*new_r11))+x598+(((-1.0)*new_r21*x600)));
evalcond[7]=((((-1.0)*new_r20*x600))+((cj1*new_r10))+(((-1.0)*x601)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x602=IKPowWithIntegerCheck(IKsign(cj1),-1);
if(!x602.valid){
continue;
}
CheckValue<IkReal> x603 = IKatan2WithCheck(IkReal(((-1.0)*new_r11)),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x603.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x602.value)))+(x603.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x604=IKsin(j2);
IkReal x605=IKcos(j2);
IkReal x606=((1.0)*sj1);
IkReal x607=((1.0)*x605);
evalcond[0]=(((sj1*x605))+new_r20);
evalcond[1]=(((cj1*x604))+new_r11);
evalcond[2]=((((-1.0)*x604*x606))+new_r21);
evalcond[3]=((((-1.0)*cj1*x607))+new_r10);
evalcond[4]=((((-1.0)*x604))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x607))+(((-1.0)*new_r01)));
evalcond[6]=(((cj1*new_r11))+x604+(((-1.0)*new_r21*x606)));
evalcond[7]=((((-1.0)*new_r20*x606))+((cj1*new_r10))+(((-1.0)*x607)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x608=IKPowWithIntegerCheck(IKsign(sj1),-1);
if(!x608.valid){
continue;
}
CheckValue<IkReal> x609 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x609.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x608.value)))+(x609.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x610=IKsin(j2);
IkReal x611=IKcos(j2);
IkReal x612=((1.0)*sj1);
IkReal x613=((1.0)*x611);
evalcond[0]=(((sj1*x611))+new_r20);
evalcond[1]=(((cj1*x610))+new_r11);
evalcond[2]=((((-1.0)*x610*x612))+new_r21);
evalcond[3]=((((-1.0)*cj1*x613))+new_r10);
evalcond[4]=((((-1.0)*x610))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x613))+(((-1.0)*new_r01)));
evalcond[6]=((((-1.0)*new_r21*x612))+((cj1*new_r11))+x610);
evalcond[7]=(((cj1*new_r10))+(((-1.0)*x613))+(((-1.0)*new_r20*x612)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j0)))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(new_r00, new_r01);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x614=IKcos(j2);
IkReal x615=IKsin(j2);
IkReal x616=((1.0)*sj1);
IkReal x617=((1.0)*new_r11);
IkReal x618=((1.0)*new_r10);
IkReal x619=((1.0)*x614);
evalcond[0]=(((sj1*x614))+new_r20);
evalcond[1]=((((-1.0)*x615))+new_r00);
evalcond[2]=((((-1.0)*x619))+new_r01);
evalcond[3]=(new_r21+(((-1.0)*x615*x616)));
evalcond[4]=((((-1.0)*x617))+((cj1*x615)));
evalcond[5]=((((-1.0)*cj1*x619))+(((-1.0)*x618)));
evalcond[6]=((((-1.0)*new_r21*x616))+(((-1.0)*cj1*x617))+x615);
evalcond[7]=((((-1.0)*cj1*x618))+(((-1.0)*x619))+(((-1.0)*new_r20*x616)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j1)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x620=IKcos(j2);
IkReal x621=IKsin(j2);
IkReal x622=((1.0)*sj0);
IkReal x623=((1.0)*x621);
IkReal x624=((1.0)*x620);
evalcond[0]=(x620+new_r20);
evalcond[1]=((((-1.0)*x623))+new_r21);
evalcond[2]=(((sj0*x620))+new_r01);
evalcond[3]=(((sj0*x621))+new_r00);
evalcond[4]=((((-1.0)*cj0*x624))+new_r11);
evalcond[5]=((((-1.0)*new_r02*x623))+new_r10);
evalcond[6]=((((-1.0)*new_r00*x622))+(((-1.0)*x623))+((cj0*new_r10)));
evalcond[7]=((((-1.0)*new_r01*x622))+(((-1.0)*x624))+((cj0*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j1)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x625=IKcos(j2);
IkReal x626=IKsin(j2);
IkReal x627=((1.0)*sj0);
IkReal x628=((1.0)*x625);
evalcond[0]=(x626+new_r21);
evalcond[1]=((((-1.0)*x628))+new_r20);
evalcond[2]=(((sj0*x625))+new_r01);
evalcond[3]=(((sj0*x626))+new_r00);
evalcond[4]=(((new_r02*x626))+new_r10);
evalcond[5]=((((-1.0)*cj0*x628))+new_r11);
evalcond[6]=((((-1.0)*new_r00*x627))+(((-1.0)*x626))+((cj0*new_r10)));
evalcond[7]=((((-1.0)*new_r01*x627))+(((-1.0)*x628))+((cj0*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j1))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x629=((1.0)*new_r01);
if( IKabs(((((-1.0)*cj0*x629))+(((-1.0)*new_r00*sj0)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj0*new_r00))+(((-1.0)*sj0*x629)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj0*x629))+(((-1.0)*new_r00*sj0))))+IKsqr((((cj0*new_r00))+(((-1.0)*sj0*x629))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*cj0*x629))+(((-1.0)*new_r00*sj0))), (((cj0*new_r00))+(((-1.0)*sj0*x629))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x630=IKsin(j2);
IkReal x631=IKcos(j2);
IkReal x632=((1.0)*sj0);
IkReal x633=((1.0)*x631);
IkReal x634=(sj0*x630);
IkReal x635=(cj0*x630);
IkReal x636=(cj0*x633);
evalcond[0]=(((new_r11*sj0))+x630+((cj0*new_r01)));
evalcond[1]=(((sj0*x631))+x635+new_r01);
evalcond[2]=(((new_r10*sj0))+(((-1.0)*x633))+((cj0*new_r00)));
evalcond[3]=((((-1.0)*new_r00*x632))+(((-1.0)*x630))+((cj0*new_r10)));
evalcond[4]=((((-1.0)*new_r01*x632))+(((-1.0)*x633))+((cj0*new_r11)));
evalcond[5]=((((-1.0)*x636))+x634+new_r00);
evalcond[6]=((((-1.0)*x636))+x634+new_r11);
evalcond[7]=((((-1.0)*x631*x632))+(((-1.0)*x635))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j1)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x637=((1.0)*sj0);
if( IKabs(((((-1.0)*new_r00*x637))+((cj0*new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*x637))+(((-1.0)*cj0*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r00*x637))+((cj0*new_r01))))+IKsqr(((((-1.0)*new_r01*x637))+(((-1.0)*cj0*new_r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*new_r00*x637))+((cj0*new_r01))), ((((-1.0)*new_r01*x637))+(((-1.0)*cj0*new_r00))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x638=IKsin(j2);
IkReal x639=IKcos(j2);
IkReal x640=((1.0)*sj0);
IkReal x641=((1.0)*x638);
IkReal x642=(sj0*x639);
IkReal x643=((1.0)*x639);
IkReal x644=(cj0*x641);
evalcond[0]=(((new_r10*sj0))+x639+((cj0*new_r00)));
evalcond[1]=(((new_r11*sj0))+(((-1.0)*x641))+((cj0*new_r01)));
evalcond[2]=(((cj0*x639))+((sj0*x638))+new_r00);
evalcond[3]=((((-1.0)*x641))+(((-1.0)*new_r00*x640))+((cj0*new_r10)));
evalcond[4]=((((-1.0)*x643))+(((-1.0)*new_r01*x640))+((cj0*new_r11)));
evalcond[5]=((((-1.0)*x644))+x642+new_r01);
evalcond[6]=((((-1.0)*x644))+x642+new_r10);
evalcond[7]=((((-1.0)*cj0*x643))+new_r11+(((-1.0)*x638*x640)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j0))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(new_r10, new_r11);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x645=IKcos(j2);
IkReal x646=IKsin(j2);
IkReal x647=((1.0)*sj1);
IkReal x648=((1.0)*x645);
evalcond[0]=(((sj1*x645))+new_r20);
evalcond[1]=((((-1.0)*x646))+new_r10);
evalcond[2]=((((-1.0)*x648))+new_r11);
evalcond[3]=(((cj1*x646))+new_r01);
evalcond[4]=((((-1.0)*x646*x647))+new_r21);
evalcond[5]=((((-1.0)*cj1*x648))+new_r00);
evalcond[6]=(((cj1*new_r01))+(((-1.0)*new_r21*x647))+x646);
evalcond[7]=(((cj1*new_r00))+(((-1.0)*x648))+(((-1.0)*new_r20*x647)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j0)))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[3];
sj0=0;
cj0=-1.0;
j0=3.14159265358979;
j2eval[0]=sj1;
j2eval[1]=IKsign(sj1);
j2eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[1];
sj0=0;
cj0=-1.0;
j0=3.14159265358979;
j2eval[0]=sj1;
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
sj0=0;
cj0=-1.0;
j0=3.14159265358979;
j2eval[0]=cj1;
j2eval[1]=sj1;
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j1)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r01;
evalcond[3]=new_r00;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x649=IKcos(j2);
IkReal x650=((1.0)*(IKsin(j2)));
evalcond[0]=(x649+new_r20);
evalcond[1]=((((-1.0)*x650))+new_r21);
evalcond[2]=((((-1.0)*x650))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x649))+(((-1.0)*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j1)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r01;
evalcond[3]=new_r00;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x651=IKsin(j2);
IkReal x652=((1.0)*(IKcos(j2)));
evalcond[0]=(x651+new_r21);
evalcond[1]=((((-1.0)*x652))+new_r20);
evalcond[2]=((((-1.0)*x651))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x652))+(((-1.0)*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j1))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(new_r01, ((-1.0)*new_r11));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x653=IKsin(j2);
IkReal x654=((1.0)*(IKcos(j2)));
evalcond[0]=(x653+(((-1.0)*new_r01)));
evalcond[1]=((((-1.0)*x653))+(((-1.0)*new_r10)));
evalcond[2]=((((-1.0)*x654))+(((-1.0)*new_r11)));
evalcond[3]=((((-1.0)*x654))+(((-1.0)*new_r00)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j1)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r10), new_r00);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x655=IKcos(j2);
IkReal x656=((1.0)*(IKsin(j2)));
evalcond[0]=(x655+(((-1.0)*new_r00)));
evalcond[1]=((((-1.0)*x656))+(((-1.0)*new_r10)));
evalcond[2]=((((-1.0)*x655))+(((-1.0)*new_r11)));
evalcond[3]=((((-1.0)*x656))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r11));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x657=IKsin(j2);
IkReal x658=IKcos(j2);
IkReal x659=((-1.0)*x658);
evalcond[0]=x657;
evalcond[1]=(new_r22*x657);
evalcond[2]=x659;
evalcond[3]=(new_r22*x659);
evalcond[4]=((((-1.0)*x657))+(((-1.0)*new_r10)));
evalcond[5]=((((-1.0)*x658))+(((-1.0)*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j2]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x660=IKPowWithIntegerCheck(cj1,-1);
if(!x660.valid){
continue;
}
CheckValue<IkReal> x661=IKPowWithIntegerCheck(sj1,-1);
if(!x661.valid){
continue;
}
if( IKabs((new_r01*(x660.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*(x661.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r01*(x660.value)))+IKsqr(((-1.0)*new_r20*(x661.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((new_r01*(x660.value)), ((-1.0)*new_r20*(x661.value)));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x662=IKsin(j2);
IkReal x663=IKcos(j2);
IkReal x664=((1.0)*new_r00);
IkReal x665=((1.0)*sj1);
IkReal x666=((1.0)*new_r01);
IkReal x667=((1.0)*x663);
evalcond[0]=(((sj1*x663))+new_r20);
evalcond[1]=((((-1.0)*x662*x665))+new_r21);
evalcond[2]=((((-1.0)*x662))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x667))+(((-1.0)*new_r11)));
evalcond[4]=((((-1.0)*x666))+((cj1*x662)));
evalcond[5]=((((-1.0)*cj1*x667))+(((-1.0)*x664)));
evalcond[6]=((((-1.0)*new_r21*x665))+(((-1.0)*cj1*x666))+x662);
evalcond[7]=((((-1.0)*cj1*x664))+(((-1.0)*x667))+(((-1.0)*new_r20*x665)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x668=IKPowWithIntegerCheck(sj1,-1);
if(!x668.valid){
continue;
}
if( IKabs((new_r21*(x668.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r21*(x668.value)))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((new_r21*(x668.value)), ((-1.0)*new_r11));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x669=IKsin(j2);
IkReal x670=IKcos(j2);
IkReal x671=((1.0)*new_r00);
IkReal x672=((1.0)*sj1);
IkReal x673=((1.0)*new_r01);
IkReal x674=((1.0)*x670);
evalcond[0]=(((sj1*x670))+new_r20);
evalcond[1]=((((-1.0)*x669*x672))+new_r21);
evalcond[2]=((((-1.0)*x669))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*new_r11))+(((-1.0)*x674)));
evalcond[4]=(((cj1*x669))+(((-1.0)*x673)));
evalcond[5]=((((-1.0)*cj1*x674))+(((-1.0)*x671)));
evalcond[6]=((((-1.0)*new_r21*x672))+(((-1.0)*cj1*x673))+x669);
evalcond[7]=((((-1.0)*new_r20*x672))+(((-1.0)*cj1*x671))+(((-1.0)*x674)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x675=IKPowWithIntegerCheck(IKsign(sj1),-1);
if(!x675.valid){
continue;
}
CheckValue<IkReal> x676 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x676.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x675.value)))+(x676.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x677=IKsin(j2);
IkReal x678=IKcos(j2);
IkReal x679=((1.0)*new_r00);
IkReal x680=((1.0)*sj1);
IkReal x681=((1.0)*new_r01);
IkReal x682=((1.0)*x678);
evalcond[0]=(((sj1*x678))+new_r20);
evalcond[1]=((((-1.0)*x677*x680))+new_r21);
evalcond[2]=((((-1.0)*x677))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x682))+(((-1.0)*new_r11)));
evalcond[4]=((((-1.0)*x681))+((cj1*x677)));
evalcond[5]=((((-1.0)*cj1*x682))+(((-1.0)*x679)));
evalcond[6]=((((-1.0)*cj1*x681))+(((-1.0)*new_r21*x680))+x677);
evalcond[7]=((((-1.0)*x682))+(((-1.0)*new_r20*x680))+(((-1.0)*cj1*x679)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[1];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
j2eval[0]=IKabs(new_r22);
if( IKabs(j2eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j2]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
op[0]=new_r22;
op[1]=0;
op[2]=((-1.0)*new_r22);
polyroots2(op,zeror,numroots);
IkReal j2array[2], cj2array[2], sj2array[2], tempj2array[1];
int numsolutions = 0;
for(int ij2 = 0; ij2 < numroots; ++ij2)
{
IkReal htj2 = zeror[ij2];
tempj2array[0]=((2.0)*(atan(htj2)));
for(int kj2 = 0; kj2 < 1; ++kj2)
{
j2array[numsolutions] = tempj2array[kj2];
if( j2array[numsolutions] > IKPI )
{
    j2array[numsolutions]-=IK2PI;
}
else if( j2array[numsolutions] < -IKPI )
{
    j2array[numsolutions]+=IK2PI;
}
sj2array[numsolutions] = IKsin(j2array[numsolutions]);
cj2array[numsolutions] = IKcos(j2array[numsolutions]);
numsolutions++;
}
}
bool j2valid[2]={true,true};
_nj2 = 2;
for(int ij2 = 0; ij2 < numsolutions; ++ij2)
    {
if( !j2valid[ij2] )
{
    continue;
}
    j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
htj2 = IKtan(j2/2);

_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < numsolutions; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j2]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x684=IKPowWithIntegerCheck(sj1,-1);
if(!x684.valid){
continue;
}
IkReal x683=x684.value;
CheckValue<IkReal> x685=IKPowWithIntegerCheck(cj0,-1);
if(!x685.valid){
continue;
}
CheckValue<IkReal> x686=IKPowWithIntegerCheck(cj1,-1);
if(!x686.valid){
continue;
}
if( IKabs((x683*(x685.value)*(x686.value)*((((new_r20*sj0))+(((-1.0)*new_r01*sj1)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x683)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x683*(x685.value)*(x686.value)*((((new_r20*sj0))+(((-1.0)*new_r01*sj1))))))+IKsqr(((-1.0)*new_r20*x683))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((x683*(x685.value)*(x686.value)*((((new_r20*sj0))+(((-1.0)*new_r01*sj1))))), ((-1.0)*new_r20*x683));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[12];
IkReal x687=IKsin(j2);
IkReal x688=IKcos(j2);
IkReal x689=((1.0)*sj1);
IkReal x690=((1.0)*sj0);
IkReal x691=(cj0*new_r00);
IkReal x692=(cj0*cj1);
IkReal x693=(new_r11*sj0);
IkReal x694=(new_r10*sj0);
IkReal x695=((1.0)*x688);
IkReal x696=(cj1*x687);
IkReal x697=((1.0)*x687);
evalcond[0]=(((sj1*x688))+new_r20);
evalcond[1]=((((-1.0)*x687*x689))+new_r21);
evalcond[2]=(x696+x693+((cj0*new_r01)));
evalcond[3]=((((-1.0)*new_r00*x690))+(((-1.0)*x697))+((cj0*new_r10)));
evalcond[4]=((((-1.0)*new_r01*x690))+(((-1.0)*x695))+((cj0*new_r11)));
evalcond[5]=(((x687*x692))+((sj0*x688))+new_r01);
evalcond[6]=((((-1.0)*cj1*x695))+x694+x691);
evalcond[7]=((((-1.0)*x692*x695))+((sj0*x687))+new_r00);
evalcond[8]=(((sj0*x696))+(((-1.0)*cj0*x695))+new_r11);
evalcond[9]=((((-1.0)*cj1*x688*x690))+(((-1.0)*cj0*x697))+new_r10);
evalcond[10]=(((cj1*x693))+(((-1.0)*new_r21*x689))+x687+((new_r01*x692)));
evalcond[11]=(((cj1*x691))+((cj1*x694))+(((-1.0)*new_r20*x689))+(((-1.0)*x695)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x699=IKPowWithIntegerCheck(sj1,-1);
if(!x699.valid){
continue;
}
IkReal x698=x699.value;
CheckValue<IkReal> x700=IKPowWithIntegerCheck(sj0,-1);
if(!x700.valid){
continue;
}
if( IKabs((x698*(x700.value)*(((((-1.0)*cj0*cj1*new_r20))+(((-1.0)*new_r00*sj1)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x698)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x698*(x700.value)*(((((-1.0)*cj0*cj1*new_r20))+(((-1.0)*new_r00*sj1))))))+IKsqr(((-1.0)*new_r20*x698))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((x698*(x700.value)*(((((-1.0)*cj0*cj1*new_r20))+(((-1.0)*new_r00*sj1))))), ((-1.0)*new_r20*x698));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[12];
IkReal x701=IKsin(j2);
IkReal x702=IKcos(j2);
IkReal x703=((1.0)*sj1);
IkReal x704=((1.0)*sj0);
IkReal x705=(cj0*new_r00);
IkReal x706=(cj0*cj1);
IkReal x707=(new_r11*sj0);
IkReal x708=(new_r10*sj0);
IkReal x709=((1.0)*x702);
IkReal x710=(cj1*x701);
IkReal x711=((1.0)*x701);
evalcond[0]=(((sj1*x702))+new_r20);
evalcond[1]=(new_r21+(((-1.0)*x701*x703)));
evalcond[2]=(x710+x707+((cj0*new_r01)));
evalcond[3]=((((-1.0)*x711))+((cj0*new_r10))+(((-1.0)*new_r00*x704)));
evalcond[4]=((((-1.0)*x709))+(((-1.0)*new_r01*x704))+((cj0*new_r11)));
evalcond[5]=(((x701*x706))+((sj0*x702))+new_r01);
evalcond[6]=((((-1.0)*cj1*x709))+x708+x705);
evalcond[7]=((((-1.0)*x706*x709))+((sj0*x701))+new_r00);
evalcond[8]=((((-1.0)*cj0*x709))+((sj0*x710))+new_r11);
evalcond[9]=(new_r10+(((-1.0)*cj1*x702*x704))+(((-1.0)*cj0*x711)));
evalcond[10]=((((-1.0)*new_r21*x703))+((new_r01*x706))+x701+((cj1*x707)));
evalcond[11]=((((-1.0)*new_r20*x703))+(((-1.0)*x709))+((cj1*x708))+((cj1*x705)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x712=IKPowWithIntegerCheck(IKsign(sj1),-1);
if(!x712.valid){
continue;
}
CheckValue<IkReal> x713 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x713.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x712.value)))+(x713.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[12];
IkReal x714=IKsin(j2);
IkReal x715=IKcos(j2);
IkReal x716=((1.0)*sj1);
IkReal x717=((1.0)*sj0);
IkReal x718=(cj0*new_r00);
IkReal x719=(cj0*cj1);
IkReal x720=(new_r11*sj0);
IkReal x721=(new_r10*sj0);
IkReal x722=((1.0)*x715);
IkReal x723=(cj1*x714);
IkReal x724=((1.0)*x714);
evalcond[0]=(((sj1*x715))+new_r20);
evalcond[1]=((((-1.0)*x714*x716))+new_r21);
evalcond[2]=(x720+x723+((cj0*new_r01)));
evalcond[3]=((((-1.0)*x724))+((cj0*new_r10))+(((-1.0)*new_r00*x717)));
evalcond[4]=((((-1.0)*x722))+((cj0*new_r11))+(((-1.0)*new_r01*x717)));
evalcond[5]=(((x714*x719))+((sj0*x715))+new_r01);
evalcond[6]=((((-1.0)*cj1*x722))+x718+x721);
evalcond[7]=(((sj0*x714))+new_r00+(((-1.0)*x719*x722)));
evalcond[8]=((((-1.0)*cj0*x722))+((sj0*x723))+new_r11);
evalcond[9]=((((-1.0)*cj0*x724))+new_r10+(((-1.0)*cj1*x715*x717)));
evalcond[10]=(((cj1*x720))+(((-1.0)*new_r21*x716))+((new_r01*x719))+x714);
evalcond[11]=(((cj1*x721))+(((-1.0)*new_r20*x716))+(((-1.0)*x722))+((cj1*x718)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
}
}
}static inline void polyroots3(IkReal rawcoeffs[3+1], IkReal rawroots[3], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots2(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[3];
    const int maxsteps = 110;
    for(int i = 0; i < 3; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[3];
    IkReal err[3];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 3; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 3; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 3; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 3; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[3] = {false};
    for(int i = 0; i < 3; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 3; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {
    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];
    if( det < 0 ) {
        numroots=0;
    }
    else if( det == 0 ) {
        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];
        numroots = 1;
    }
    else {
        det = IKsqrt(det);
        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);
        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);
        numroots = 2;
    }
}
static inline void polyroots5(IkReal rawcoeffs[5+1], IkReal rawroots[5], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots4(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[5];
    const int maxsteps = 110;
    for(int i = 0; i < 5; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[5];
    IkReal err[5];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 5; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 5; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 5; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 5; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[5] = {false};
    for(int i = 0; i < 5; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 5; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots4(IkReal rawcoeffs[4+1], IkReal rawroots[4], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots3(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[4];
    const int maxsteps = 110;
    for(int i = 0; i < 4; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[4];
    IkReal err[4];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 4; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 4; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 4; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 4; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[4] = {false};
    for(int i = 0; i < 4; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 4; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots7(IkReal rawcoeffs[7+1], IkReal rawroots[7], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots6(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[7];
    const int maxsteps = 110;
    for(int i = 0; i < 7; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[7];
    IkReal err[7];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 7; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 7; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 7; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 7; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[7] = {false};
    for(int i = 0; i < 7; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 7; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots6(IkReal rawcoeffs[6+1], IkReal rawroots[6], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots5(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[6];
    const int maxsteps = 110;
    for(int i = 0; i < 6; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[6];
    IkReal err[6];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 6; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 6; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 6; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 6; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[6] = {false};
    for(int i = 0; i < 6; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 6; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots8(IkReal rawcoeffs[8+1], IkReal rawroots[8], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots7(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[8];
    const int maxsteps = 110;
    for(int i = 0; i < 8; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[8];
    IkReal err[8];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 8; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 8; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 8; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 8; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[8] = {false};
    for(int i = 0; i < 8; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 8; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "<robot:GenericRobot - xarm7_with_gripper (b0c22985b5978e1acf2a611482b6a182)>"; }

IKFAST_API const char* GetIkFastVersion() { return "0x10000049"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif
