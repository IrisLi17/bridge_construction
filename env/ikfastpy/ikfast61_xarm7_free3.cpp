/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x10000049 generated on 2021-08-10 16:18:44.129192
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x10000049);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)1e-7)
#endif

// used to check input to atan2 for degenerate cases. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)1e-7)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.00001)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42,x43,x44,x45,x46,x47,x48,x49,x50,x51,x52,x53,x54,x55,x56,x57,x58,x59,x60,x61,x62,x63,x64,x65;
x0=IKcos(j[0]);
x1=IKcos(j[3]);
x2=IKsin(j[1]);
x3=IKsin(j[3]);
x4=IKcos(j[2]);
x5=IKsin(j[0]);
x6=IKcos(j[1]);
x7=IKsin(j[2]);
x8=IKcos(j[4]);
x9=IKsin(j[4]);
x10=IKcos(j[6]);
x11=IKsin(j[6]);
x12=IKcos(j[5]);
x13=IKsin(j[5]);
x14=((0.097)*x2);
x15=((0.0775)*x4);
x16=((0.3425)*x5);
x17=((1.0)*x1);
x18=((1.0)*x5);
x19=((0.3425)*x4);
x20=((1.0)*x2);
x21=((0.0525)*x4);
x22=((0.0775)*x5);
x23=((1.0)*x4);
x24=((0.293)*x2);
x25=((0.076)*x8);
x26=(x7*x9);
x27=(x1*x6);
x28=(x5*x6);
x29=(x1*x2);
x30=(x0*x7);
x31=((-1.0)*x12);
x32=(x3*x6);
x33=(x2*x3);
x34=((-1.0)*x13);
x35=(x0*x6);
x36=((-0.097)*x8);
x37=(x0*x33);
x38=(x17*x2*x4);
x39=(x20*x26);
x40=((((-1.0)*x18*x7))+((x35*x4)));
x41=(((x30*x6))+((x4*x5)));
x42=(x30+((x28*x4)));
x43=((((-1.0)*x0*x23))+((x28*x7)));
x44=((((-1.0)*x38))+x32);
x45=(x41*x8);
x46=(x3*x40);
x47=((((-1.0)*x20*x3*x4))+(((-1.0)*x17*x6)));
x48=(x41*x9);
x49=(x1*x40);
x50=(x3*x42);
x51=(x44*x8);
x52=(x43*x9);
x53=(x13*x47);
x54=(x37+x49);
x55=((((-1.0)*x0*x17*x2))+x46);
x56=((((-1.0)*x17*x2*x5))+x50);
x57=(((x33*x5))+((x1*x42)));
x58=((((-1.0)*x39))+x51);
x59=((((-1.0)*x20*x7*x8))+((x9*(((((-1.0)*x32))+x38)))));
x60=(x57*x8);
x61=(x12*x58);
x62=(x54*x8);
x63=(x48+x62);
x64=(x52+x60);
x65=(((x9*(((((-1.0)*x18*x33))+(((-1.0)*x17*x42))))))+((x43*x8)));
eerot[0]=(((x10*((((x12*x63))+((x13*x55))))))+((x11*((x45+((x9*(((((-1.0)*x37))+(((-1.0)*x49)))))))))));
IkReal x66=((1.0)*x0);
eerot[1]=(((x11*((((x31*x63))+((x34*((x46+(((-1.0)*x29*x66))))))))))+((x10*((((x9*(((((-1.0)*x20*x3*x66))+(((-1.0)*x17*x40))))))+x45)))));
eerot[2]=(((x13*(((((-1.0)*x48))+(((-1.0)*x62))))))+((x12*x55)));
IkReal x67=((1.0)*x7);
IkReal x68=(x0*x29);
eetrans[0]=(((x0*x24))+((x3*(((((-1.0)*x16*x67))+((x19*x35))))))+((x13*((((x36*x54))+(((-0.097)*x48))))))+((x13*(((((0.076)*x46))+(((-0.076)*x68))))))+((x21*x35))+((x12*(((((-0.097)*x68))+(((0.097)*x46))))))+((x1*((((x15*x35))+(((-1.0)*x22*x67))))))+(((-0.3425)*x68))+(((-0.0525)*x5*x7))+(((0.0775)*x37))+((x12*((((x25*x54))+(((0.076)*x48)))))));
eerot[3]=(((x11*x65))+((x10*((((x12*x64))+((x13*x56)))))));
eerot[4]=(((x10*x65))+((x11*((((x34*x56))+((x31*x64)))))));
eerot[5]=(((x12*x56))+((x13*(((((-1.0)*x52))+(((-1.0)*x60)))))));
eetrans[1]=(((x21*x28))+((x12*(((((0.076)*x52))+((x25*x57))))))+((x13*((((x36*x57))+(((-0.097)*x52))))))+(((-1.0)*x16*x29))+((x22*x33))+((x1*(((((0.0775)*x30))+((x15*x28))))))+((x12*(((((-1.0)*x1*x14*x5))+(((0.097)*x50))))))+((x13*(((((0.076)*x50))+(((-0.076)*x29*x5))))))+((x3*(((((0.3425)*x30))+((x16*x4*x6))))))+(((0.0525)*x30))+((x24*x5)));
eerot[6]=(((x10*((x53+x61))))+((x11*x59)));
eerot[7]=(((x10*x59))+((x11*(((((-1.0)*x53))+(((-1.0)*x61)))))));
eerot[8]=(((x13*((x39+(((-1.0)*x51))))))+((x12*x47)));
eetrans[2]=((0.267)+((x12*((((x25*x44))+(((-0.076)*x2*x26))))))+(((-1.0)*x15*x29))+((x13*((((x36*x44))+((x14*x26))))))+(((-1.0)*x2*x21))+(((-1.0)*x19*x33))+(((0.0775)*x32))+(((-0.3425)*x27))+((x13*(((((-0.076)*x27))+(((-0.076)*x33*x4))))))+(((0.293)*x6))+((x12*(((((-0.097)*x27))+(((-1.0)*x14*x3*x4)))))));
}

IKFAST_API int GetNumFreeParameters() { return 1; }
IKFAST_API int* GetFreeParameters() { static int freeparams[] = {3}; return freeparams; }
IKFAST_API int GetNumJoints() { return 7; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x67000001; }

class IKSolver {
public:
IkReal j0,cj0,sj0,htj0,j0mul,j1,cj1,sj1,htj1,j1mul,j2,cj2,sj2,htj2,j2mul,j4,cj4,sj4,htj4,j4mul,j5,cj5,sj5,htj5,j5mul,j6,cj6,sj6,htj6,j6mul,j3,cj3,sj3,htj3,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij0[2], _nj0,_ij1[2], _nj1,_ij2[2], _nj2,_ij4[2], _nj4,_ij5[2], _nj5,_ij6[2], _nj6,_ij3[2], _nj3;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j0=numeric_limits<IkReal>::quiet_NaN(); _ij0[0] = -1; _ij0[1] = -1; _nj0 = -1; j1=numeric_limits<IkReal>::quiet_NaN(); _ij1[0] = -1; _ij1[1] = -1; _nj1 = -1; j2=numeric_limits<IkReal>::quiet_NaN(); _ij2[0] = -1; _ij2[1] = -1; _nj2 = -1; j4=numeric_limits<IkReal>::quiet_NaN(); _ij4[0] = -1; _ij4[1] = -1; _nj4 = -1; j5=numeric_limits<IkReal>::quiet_NaN(); _ij5[0] = -1; _ij5[1] = -1; _nj5 = -1; j6=numeric_limits<IkReal>::quiet_NaN(); _ij6[0] = -1; _ij6[1] = -1; _nj6 = -1;  _ij3[0] = -1; _ij3[1] = -1; _nj3 = 0; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
j3=pfree[0]; cj3=cos(pfree[0]); sj3=sin(pfree[0]), htj3=tan(pfree[0]*0.5);
r00 = eerot[0*3+0];
r01 = eerot[0*3+1];
r02 = eerot[0*3+2];
r10 = eerot[1*3+0];
r11 = eerot[1*3+1];
r12 = eerot[1*3+2];
r20 = eerot[2*3+0];
r21 = eerot[2*3+1];
r22 = eerot[2*3+2];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_r00=r00;
new_r01=r01;
new_r02=r02;
new_px=((((-0.097)*r02))+px);
new_r10=r10;
new_r11=r11;
new_r12=r12;
new_py=((((-0.097)*r12))+py);
new_r20=r20;
new_r21=r21;
new_r22=r22;
new_pz=((-0.267)+(((-0.097)*r22))+pz);
r00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;
IkReal x69=((1.0)*px);
IkReal x70=((1.0)*pz);
IkReal x71=((1.0)*py);
pp=((px*px)+(py*py)+(pz*pz));
npx=(((px*r00))+((py*r10))+((pz*r20)));
npy=(((px*r01))+((py*r11))+((pz*r21)));
npz=(((px*r02))+((py*r12))+((pz*r22)));
rxp0_0=((((-1.0)*r20*x71))+((pz*r10)));
rxp0_1=(((px*r20))+(((-1.0)*r00*x70)));
rxp0_2=((((-1.0)*r10*x69))+((py*r00)));
rxp1_0=((((-1.0)*r21*x71))+((pz*r11)));
rxp1_1=(((px*r21))+(((-1.0)*r01*x70)));
rxp1_2=((((-1.0)*r11*x69))+((py*r01)));
rxp2_0=((((-1.0)*r22*x71))+((pz*r12)));
rxp2_1=(((px*r22))+(((-1.0)*r02*x70)));
rxp2_2=((((-1.0)*r12*x69))+((py*r02)));
{
IkReal j6eval[2];
j6eval[0]=((npx*npx)+(npy*npy));
j6eval[1]=((IKabs(npy))+(IKabs(npx)));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j4, j5, j6]

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
CheckValue<IkReal> x74 = IKatan2WithCheck(IkReal(((-0.152)*npx)),IkReal(((0.152)*npy)),IKFAST_ATAN2_MAGTHRESH);
if(!x74.valid){
continue;
}
IkReal x72=((1.0)*(x74.value));
if((((((0.023104)*(npx*npx)))+(((0.023104)*(npy*npy))))) < -0.00001)
continue;
CheckValue<IkReal> x75=IKPowWithIntegerCheck(IKabs(IKsqrt(((((0.023104)*(npx*npx)))+(((0.023104)*(npy*npy)))))),-1);
if(!x75.valid){
continue;
}
if( (((x75.value)*(((-0.20614175)+(((0.1925675)*cj3))+pp+(((-0.0813775)*sj3)))))) < -1-IKFAST_SINCOS_THRESH || (((x75.value)*(((-0.20614175)+(((0.1925675)*cj3))+pp+(((-0.0813775)*sj3)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x73=IKasin(((x75.value)*(((-0.20614175)+(((0.1925675)*cj3))+pp+(((-0.0813775)*sj3))))));
j6array[0]=((((-1.0)*x72))+(((-1.0)*x73)));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x72))+x73);
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];

{
IkReal j5eval[2];
IkReal x76=(cj6*npx);
IkReal x77=(npy*sj6);
j5eval[0]=((1.0)+(((173.130193905817)*(x77*x77)))+(((173.130193905817)*(npz*npz)))+(((173.130193905817)*(x76*x76)))+(((-26.3157894736842)*x76))+(((26.3157894736842)*x77))+(((-346.260387811634)*x76*x77)));
j5eval[1]=((IKabs(npz))+(IKabs(((0.076)+x77+(((-1.0)*x76))))));
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
j4eval[0]=((-1.47619047619048)+(((-5.58095238095238)*sj3))+(((-1.0)*cj3)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.2276868576215)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
sj4array[0]=((((819672131.147541)*npx*sj6))+(((819672131.147541)*cj6*npy)));
if( sj4array[0] >= -1-IKFAST_SINCOS_THRESH && sj4array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j4valid[0] = j4valid[1] = true;
    j4array[0] = IKasin(sj4array[0]);
    cj4array[0] = IKcos(j4array[0]);
    sj4array[1] = sj4array[0];
    j4array[1] = j4array[0] > 0 ? (IKPI-j4array[0]) : (-IKPI-j4array[0]);
    cj4array[1] = -cj4array[0];
}
else if( isnan(sj4array[0]) )
{
    // probably any value will work
    j4valid[0] = true;
    cj4array[0] = 1; sj4array[0] = 0; j4array[0] = 0;
}
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

{
IkReal j5eval[3];
sj3=-0.08598789;
cj3=-0.99629618;
j3=3.22768551701203;
IkReal x78=cj4*cj4;
j5eval[0]=((2.66577892183399e+17)+x78);
j5eval[1]=IKsign(((3.01548646391586e+23)+(((1131184.0)*x78))));
j5eval[2]=((IKabs(((-1.2678337487137e+24)+(((3.149502082575e+24)*pp))+(((927200000000000.0)*cj4*npz)))))+(IKabs(((((2.45555826425442e+15)*cj4))+(((4.787243165514e+23)*npz))+(((-6.1e+15)*cj4*pp))))));
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  || IKabs(j5eval[2]) < 0.0000010000000000  )
{
{
IkReal j5eval[3];
sj3=-0.08598789;
cj3=-0.99629618;
j3=3.22768551701203;
IkReal x79=cj4*cj4;
j5eval[0]=((2.66577892183399e+17)+x79);
j5eval[1]=IKsign(((1.58709813890308e+22)+(((59536.0)*x79))));
j5eval[2]=((IKabs(((((2.51960166606e+22)*npz))+(((-321052631578947.0)*cj4*pp))+(((129239908644969.0)*cj4)))))+(IKabs(((-6.67280920375629e+22)+(((48800000000000.0)*cj4*npz))+(((1.65763267503947e+23)*pp))))));
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  || IKabs(j5eval[2]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
sj3=-0.08598789;
cj3=-0.99629618;
j3=3.22768551701203;
j5eval[0]=((1367378935.19596)+(((-3396788268.52351)*pp))+((cj4*npz)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
CheckValue<IkReal> x80=IKPowWithIntegerCheck(npz,-1);
if(!x80.valid){
continue;
}
IkReal gconst4=((8.49197067130878e-5)*(x80.value)*(((-16102021404947.0)+(((40000000000000.0)*pp)))));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.0)+(IKsign(sj4)))))+(IKabs((cj4+(((-1.0)*gconst4)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[2];
sj3=-0.08598789;
cj3=-0.99629618;
j3=3.22768551701203;
if((((1.0)+(((-1.0)*(gconst4*gconst4))))) < -0.00001)
continue;
sj4=IKsqrt(((1.0)+(((-1.0)*(gconst4*gconst4)))));
cj4=gconst4;
if( (gconst4) < -1-IKFAST_SINCOS_THRESH || (gconst4) > 1+IKFAST_SINCOS_THRESH )
    continue;
j4=IKacos(gconst4);
CheckValue<IkReal> x81=IKPowWithIntegerCheck(npz,-1);
if(!x81.valid){
continue;
}
IkReal gconst4=((8.49197067130878e-5)*(x81.value)*(((-16102021404947.0)+(((40000000000000.0)*pp)))));
CheckValue<IkReal> x83=IKPowWithIntegerCheck(npz,-1);
if(!x83.valid){
continue;
}
IkReal x82=x83.value;
j5eval[0]=((IKabs(((((1.28816171239576e+27)*pp*x82))+(((3.69664e+25)*npz))+(((-1.6e+27)*x82*(pp*pp)))+(((-2.59275093325371e+26)*x82)))))+(((77.2185550679688)*(IKabs(((-2.53566749742739e+24)+(((6.29900416515e+24)*pp))))))));
IkReal x84=((-16102021404947.0)+(((40000000000000.0)*pp)));
j5eval[1]=IKsign(((3.01548646391586e+23)+(((0.00815737119090811)*(x82*x82)*(x84*x84)))));
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  )
{
{
IkReal j5eval[2];
sj3=-0.08598789;
cj3=-0.99629618;
j3=3.22768551701203;
if((((1.0)+(((-1.0)*(gconst4*gconst4))))) < -0.00001)
continue;
sj4=IKsqrt(((1.0)+(((-1.0)*(gconst4*gconst4)))));
cj4=gconst4;
if( (gconst4) < -1-IKFAST_SINCOS_THRESH || (gconst4) > 1+IKFAST_SINCOS_THRESH )
    continue;
j4=IKacos(gconst4);
CheckValue<IkReal> x85=IKPowWithIntegerCheck(npz,-1);
if(!x85.valid){
continue;
}
IkReal gconst4=((8.49197067130878e-5)*(x85.value)*(((-16102021404947.0)+(((40000000000000.0)*pp)))));
CheckValue<IkReal> x87=IKPowWithIntegerCheck(npz,-1);
if(!x87.valid){
continue;
}
IkReal x86=x87.value;
j5eval[0]=((((1467.15254629141)*(IKabs(((-1.33456184075126e+23)+(((3.31526535007895e+23)*pp)))))))+(IKabs(((((1.28816171239576e+27)*pp*x86))+(((3.69664e+25)*npz))+(((-2.59275093325371e+26)*x86))+(((-1.6e+27)*x86*(pp*pp)))))));
IkReal x88=((-16102021404947.0)+(((40000000000000.0)*pp)));
j5eval[1]=IKsign(((1.58709813890308e+22)+(((0.000429335325837269)*(x86*x86)*(x88*x88)))));
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  )
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x89=(gconst4*pp);
CheckValue<IkReal> x90=IKPowWithIntegerCheck(((((1.525e+15)*x89))+(((-613889566063604.0)*gconst4))+(((1.1968107913785e+23)*npz))),-1);
if(!x90.valid){
continue;
}
CheckValue<IkReal> x91=IKPowWithIntegerCheck(((((-6.1e+15)*x89))+(((2.45555826425442e+15)*gconst4))+(((-4.787243165514e+23)*npz))),-1);
if(!x91.valid){
continue;
}
if( IKabs(((x90.value)*(((((1.25e+24)*npz*pp))+(((-5.03188168904594e+23)*npz))+(((146010916548177.0)*gconst4)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x91.value)*(((5.0289425815149e+24)+(((-2.64835878370839e+25)*pp))+(((3.28947368421053e+25)*(pp*pp))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x90.value)*(((((1.25e+24)*npz*pp))+(((-5.03188168904594e+23)*npz))+(((146010916548177.0)*gconst4))))))+IKsqr(((x91.value)*(((5.0289425815149e+24)+(((-2.64835878370839e+25)*pp))+(((3.28947368421053e+25)*(pp*pp)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x90.value)*(((((1.25e+24)*npz*pp))+(((-5.03188168904594e+23)*npz))+(((146010916548177.0)*gconst4))))), ((x91.value)*(((5.0289425815149e+24)+(((-2.64835878370839e+25)*pp))+(((3.28947368421053e+25)*(pp*pp)))))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[5];
IkReal x92=IKcos(j5);
IkReal x93=IKsin(j5);
IkReal x94=((1.0)*npz);
IkReal x95=((1.22e-9)*gconst4);
IkReal x96=((6.57894736842105)*pp);
IkReal x97=(gconst4*x92);
evalcond[0]=((-0.402550535123675)+(((-0.09574486331028)*x93))+pp+(((1.8544e-10)*x97)));
evalcond[1]=((((0.629900416515)*x92))+((x93*x95))+(((-1.0)*x94)));
evalcond[2]=((2.64835878370839)+(((0.629900416515)*x93))+(((-1.0)*x92*x95))+(((-1.0)*x96)));
evalcond[3]=((0.629900416515)+(((-1.0)*x92*x94))+(((2.64835878370839)*x93))+(((-1.0)*x93*x96)));
evalcond[4]=(((npz*x93))+(((-1.0)*x92*x96))+(((-1.0)*x95))+(((2.64835878370839)*x92)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x638=IKPowWithIntegerCheck(IKsign(((1.58709813890308e+22)+(((59536.0)*(gconst4*gconst4))))),-1);
if(!x638.valid){
continue;
}
CheckValue<IkReal> x639 = IKatan2WithCheck(IkReal(((-6.67280920375629e+22)+(((1.65763267503947e+23)*pp))+(((48800000000000.0)*gconst4*npz)))),IkReal(((((2.51960166606e+22)*npz))+(((129239908644969.0)*gconst4))+(((-321052631578947.0)*gconst4*pp)))),IKFAST_ATAN2_MAGTHRESH);
if(!x639.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(((1.5707963267949)*(x638.value)))+(x639.value));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[5];
IkReal x640=IKcos(j5);
IkReal x641=IKsin(j5);
IkReal x642=((1.0)*npz);
IkReal x643=((1.22e-9)*gconst4);
IkReal x644=((6.57894736842105)*pp);
IkReal x645=(gconst4*x640);
evalcond[0]=((-0.402550535123675)+(((-0.09574486331028)*x641))+(((1.8544e-10)*x645))+pp);
evalcond[1]=((((0.629900416515)*x640))+((x641*x643))+(((-1.0)*x642)));
evalcond[2]=((2.64835878370839)+(((0.629900416515)*x641))+(((-1.0)*x640*x643))+(((-1.0)*x644)));
evalcond[3]=((0.629900416515)+(((2.64835878370839)*x641))+(((-1.0)*x640*x642))+(((-1.0)*x641*x644)));
evalcond[4]=((((2.64835878370839)*x640))+((npz*x641))+(((-1.0)*x640*x644))+(((-1.0)*x643)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x646=IKPowWithIntegerCheck(IKsign(((3.01548646391586e+23)+(((1131184.0)*(gconst4*gconst4))))),-1);
if(!x646.valid){
continue;
}
CheckValue<IkReal> x647 = IKatan2WithCheck(IkReal(((-1.2678337487137e+24)+(((927200000000000.0)*gconst4*npz))+(((3.149502082575e+24)*pp)))),IkReal(((((-6.1e+15)*gconst4*pp))+(((4.787243165514e+23)*npz))+(((2.45555826425442e+15)*gconst4)))),IKFAST_ATAN2_MAGTHRESH);
if(!x647.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(((1.5707963267949)*(x646.value)))+(x647.value));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[5];
IkReal x648=IKcos(j5);
IkReal x649=IKsin(j5);
IkReal x650=((1.0)*npz);
IkReal x651=((1.22e-9)*gconst4);
IkReal x652=((6.57894736842105)*pp);
IkReal x653=(gconst4*x648);
evalcond[0]=((-0.402550535123675)+(((-0.09574486331028)*x649))+(((1.8544e-10)*x653))+pp);
evalcond[1]=((((0.629900416515)*x648))+((x649*x651))+(((-1.0)*x650)));
evalcond[2]=((2.64835878370839)+(((0.629900416515)*x649))+(((-1.0)*x652))+(((-1.0)*x648*x651)));
evalcond[3]=((0.629900416515)+(((2.64835878370839)*x649))+(((-1.0)*x649*x652))+(((-1.0)*x648*x650)));
evalcond[4]=((((2.64835878370839)*x648))+((npz*x649))+(((-1.0)*x651))+(((-1.0)*x648*x652)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
CheckValue<IkReal> x654=IKPowWithIntegerCheck(npz,-1);
if(!x654.valid){
continue;
}
IkReal gconst4=((8.49197067130878e-5)*(x654.value)*(((-16102021404947.0)+(((40000000000000.0)*pp)))));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((cj4+(((-1.0)*gconst4)))))+(IKabs(((1.0)+(IKsign(sj4)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[2];
sj3=-0.08598789;
cj3=-0.99629618;
j3=3.22768551701203;
if((((1.0)+(((-1.0)*(gconst4*gconst4))))) < -0.00001)
continue;
sj4=((-1.0)*(IKsqrt(((1.0)+(((-1.0)*(gconst4*gconst4)))))));
cj4=gconst4;
if( (gconst4) < -1-IKFAST_SINCOS_THRESH || (gconst4) > 1+IKFAST_SINCOS_THRESH )
    continue;
j4=((-1.0)*(IKacos(gconst4)));
CheckValue<IkReal> x655=IKPowWithIntegerCheck(npz,-1);
if(!x655.valid){
continue;
}
IkReal gconst4=((8.49197067130878e-5)*(x655.value)*(((-16102021404947.0)+(((40000000000000.0)*pp)))));
CheckValue<IkReal> x657=IKPowWithIntegerCheck(npz,-1);
if(!x657.valid){
continue;
}
IkReal x656=x657.value;
j5eval[0]=((IKabs(((((-2.59275093325371e+26)*x656))+(((3.69664e+25)*npz))+(((1.28816171239576e+27)*pp*x656))+(((-1.6e+27)*x656*(pp*pp))))))+(((77.2185550679688)*(IKabs(((-2.53566749742739e+24)+(((6.29900416515e+24)*pp))))))));
IkReal x658=((-16102021404947.0)+(((40000000000000.0)*pp)));
j5eval[1]=IKsign(((3.01548646391586e+23)+(((0.00815737119090811)*(x656*x656)*(x658*x658)))));
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  )
{
{
IkReal j5eval[2];
sj3=-0.08598789;
cj3=-0.99629618;
j3=3.22768551701203;
if((((1.0)+(((-1.0)*(gconst4*gconst4))))) < -0.00001)
continue;
sj4=((-1.0)*(IKsqrt(((1.0)+(((-1.0)*(gconst4*gconst4)))))));
cj4=gconst4;
if( (gconst4) < -1-IKFAST_SINCOS_THRESH || (gconst4) > 1+IKFAST_SINCOS_THRESH )
    continue;
j4=((-1.0)*(IKacos(gconst4)));
CheckValue<IkReal> x659=IKPowWithIntegerCheck(npz,-1);
if(!x659.valid){
continue;
}
IkReal gconst4=((8.49197067130878e-5)*(x659.value)*(((-16102021404947.0)+(((40000000000000.0)*pp)))));
CheckValue<IkReal> x661=IKPowWithIntegerCheck(npz,-1);
if(!x661.valid){
continue;
}
IkReal x660=x661.value;
j5eval[0]=((((1467.15254629141)*(IKabs(((-1.33456184075126e+23)+(((3.31526535007895e+23)*pp)))))))+(IKabs(((((-2.59275093325371e+26)*x660))+(((3.69664e+25)*npz))+(((1.28816171239576e+27)*pp*x660))+(((-1.6e+27)*x660*(pp*pp)))))));
IkReal x662=((-16102021404947.0)+(((40000000000000.0)*pp)));
j5eval[1]=IKsign(((1.58709813890308e+22)+(((0.000429335325837269)*(x660*x660)*(x662*x662)))));
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  )
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x663=(gconst4*pp);
CheckValue<IkReal> x664=IKPowWithIntegerCheck(((((-613889566063604.0)*gconst4))+(((1.525e+15)*x663))+(((1.1968107913785e+23)*npz))),-1);
if(!x664.valid){
continue;
}
CheckValue<IkReal> x665=IKPowWithIntegerCheck(((((-6.1e+15)*x663))+(((2.45555826425442e+15)*gconst4))+(((-4.787243165514e+23)*npz))),-1);
if(!x665.valid){
continue;
}
if( IKabs(((x664.value)*(((((1.25e+24)*npz*pp))+(((-5.03188168904594e+23)*npz))+(((146010916548177.0)*gconst4)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x665.value)*(((5.0289425815149e+24)+(((-2.64835878370839e+25)*pp))+(((3.28947368421053e+25)*(pp*pp))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x664.value)*(((((1.25e+24)*npz*pp))+(((-5.03188168904594e+23)*npz))+(((146010916548177.0)*gconst4))))))+IKsqr(((x665.value)*(((5.0289425815149e+24)+(((-2.64835878370839e+25)*pp))+(((3.28947368421053e+25)*(pp*pp)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x664.value)*(((((1.25e+24)*npz*pp))+(((-5.03188168904594e+23)*npz))+(((146010916548177.0)*gconst4))))), ((x665.value)*(((5.0289425815149e+24)+(((-2.64835878370839e+25)*pp))+(((3.28947368421053e+25)*(pp*pp)))))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[5];
IkReal x666=IKcos(j5);
IkReal x667=IKsin(j5);
IkReal x668=((1.0)*npz);
IkReal x669=((1.22e-9)*gconst4);
IkReal x670=((6.57894736842105)*pp);
IkReal x671=(gconst4*x666);
evalcond[0]=((-0.402550535123675)+(((-0.09574486331028)*x667))+pp+(((1.8544e-10)*x671)));
evalcond[1]=(((x667*x669))+(((-1.0)*x668))+(((0.629900416515)*x666)));
evalcond[2]=((2.64835878370839)+(((0.629900416515)*x667))+(((-1.0)*x666*x669))+(((-1.0)*x670)));
evalcond[3]=((0.629900416515)+(((2.64835878370839)*x667))+(((-1.0)*x667*x670))+(((-1.0)*x666*x668)));
evalcond[4]=((((2.64835878370839)*x666))+(((-1.0)*x666*x670))+(((-1.0)*x669))+((npz*x667)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x672=IKPowWithIntegerCheck(IKsign(((1.58709813890308e+22)+(((59536.0)*(gconst4*gconst4))))),-1);
if(!x672.valid){
continue;
}
CheckValue<IkReal> x673 = IKatan2WithCheck(IkReal(((-6.67280920375629e+22)+(((1.65763267503947e+23)*pp))+(((48800000000000.0)*gconst4*npz)))),IkReal(((((2.51960166606e+22)*npz))+(((129239908644969.0)*gconst4))+(((-321052631578947.0)*gconst4*pp)))),IKFAST_ATAN2_MAGTHRESH);
if(!x673.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(((1.5707963267949)*(x672.value)))+(x673.value));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[5];
IkReal x674=IKcos(j5);
IkReal x675=IKsin(j5);
IkReal x676=((1.0)*npz);
IkReal x677=((1.22e-9)*gconst4);
IkReal x678=((6.57894736842105)*pp);
IkReal x679=(gconst4*x674);
evalcond[0]=((-0.402550535123675)+pp+(((-0.09574486331028)*x675))+(((1.8544e-10)*x679)));
evalcond[1]=((((0.629900416515)*x674))+((x675*x677))+(((-1.0)*x676)));
evalcond[2]=((2.64835878370839)+(((0.629900416515)*x675))+(((-1.0)*x674*x677))+(((-1.0)*x678)));
evalcond[3]=((0.629900416515)+(((-1.0)*x675*x678))+(((2.64835878370839)*x675))+(((-1.0)*x674*x676)));
evalcond[4]=((((2.64835878370839)*x674))+((npz*x675))+(((-1.0)*x674*x678))+(((-1.0)*x677)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x680=IKPowWithIntegerCheck(IKsign(((3.01548646391586e+23)+(((1131184.0)*(gconst4*gconst4))))),-1);
if(!x680.valid){
continue;
}
CheckValue<IkReal> x681 = IKatan2WithCheck(IkReal(((-1.2678337487137e+24)+(((927200000000000.0)*gconst4*npz))+(((3.149502082575e+24)*pp)))),IkReal(((((-6.1e+15)*gconst4*pp))+(((4.787243165514e+23)*npz))+(((2.45555826425442e+15)*gconst4)))),IKFAST_ATAN2_MAGTHRESH);
if(!x681.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(((1.5707963267949)*(x680.value)))+(x681.value));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[5];
IkReal x682=IKcos(j5);
IkReal x683=IKsin(j5);
IkReal x684=((1.0)*npz);
IkReal x685=((1.22e-9)*gconst4);
IkReal x686=((6.57894736842105)*pp);
IkReal x687=(gconst4*x682);
evalcond[0]=((-0.402550535123675)+(((1.8544e-10)*x687))+pp+(((-0.09574486331028)*x683)));
evalcond[1]=((((0.629900416515)*x682))+(((-1.0)*x684))+((x683*x685)));
evalcond[2]=((2.64835878370839)+(((0.629900416515)*x683))+(((-1.0)*x686))+(((-1.0)*x682*x685)));
evalcond[3]=((0.629900416515)+(((-1.0)*x682*x684))+(((2.64835878370839)*x683))+(((-1.0)*x683*x686)));
evalcond[4]=(((npz*x683))+(((-1.0)*x685))+(((-1.0)*x682*x686))+(((2.64835878370839)*x682)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x688=(cj4*npz);
CheckValue<IkReal> x689=IKPowWithIntegerCheck(((6.67280920375629e+22)+(((48800000000000.0)*x688))+(((-1.65763267503947e+23)*pp))),-1);
if(!x689.valid){
continue;
}
CheckValue<IkReal> x690=IKPowWithIntegerCheck(((1.66820230093907e+22)+(((-4.14408168759868e+22)*pp))+(((12200000000000.0)*x688))),-1);
if(!x690.valid){
continue;
}
if( IKabs(((x689.value)*(((-1.58709813890308e+22)+(((4.0e+22)*(npz*npz))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x690.value)*(((((2.64835878370839e+22)*npz))+(((-6.57894736842105e+22)*npz*pp))+(((7684785081483.0)*cj4)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x689.value)*(((-1.58709813890308e+22)+(((4.0e+22)*(npz*npz)))))))+IKsqr(((x690.value)*(((((2.64835878370839e+22)*npz))+(((-6.57894736842105e+22)*npz*pp))+(((7684785081483.0)*cj4))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x689.value)*(((-1.58709813890308e+22)+(((4.0e+22)*(npz*npz)))))), ((x690.value)*(((((2.64835878370839e+22)*npz))+(((-6.57894736842105e+22)*npz*pp))+(((7684785081483.0)*cj4))))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[5];
IkReal x691=IKsin(j5);
IkReal x692=IKcos(j5);
IkReal x693=((1.22e-9)*cj4);
IkReal x694=((6.57894736842105)*pp);
IkReal x695=((1.0)*npz);
evalcond[0]=((-0.402550535123675)+(((-0.09574486331028)*x691))+pp+(((1.8544e-10)*cj4*x692)));
evalcond[1]=((((0.629900416515)*x692))+((x691*x693))+(((-1.0)*x695)));
evalcond[2]=((2.64835878370839)+(((0.629900416515)*x691))+(((-1.0)*x692*x693))+(((-1.0)*x694)));
evalcond[3]=((0.629900416515)+(((2.64835878370839)*x691))+(((-1.0)*x692*x695))+(((-1.0)*x691*x694)));
evalcond[4]=(((npz*x691))+(((2.64835878370839)*x692))+(((-1.0)*x692*x694))+(((-1.0)*x693)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x696 = IKatan2WithCheck(IkReal(((-6.67280920375629e+22)+(((48800000000000.0)*cj4*npz))+(((1.65763267503947e+23)*pp)))),IkReal(((((2.51960166606e+22)*npz))+(((-321052631578947.0)*cj4*pp))+(((129239908644969.0)*cj4)))),IKFAST_ATAN2_MAGTHRESH);
if(!x696.valid){
continue;
}
CheckValue<IkReal> x697=IKPowWithIntegerCheck(IKsign(((1.58709813890308e+22)+(((59536.0)*(cj4*cj4))))),-1);
if(!x697.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(x696.value)+(((1.5707963267949)*(x697.value))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[5];
IkReal x698=IKsin(j5);
IkReal x699=IKcos(j5);
IkReal x700=((1.22e-9)*cj4);
IkReal x701=((6.57894736842105)*pp);
IkReal x702=((1.0)*npz);
evalcond[0]=((-0.402550535123675)+(((-0.09574486331028)*x698))+pp+(((1.8544e-10)*cj4*x699)));
evalcond[1]=((((0.629900416515)*x699))+(((-1.0)*x702))+((x698*x700)));
evalcond[2]=((2.64835878370839)+(((0.629900416515)*x698))+(((-1.0)*x701))+(((-1.0)*x699*x700)));
evalcond[3]=((0.629900416515)+(((2.64835878370839)*x698))+(((-1.0)*x699*x702))+(((-1.0)*x698*x701)));
evalcond[4]=(((npz*x698))+(((2.64835878370839)*x699))+(((-1.0)*x700))+(((-1.0)*x699*x701)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x703 = IKatan2WithCheck(IkReal(((-1.2678337487137e+24)+(((3.149502082575e+24)*pp))+(((927200000000000.0)*cj4*npz)))),IkReal(((((2.45555826425442e+15)*cj4))+(((4.787243165514e+23)*npz))+(((-6.1e+15)*cj4*pp)))),IKFAST_ATAN2_MAGTHRESH);
if(!x703.valid){
continue;
}
CheckValue<IkReal> x704=IKPowWithIntegerCheck(IKsign(((3.01548646391586e+23)+(((1131184.0)*(cj4*cj4))))),-1);
if(!x704.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(x703.value)+(((1.5707963267949)*(x704.value))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[5];
IkReal x705=IKsin(j5);
IkReal x706=IKcos(j5);
IkReal x707=((1.22e-9)*cj4);
IkReal x708=((6.57894736842105)*pp);
IkReal x709=((1.0)*npz);
evalcond[0]=((-0.402550535123675)+(((1.8544e-10)*cj4*x706))+(((-0.09574486331028)*x705))+pp);
evalcond[1]=((((-1.0)*x709))+(((0.629900416515)*x706))+((x705*x707)));
evalcond[2]=((2.64835878370839)+(((-1.0)*x706*x707))+(((-1.0)*x708))+(((0.629900416515)*x705)));
evalcond[3]=((0.629900416515)+(((-1.0)*x706*x709))+(((2.64835878370839)*x705))+(((-1.0)*x705*x708)));
evalcond[4]=((((-1.0)*x706*x708))+((npz*x705))+(((2.64835878370839)*x706))+(((-1.0)*x707)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-5.8424922655324)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
sj4array[0]=((((-51305507480.2948)*npx*sj6))+(((-51305507480.2948)*cj6*npy)));
if( sj4array[0] >= -1-IKFAST_SINCOS_THRESH && sj4array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j4valid[0] = j4valid[1] = true;
    j4array[0] = IKasin(sj4array[0]);
    cj4array[0] = IKcos(j4array[0]);
    sj4array[1] = sj4array[0];
    j4array[1] = j4array[0] > 0 ? (IKPI-j4array[0]) : (-IKPI-j4array[0]);
    cj4array[1] = -cj4array[0];
}
else if( isnan(sj4array[0]) )
{
    // probably any value will work
    j4valid[0] = true;
    cj4array[0] = 1; sj4array[0] = 0; j4array[0] = 0;
}
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

{
IkReal j5eval[3];
sj3=-0.426566392851566;
cj3=0.90445625;
j3=5.84249356263499;
IkReal x710=cj4*cj4;
j5eval[0]=((7.99143187523418e+18)+x710);
j5eval[1]=IKsign(((1.29848489559027e+31)+(((1624846355275.0)*x710))));
j5eval[2]=((IKabs(((((2.35661473633585e+32)*npz))+(((5.484445186506e+23)*cj4*pp))+(((-4.83287359777169e+21)*cj4)))))+(IKabs(((-1.3662108726603e+31)+(((-8.33635668348912e+22)*cj4*npz))+(((1.5504044317999e+33)*pp))))));
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  || IKabs(j5eval[2]) < 0.0000010000000000  )
{
{
IkReal j5eval[3];
sj3=-0.426566392851566;
cj3=0.90445625;
j3=5.84249356263499;
IkReal x711=cj4*cj4;
j5eval[0]=((-7.99143187523418e+18)+(((-1.0)*x711)));
j5eval[1]=((IKabs(((((-1.24032354543992e+31)*npz))+(((2.54361768303773e+20)*cj4))+(((-2.88655009816105e+22)*cj4*pp)))))+(IKabs(((7.19058354031738e+29)+(((4.3875561492048e+21)*cj4*npz))+(((-8.16002332526264e+31)*pp))))));
j5eval[2]=IKsign(((-6.83413102942248e+29)+(((-85518229225.0)*x711))));
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  || IKabs(j5eval[2]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
sj3=-0.426566392851566;
cj3=0.90445625;
j3=5.84249356263499;
j5eval[0]=((-163885846.603253)+(((18598105751.2884)*pp))+((cj4*npz)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
CheckValue<IkReal> x712=IKPowWithIntegerCheck(npz,-1);
if(!x712.valid){
continue;
}
IkReal gconst5=((6.19791162828051e-9)*(x712.value)*(((2.64421076698572e+16)+(((-3.000705216e+18)*pp)))));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((cj4+(((-1.0)*gconst5)))))+(IKabs(((-1.0)+(IKsign(sj4)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[2];
sj3=-0.426566392851566;
cj3=0.90445625;
j3=5.84249356263499;
if((((1.0)+(((-1.0)*(gconst5*gconst5))))) < -0.00001)
continue;
sj4=IKsqrt(((1.0)+(((-1.0)*(gconst5*gconst5)))));
cj4=gconst5;
if( (gconst5) < -1-IKFAST_SINCOS_THRESH || (gconst5) > 1+IKFAST_SINCOS_THRESH )
    continue;
j4=IKacos(gconst5);
CheckValue<IkReal> x713=IKPowWithIntegerCheck(npz,-1);
if(!x713.valid){
continue;
}
IkReal gconst5=((6.19791162828051e-9)*(x713.value)*(((2.64421076698572e+16)+(((-3.000705216e+18)*pp)))));
CheckValue<IkReal> x715=IKPowWithIntegerCheck(npz,-1);
if(!x715.valid){
continue;
}
IkReal x714=x715.value;
IkReal x716=((2.64421076698572e+16)+(((-3.000705216e+18)*pp)));
j5eval[0]=IKsign(((1.29848489559027e+31)+(((6.24170242718143e-5)*(x714*x714)*(x716*x716)))));
j5eval[1]=((((882.765299501375)*(IKabs(((-2.73242174532061e+31)+(((3.1008088635998e+33)*pp)))))))+(IKabs(((((2.08033771353087e+35)*npz))+(((-9.00423179332961e+36)*x714*(pp*pp)))+(((1.58689940813948e+35)*pp*x714))+(((-6.99185058024323e+32)*x714))))));
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  )
{
{
IkReal j5eval[2];
sj3=-0.426566392851566;
cj3=0.90445625;
j3=5.84249356263499;
if((((1.0)+(((-1.0)*(gconst5*gconst5))))) < -0.00001)
continue;
sj4=IKsqrt(((1.0)+(((-1.0)*(gconst5*gconst5)))));
cj4=gconst5;
if( (gconst5) < -1-IKFAST_SINCOS_THRESH || (gconst5) > 1+IKFAST_SINCOS_THRESH )
    continue;
j4=IKacos(gconst5);
CheckValue<IkReal> x717=IKPowWithIntegerCheck(npz,-1);
if(!x717.valid){
continue;
}
IkReal gconst5=((6.19791162828051e-9)*(x717.value)*(((2.64421076698572e+16)+(((-3.000705216e+18)*pp)))));
CheckValue<IkReal> x719=IKPowWithIntegerCheck(npz,-1);
if(!x719.valid){
continue;
}
IkReal x718=x719.value;
IkReal x720=((2.64421076698572e+16)+(((-3.000705216e+18)*pp)));
j5eval[0]=IKsign(((-6.83413102942248e+29)+(((-3.28510654062181e-6)*(x718*x718)*(x720*x720)))));
j5eval[1]=((IKabs(((((-2.08033771353087e+35)*npz))+(((9.00423179332961e+36)*x718*(pp*pp)))+(((6.99185058024323e+32)*x718))+(((-1.58689940813948e+35)*pp*x718)))))+(((16772.5406905261)*(IKabs(((1.43811670806348e+30)+(((-1.63200466505253e+32)*pp))))))));
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  )
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x721=(gconst5*pp);
CheckValue<IkReal> x722=IKPowWithIntegerCheck(((((7.85538245445284e+30)*npz))+(((-1.828148395502e+22)*x721))+(((1.6109578659239e+20)*gconst5))),-1);
if(!x722.valid){
continue;
}
CheckValue<IkReal> x723=IKPowWithIntegerCheck(((((-4.570370988755e+22)*x721))+(((1.96384561361321e+31)*npz))+(((4.02739466480974e+20)*gconst5))),-1);
if(!x723.valid){
continue;
}
if( IKabs(((x722.value)*(((((-8.26510108405981e+30)*npz))+(((9.37940811805167e+32)*npz*pp))+(((-1.53109926014666e+20)*gconst5)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x723.value)*(((-1.15820320739471e+29)+(((2.71878325133546e+32)*pp))+(((-1.54266580889008e+34)*(pp*pp))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x722.value)*(((((-8.26510108405981e+30)*npz))+(((9.37940811805167e+32)*npz*pp))+(((-1.53109926014666e+20)*gconst5))))))+IKsqr(((x723.value)*(((-1.15820320739471e+29)+(((2.71878325133546e+32)*pp))+(((-1.54266580889008e+34)*(pp*pp)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x722.value)*(((((-8.26510108405981e+30)*npz))+(((9.37940811805167e+32)*npz*pp))+(((-1.53109926014666e+20)*gconst5))))), ((x723.value)*(((-1.15820320739471e+29)+(((2.71878325133546e+32)*pp))+(((-1.54266580889008e+34)*(pp*pp)))))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[5];
IkReal x724=IKcos(j5);
IkReal x725=IKsin(j5);
IkReal x726=((6.57894736842105)*pp);
IkReal x727=((1.0)*npz);
IkReal x728=((1.94910848583668e-11)*gconst5);
IkReal x729=(gconst5*x724);
evalcond[0]=((-0.00881196444384667)+(((-2.96264489847176e-12)*x729))+(((-0.0083751366350445)*x725))+pp);
evalcond[1]=((((0.0550995831252928)*x724))+(((-1.0)*x727))+(((-1.0)*x725*x728)));
evalcond[2]=((0.0579734502884649)+(((0.0550995831252928)*x725))+(((-1.0)*x726))+((x724*x728)));
evalcond[3]=((0.0550995831252928)+(((0.0579734502884649)*x725))+(((-1.0)*x724*x727))+(((-1.0)*x725*x726)));
evalcond[4]=((((0.0579734502884649)*x724))+(((-1.0)*x724*x726))+((npz*x725))+x728);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x730 = IKatan2WithCheck(IkReal(((7.19058354031738e+29)+(((-8.16002332526264e+31)*pp))+(((4.3875561492048e+21)*gconst5*npz)))),IkReal(((((2.54361768303773e+20)*gconst5))+(((-1.24032354543992e+31)*npz))+(((-2.88655009816105e+22)*gconst5*pp)))),IKFAST_ATAN2_MAGTHRESH);
if(!x730.valid){
continue;
}
CheckValue<IkReal> x731=IKPowWithIntegerCheck(IKsign(((-6.83413102942248e+29)+(((-85518229225.0)*(gconst5*gconst5))))),-1);
if(!x731.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(x730.value)+(((1.5707963267949)*(x731.value))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[5];
IkReal x732=IKcos(j5);
IkReal x733=IKsin(j5);
IkReal x734=((6.57894736842105)*pp);
IkReal x735=((1.0)*npz);
IkReal x736=((1.94910848583668e-11)*gconst5);
IkReal x737=(gconst5*x732);
evalcond[0]=((-0.00881196444384667)+(((-2.96264489847176e-12)*x737))+(((-0.0083751366350445)*x733))+pp);
evalcond[1]=((((0.0550995831252928)*x732))+(((-1.0)*x733*x736))+(((-1.0)*x735)));
evalcond[2]=((0.0579734502884649)+(((0.0550995831252928)*x733))+(((-1.0)*x734))+((x732*x736)));
evalcond[3]=((0.0550995831252928)+(((0.0579734502884649)*x733))+(((-1.0)*x732*x735))+(((-1.0)*x733*x734)));
evalcond[4]=((((0.0579734502884649)*x732))+((npz*x733))+(((-1.0)*x732*x734))+x736);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x738 = IKatan2WithCheck(IkReal(((-1.3662108726603e+31)+(((-8.33635668348912e+22)*gconst5*npz))+(((1.5504044317999e+33)*pp)))),IkReal(((((2.35661473633585e+32)*npz))+(((-4.83287359777169e+21)*gconst5))+(((5.484445186506e+23)*gconst5*pp)))),IKFAST_ATAN2_MAGTHRESH);
if(!x738.valid){
continue;
}
CheckValue<IkReal> x739=IKPowWithIntegerCheck(IKsign(((1.29848489559027e+31)+(((1624846355275.0)*(gconst5*gconst5))))),-1);
if(!x739.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(x738.value)+(((1.5707963267949)*(x739.value))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[5];
IkReal x740=IKcos(j5);
IkReal x741=IKsin(j5);
IkReal x742=((6.57894736842105)*pp);
IkReal x743=((1.0)*npz);
IkReal x744=((1.94910848583668e-11)*gconst5);
IkReal x745=(gconst5*x740);
evalcond[0]=((-0.00881196444384667)+(((-0.0083751366350445)*x741))+pp+(((-2.96264489847176e-12)*x745)));
evalcond[1]=((((0.0550995831252928)*x740))+(((-1.0)*x741*x744))+(((-1.0)*x743)));
evalcond[2]=((0.0579734502884649)+(((0.0550995831252928)*x741))+((x740*x744))+(((-1.0)*x742)));
evalcond[3]=((0.0550995831252928)+(((0.0579734502884649)*x741))+(((-1.0)*x740*x743))+(((-1.0)*x741*x742)));
evalcond[4]=((((0.0579734502884649)*x740))+(((-1.0)*x740*x742))+x744+((npz*x741)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
CheckValue<IkReal> x746=IKPowWithIntegerCheck(npz,-1);
if(!x746.valid){
continue;
}
IkReal gconst5=((6.19791162828051e-9)*(x746.value)*(((2.64421076698572e+16)+(((-3.000705216e+18)*pp)))));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((cj4+(((-1.0)*gconst5)))))+(IKabs(((1.0)+(IKsign(sj4)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[2];
sj3=-0.426566392851566;
cj3=0.90445625;
j3=5.84249356263499;
if((((1.0)+(((-1.0)*(gconst5*gconst5))))) < -0.00001)
continue;
sj4=((-1.0)*(IKsqrt(((1.0)+(((-1.0)*(gconst5*gconst5)))))));
cj4=gconst5;
if( (gconst5) < -1-IKFAST_SINCOS_THRESH || (gconst5) > 1+IKFAST_SINCOS_THRESH )
    continue;
j4=((-1.0)*(IKacos(gconst5)));
CheckValue<IkReal> x747=IKPowWithIntegerCheck(npz,-1);
if(!x747.valid){
continue;
}
IkReal gconst5=((6.19791162828051e-9)*(x747.value)*(((2.64421076698572e+16)+(((-3.000705216e+18)*pp)))));
CheckValue<IkReal> x749=IKPowWithIntegerCheck(npz,-1);
if(!x749.valid){
continue;
}
IkReal x748=x749.value;
IkReal x750=((2.64421076698572e+16)+(((-3.000705216e+18)*pp)));
j5eval[0]=IKsign(((1.29848489559027e+31)+(((6.24170242718143e-5)*(x748*x748)*(x750*x750)))));
j5eval[1]=((IKabs(((((2.08033771353087e+35)*npz))+(((1.58689940813948e+35)*pp*x748))+(((-6.99185058024323e+32)*x748))+(((-9.00423179332961e+36)*x748*(pp*pp))))))+(((882.765299501375)*(IKabs(((-2.73242174532061e+31)+(((3.1008088635998e+33)*pp))))))));
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  )
{
{
IkReal j5eval[2];
sj3=-0.426566392851566;
cj3=0.90445625;
j3=5.84249356263499;
if((((1.0)+(((-1.0)*(gconst5*gconst5))))) < -0.00001)
continue;
sj4=((-1.0)*(IKsqrt(((1.0)+(((-1.0)*(gconst5*gconst5)))))));
cj4=gconst5;
if( (gconst5) < -1-IKFAST_SINCOS_THRESH || (gconst5) > 1+IKFAST_SINCOS_THRESH )
    continue;
j4=((-1.0)*(IKacos(gconst5)));
CheckValue<IkReal> x751=IKPowWithIntegerCheck(npz,-1);
if(!x751.valid){
continue;
}
IkReal gconst5=((6.19791162828051e-9)*(x751.value)*(((2.64421076698572e+16)+(((-3.000705216e+18)*pp)))));
CheckValue<IkReal> x753=IKPowWithIntegerCheck(npz,-1);
if(!x753.valid){
continue;
}
IkReal x752=x753.value;
IkReal x754=((2.64421076698572e+16)+(((-3.000705216e+18)*pp)));
j5eval[0]=IKsign(((-6.83413102942248e+29)+(((-3.28510654062181e-6)*(x752*x752)*(x754*x754)))));
j5eval[1]=((IKabs(((((-1.58689940813948e+35)*pp*x752))+(((-2.08033771353087e+35)*npz))+(((9.00423179332961e+36)*x752*(pp*pp)))+(((6.99185058024323e+32)*x752)))))+(((16772.5406905261)*(IKabs(((1.43811670806348e+30)+(((-1.63200466505253e+32)*pp))))))));
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  )
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x755=(gconst5*pp);
CheckValue<IkReal> x756=IKPowWithIntegerCheck(((((-1.828148395502e+22)*x755))+(((7.85538245445284e+30)*npz))+(((1.6109578659239e+20)*gconst5))),-1);
if(!x756.valid){
continue;
}
CheckValue<IkReal> x757=IKPowWithIntegerCheck(((((1.96384561361321e+31)*npz))+(((-4.570370988755e+22)*x755))+(((4.02739466480974e+20)*gconst5))),-1);
if(!x757.valid){
continue;
}
if( IKabs(((x756.value)*(((((-8.26510108405981e+30)*npz))+(((9.37940811805167e+32)*npz*pp))+(((-1.53109926014666e+20)*gconst5)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x757.value)*(((-1.15820320739471e+29)+(((2.71878325133546e+32)*pp))+(((-1.54266580889008e+34)*(pp*pp))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x756.value)*(((((-8.26510108405981e+30)*npz))+(((9.37940811805167e+32)*npz*pp))+(((-1.53109926014666e+20)*gconst5))))))+IKsqr(((x757.value)*(((-1.15820320739471e+29)+(((2.71878325133546e+32)*pp))+(((-1.54266580889008e+34)*(pp*pp)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x756.value)*(((((-8.26510108405981e+30)*npz))+(((9.37940811805167e+32)*npz*pp))+(((-1.53109926014666e+20)*gconst5))))), ((x757.value)*(((-1.15820320739471e+29)+(((2.71878325133546e+32)*pp))+(((-1.54266580889008e+34)*(pp*pp)))))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[5];
IkReal x758=IKcos(j5);
IkReal x759=IKsin(j5);
IkReal x760=((6.57894736842105)*pp);
IkReal x761=((1.0)*npz);
IkReal x762=((1.94910848583668e-11)*gconst5);
IkReal x763=(gconst5*x758);
evalcond[0]=((-0.00881196444384667)+(((-0.0083751366350445)*x759))+(((-2.96264489847176e-12)*x763))+pp);
evalcond[1]=((((0.0550995831252928)*x758))+(((-1.0)*x761))+(((-1.0)*x759*x762)));
evalcond[2]=((0.0579734502884649)+(((0.0550995831252928)*x759))+(((-1.0)*x760))+((x758*x762)));
evalcond[3]=((0.0550995831252928)+(((-1.0)*x758*x761))+(((0.0579734502884649)*x759))+(((-1.0)*x759*x760)));
evalcond[4]=((((-1.0)*x758*x760))+((npz*x759))+(((0.0579734502884649)*x758))+x762);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x764 = IKatan2WithCheck(IkReal(((7.19058354031738e+29)+(((-8.16002332526264e+31)*pp))+(((4.3875561492048e+21)*gconst5*npz)))),IkReal(((((2.54361768303773e+20)*gconst5))+(((-1.24032354543992e+31)*npz))+(((-2.88655009816105e+22)*gconst5*pp)))),IKFAST_ATAN2_MAGTHRESH);
if(!x764.valid){
continue;
}
CheckValue<IkReal> x765=IKPowWithIntegerCheck(IKsign(((-6.83413102942248e+29)+(((-85518229225.0)*(gconst5*gconst5))))),-1);
if(!x765.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(x764.value)+(((1.5707963267949)*(x765.value))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[5];
IkReal x766=IKcos(j5);
IkReal x767=IKsin(j5);
IkReal x768=((6.57894736842105)*pp);
IkReal x769=((1.0)*npz);
IkReal x770=((1.94910848583668e-11)*gconst5);
IkReal x771=(gconst5*x766);
evalcond[0]=((-0.00881196444384667)+(((-0.0083751366350445)*x767))+pp+(((-2.96264489847176e-12)*x771)));
evalcond[1]=((((0.0550995831252928)*x766))+(((-1.0)*x769))+(((-1.0)*x767*x770)));
evalcond[2]=((0.0579734502884649)+(((0.0550995831252928)*x767))+(((-1.0)*x768))+((x766*x770)));
evalcond[3]=((0.0550995831252928)+(((-1.0)*x766*x769))+(((-1.0)*x767*x768))+(((0.0579734502884649)*x767)));
evalcond[4]=(((npz*x767))+(((-1.0)*x766*x768))+x770+(((0.0579734502884649)*x766)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x772 = IKatan2WithCheck(IkReal(((-1.3662108726603e+31)+(((-8.33635668348912e+22)*gconst5*npz))+(((1.5504044317999e+33)*pp)))),IkReal(((((2.35661473633585e+32)*npz))+(((-4.83287359777169e+21)*gconst5))+(((5.484445186506e+23)*gconst5*pp)))),IKFAST_ATAN2_MAGTHRESH);
if(!x772.valid){
continue;
}
CheckValue<IkReal> x773=IKPowWithIntegerCheck(IKsign(((1.29848489559027e+31)+(((1624846355275.0)*(gconst5*gconst5))))),-1);
if(!x773.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(x772.value)+(((1.5707963267949)*(x773.value))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[5];
IkReal x774=IKcos(j5);
IkReal x775=IKsin(j5);
IkReal x776=((6.57894736842105)*pp);
IkReal x777=((1.0)*npz);
IkReal x778=((1.94910848583668e-11)*gconst5);
IkReal x779=(gconst5*x774);
evalcond[0]=((-0.00881196444384667)+(((-0.0083751366350445)*x775))+pp+(((-2.96264489847176e-12)*x779)));
evalcond[1]=((((0.0550995831252928)*x774))+(((-1.0)*x775*x778))+(((-1.0)*x777)));
evalcond[2]=((0.0579734502884649)+((x774*x778))+(((0.0550995831252928)*x775))+(((-1.0)*x776)));
evalcond[3]=((0.0550995831252928)+(((-1.0)*x774*x777))+(((0.0579734502884649)*x775))+(((-1.0)*x775*x776)));
evalcond[4]=((((-1.0)*x774*x776))+(((0.0579734502884649)*x774))+x778+((npz*x775)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x780=(cj4*npz);
CheckValue<IkReal> x781=IKPowWithIntegerCheck(((-5.99215295026449e+28)+(((6.80001943771887e+30)*pp))+(((3.656296791004e+20)*x780))),-1);
if(!x781.valid){
continue;
}
CheckValue<IkReal> x782=IKPowWithIntegerCheck(((-2.39686118010579e+28)+(((1.4625187164016e+20)*x780))+(((2.72000777508755e+30)*pp))),-1);
if(!x782.valid){
continue;
}
if( IKabs(((x781.value)*(((5.6951091911854e+28)+(((-1.87588162361033e+31)*(npz*npz))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x782.value)*(((((4.93653058844825e+31)*npz*pp))+(((-4.35005320213674e+29)*npz))+(((8.05841715866664e+18)*cj4)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x781.value)*(((5.6951091911854e+28)+(((-1.87588162361033e+31)*(npz*npz)))))))+IKsqr(((x782.value)*(((((4.93653058844825e+31)*npz*pp))+(((-4.35005320213674e+29)*npz))+(((8.05841715866664e+18)*cj4))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x781.value)*(((5.6951091911854e+28)+(((-1.87588162361033e+31)*(npz*npz)))))), ((x782.value)*(((((4.93653058844825e+31)*npz*pp))+(((-4.35005320213674e+29)*npz))+(((8.05841715866664e+18)*cj4))))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[5];
IkReal x783=IKcos(j5);
IkReal x784=IKsin(j5);
IkReal x785=((1.94910848583668e-11)*cj4);
IkReal x786=((6.57894736842105)*pp);
IkReal x787=((1.0)*npz);
evalcond[0]=((-0.00881196444384667)+(((-0.0083751366350445)*x784))+pp+(((-2.96264489847176e-12)*cj4*x783)));
evalcond[1]=((((-1.0)*x787))+(((-1.0)*x784*x785))+(((0.0550995831252928)*x783)));
evalcond[2]=((0.0579734502884649)+(((-1.0)*x786))+((x783*x785))+(((0.0550995831252928)*x784)));
evalcond[3]=((0.0550995831252928)+(((-1.0)*x784*x786))+(((0.0579734502884649)*x784))+(((-1.0)*x783*x787)));
evalcond[4]=(x785+(((0.0579734502884649)*x783))+((npz*x784))+(((-1.0)*x783*x786)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x788=IKPowWithIntegerCheck(IKsign(((-6.83413102942248e+29)+(((-85518229225.0)*(cj4*cj4))))),-1);
if(!x788.valid){
continue;
}
CheckValue<IkReal> x789 = IKatan2WithCheck(IkReal(((7.19058354031738e+29)+(((4.3875561492048e+21)*cj4*npz))+(((-8.16002332526264e+31)*pp)))),IkReal(((((-1.24032354543992e+31)*npz))+(((2.54361768303773e+20)*cj4))+(((-2.88655009816105e+22)*cj4*pp)))),IKFAST_ATAN2_MAGTHRESH);
if(!x789.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(((1.5707963267949)*(x788.value)))+(x789.value));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[5];
IkReal x790=IKcos(j5);
IkReal x791=IKsin(j5);
IkReal x792=((1.94910848583668e-11)*cj4);
IkReal x793=((6.57894736842105)*pp);
IkReal x794=((1.0)*npz);
evalcond[0]=((-0.00881196444384667)+(((-2.96264489847176e-12)*cj4*x790))+(((-0.0083751366350445)*x791))+pp);
evalcond[1]=((((-1.0)*x794))+(((-1.0)*x791*x792))+(((0.0550995831252928)*x790)));
evalcond[2]=((0.0579734502884649)+(((-1.0)*x793))+((x790*x792))+(((0.0550995831252928)*x791)));
evalcond[3]=((0.0550995831252928)+(((-1.0)*x791*x793))+(((-1.0)*x790*x794))+(((0.0579734502884649)*x791)));
evalcond[4]=((((-1.0)*x790*x793))+(((0.0579734502884649)*x790))+x792+((npz*x791)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x795 = IKatan2WithCheck(IkReal(((-1.3662108726603e+31)+(((-8.33635668348912e+22)*cj4*npz))+(((1.5504044317999e+33)*pp)))),IkReal(((((2.35661473633585e+32)*npz))+(((5.484445186506e+23)*cj4*pp))+(((-4.83287359777169e+21)*cj4)))),IKFAST_ATAN2_MAGTHRESH);
if(!x795.valid){
continue;
}
CheckValue<IkReal> x796=IKPowWithIntegerCheck(IKsign(((1.29848489559027e+31)+(((1624846355275.0)*(cj4*cj4))))),-1);
if(!x796.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(x795.value)+(((1.5707963267949)*(x796.value))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[5];
IkReal x797=IKcos(j5);
IkReal x798=IKsin(j5);
IkReal x799=((1.94910848583668e-11)*cj4);
IkReal x800=((6.57894736842105)*pp);
IkReal x801=((1.0)*npz);
evalcond[0]=((-0.00881196444384667)+(((-2.96264489847176e-12)*cj4*x797))+(((-0.0083751366350445)*x798))+pp);
evalcond[1]=((((-1.0)*x798*x799))+(((-1.0)*x801))+(((0.0550995831252928)*x797)));
evalcond[2]=((0.0579734502884649)+(((-1.0)*x800))+((x797*x799))+(((0.0550995831252928)*x798)));
evalcond[3]=((0.0550995831252928)+(((-1.0)*x798*x800))+(((-1.0)*x797*x801))+(((0.0579734502884649)*x798)));
evalcond[4]=((((-1.0)*x797*x800))+(((0.0579734502884649)*x797))+x799+((npz*x798)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4, j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
CheckValue<IkReal> x802=IKPowWithIntegerCheck(((-0.0775)+(((-0.0525)*cj3))+(((-0.293)*sj3))),-1);
if(!x802.valid){
continue;
}
sj4array[0]=((x802.value)*(((((1.0)*npx*sj6))+(((1.0)*cj6*npy)))));
if( sj4array[0] >= -1-IKFAST_SINCOS_THRESH && sj4array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j4valid[0] = j4valid[1] = true;
    j4array[0] = IKasin(sj4array[0]);
    cj4array[0] = IKcos(j4array[0]);
    sj4array[1] = sj4array[0];
    j4array[1] = j4array[0] > 0 ? (IKPI-j4array[0]) : (-IKPI-j4array[0]);
    cj4array[1] = -cj4array[0];
}
else if( isnan(sj4array[0]) )
{
    // probably any value will work
    j4valid[0] = true;
    cj4array[0] = 1; sj4array[0] = 0; j4array[0] = 0;
}
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

{
IkReal j5eval[2];
IkReal x803=(cj4*npz);
IkReal x804=(cj6*npx);
IkReal x805=((73.4335839598997)*cj3);
IkReal x806=((13.1578947368421)*sj3);
IkReal x807=((0.0525)*sj3);
IkReal x808=((0.293)*cj3);
IkReal x809=(npy*sj6);
j5eval[0]=((6.52380952380952)+((x804*x805))+(((-5.58095238095238)*cj3))+(((-19.4235588972431)*x803))+sj3+(((-1.0)*x804*x806))+(((-1.0)*x805*x809))+((x806*x809))+(((85.8395989974937)*x809))+(((-73.4335839598997)*sj3*x803))+(((-13.1578947368421)*cj3*x803))+(((-85.8395989974937)*x804)));
j5eval[1]=IKsign(((0.02603)+((x804*x808))+(((-1.0)*x804*x807))+(((-0.3425)*x804))+(((-1.0)*x808*x809))+(((0.00399)*sj3))+(((0.3425)*x809))+(((-0.0775)*x803))+(((-0.293)*sj3*x803))+(((-0.0525)*cj3*x803))+(((-0.022268)*cj3))+((x807*x809))));
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  )
{
{
IkReal j5eval[2];
IkReal x810=(cj4*sj3);
IkReal x811=(cj3*cj4);
IkReal x812=(npy*sj6);
IkReal x813=(cj6*npx);
IkReal x814=(cj3*npz);
IkReal x815=((0.0775)*cj4);
IkReal x816=(npz*sj3);
IkReal x817=((19.4235588972431)*cj4);
j5eval[0]=((((-1.0)*x812*x817))+(((73.4335839598997)*x814))+((x813*x817))+(((-13.1578947368421)*x811*x812))+(((-1.0)*x811))+(((-85.8395989974937)*npz))+(((-5.58095238095238)*x810))+(((-1.47619047619048)*cj4))+(((-73.4335839598997)*x810*x812))+(((73.4335839598997)*x810*x813))+(((13.1578947368421)*x811*x813))+(((-13.1578947368421)*x816)));
j5eval[1]=IKsign(((((-1.0)*x812*x815))+(((-0.00399)*x811))+((x813*x815))+(((-0.293)*x810*x812))+(((-0.022268)*x810))+(((-0.3425)*npz))+(((0.293)*x810*x813))+(((-0.00589)*cj4))+(((0.0525)*x811*x813))+(((0.293)*x814))+(((-0.0525)*x816))+(((-0.0525)*x811*x812))));
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  )
{
{
IkReal j5eval[2];
IkReal x818=cj6*cj6;
IkReal x819=npy*npy;
IkReal x820=npz*npz;
IkReal x821=npx*npx;
IkReal x822=(npy*sj6);
IkReal x823=(cj6*npx);
IkReal x824=((173.130193905817)*x819);
IkReal x825=(x818*x821);
j5eval[0]=((-1.0)+(((346.260387811634)*x822*x823))+(((-1.0)*x824))+(((-173.130193905817)*x825))+(((-173.130193905817)*x820))+(((26.3157894736842)*x823))+((x818*x824))+(((-26.3157894736842)*x822)));
j5eval[1]=IKsign(((-0.005776)+(((0.152)*x823))+(((-0.152)*x822))+(((-1.0)*x819))+(((-1.0)*x825))+(((-1.0)*x820))+((x818*x819))+(((2.0)*x822*x823))));
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j5]

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x826=cj6*cj6;
IkReal x827=npy*npy;
IkReal x828=(cj4*sj3);
IkReal x829=(cj3*cj4);
IkReal x830=(npy*sj6);
IkReal x831=(cj6*npx);
IkReal x832=((0.293)*cj3);
IkReal x833=((0.0775)*cj4);
IkReal x834=((0.0525)*npz);
IkReal x835=((0.0525)*sj3);
CheckValue<IkReal> x836 = IKatan2WithCheck(IkReal(((0.02603)+(((0.3425)*x830))+((x831*x832))+(((-0.3425)*x831))+(((0.293)*npz*x828))+((npz*x833))+(((-1.0)*x830*x832))+((x829*x834))+((x830*x835))+(((0.00399)*sj3))+(((-0.022268)*cj3))+(((-1.0)*x831*x835)))),IkReal(((((0.0525)*x829*x830))+(((0.293)*x828*x830))+(((0.00399)*x829))+((npz*x832))+(((-0.3425)*npz))+((x830*x833))+(((-0.293)*x828*x831))+(((-0.0525)*x829*x831))+(((0.00589)*cj4))+(((0.022268)*x828))+(((-1.0)*sj3*x834))+(((-1.0)*x831*x833)))),IKFAST_ATAN2_MAGTHRESH);
if(!x836.valid){
continue;
}
CheckValue<IkReal> x837=IKPowWithIntegerCheck(IKsign(((-0.005776)+(((-0.152)*x830))+(((-1.0)*(npz*npz)))+(((-1.0)*x826*(npx*npx)))+(((0.152)*x831))+(((-1.0)*x827))+(((2.0)*x830*x831))+((x826*x827)))),-1);
if(!x837.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(x836.value)+(((1.5707963267949)*(x837.value))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[5];
IkReal x838=IKsin(j5);
IkReal x839=IKcos(j5);
IkReal x840=(npy*sj6);
IkReal x841=((0.293)*sj3);
IkReal x842=((0.293)*cj3);
IkReal x843=((0.0525)*cj4);
IkReal x844=((0.0775)*cj4);
IkReal x845=((1.0)*npz);
IkReal x846=((0.0525)*sj3);
IkReal x847=(cj3*x838);
IkReal x848=(cj4*x839);
IkReal x849=(sj3*x838);
IkReal x850=((1.0)*cj6*npx);
evalcond[0]=((0.3425)+((x838*x840))+(((-1.0)*x838*x850))+(((-1.0)*x842))+(((0.076)*x838))+(((-1.0)*x839*x845))+x846);
evalcond[1]=((((-1.0)*x839*x850))+((x839*x840))+((npz*x838))+((cj4*x841))+(((0.076)*x839))+((cj3*x843))+x844);
evalcond[2]=((((0.3425)*x839))+((x839*x846))+(((-1.0)*x843*x847))+(((-1.0)*x845))+(((-1.0)*cj4*x838*x841))+(((-1.0)*x839*x842))+(((-1.0)*x838*x844)));
evalcond[3]=((0.076)+((cj3*x839*x843))+(((0.3425)*x838))+((x838*x846))+(((-1.0)*x850))+((x839*x844))+(((-1.0)*x838*x842))+x840+((x841*x848)));
evalcond[4]=((-0.21769375)+(((-0.05206)*x838))+(((-0.00798)*x849))+(((0.1925675)*cj3))+(((-0.044536)*sj3*x848))+pp+(((0.044536)*x847))+(((-0.00798)*cj3*x848))+(((-0.0813775)*sj3))+(((-0.01178)*x848)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x851=cj4*cj4;
IkReal x852=cj3*cj3;
IkReal x853=(npy*sj6);
IkReal x854=(cj4*sj3);
IkReal x855=(cj3*cj4);
IkReal x856=(cj6*npx);
IkReal x857=((0.0775)*cj4);
IkReal x858=(sj3*x851);
CheckValue<IkReal> x859=IKPowWithIntegerCheck(IKsign(((((0.293)*x854*x856))+(((-1.0)*x853*x857))+(((-0.00399)*x855))+(((0.293)*cj3*npz))+(((-0.3425)*npz))+(((0.0525)*x855*x856))+((x856*x857))+(((-0.293)*x853*x854))+(((-0.00589)*cj4))+(((-0.0525)*x853*x855))+(((-0.022268)*x854))+(((-0.0525)*npz*sj3)))),-1);
if(!x859.valid){
continue;
}
CheckValue<IkReal> x860 = IKatan2WithCheck(IkReal(((((0.10442125)*x854))+(((-0.08309275)*cj3*x854))+(((-1.0)*npz*x856))+(((-0.00472625)*x855))+(((0.04192625)*cj4))+(((0.076)*npz))+(((-0.030765)*cj4*x852))+((npz*x853)))),IkReal(((((0.0081375)*cj3*x851))+(((0.09185525)*x851))+(((-1.0)*(npz*npz)))+(((-0.08309275)*x851*x852))+(((0.045415)*x858))+(((0.030765)*cj3*x858)))),IKFAST_ATAN2_MAGTHRESH);
if(!x860.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(((1.5707963267949)*(x859.value)))+(x860.value));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[5];
IkReal x861=IKsin(j5);
IkReal x862=IKcos(j5);
IkReal x863=(npy*sj6);
IkReal x864=((0.293)*sj3);
IkReal x865=((0.293)*cj3);
IkReal x866=((0.0525)*cj4);
IkReal x867=((0.0775)*cj4);
IkReal x868=((1.0)*npz);
IkReal x869=((0.0525)*sj3);
IkReal x870=(cj3*x861);
IkReal x871=(cj4*x862);
IkReal x872=(sj3*x861);
IkReal x873=((1.0)*cj6*npx);
evalcond[0]=((0.3425)+(((0.076)*x861))+(((-1.0)*x865))+(((-1.0)*x862*x868))+(((-1.0)*x861*x873))+((x861*x863))+x869);
evalcond[1]=((((0.076)*x862))+((cj3*x866))+(((-1.0)*x862*x873))+((x862*x863))+((cj4*x864))+((npz*x861))+x867);
evalcond[2]=((((-1.0)*x868))+(((-1.0)*x866*x870))+(((-1.0)*x862*x865))+(((-1.0)*x861*x867))+(((0.3425)*x862))+(((-1.0)*cj4*x861*x864))+((x862*x869)));
evalcond[3]=((0.076)+((cj3*x862*x866))+(((-1.0)*x861*x865))+(((0.3425)*x861))+((x862*x867))+((x861*x869))+((x864*x871))+x863+(((-1.0)*x873)));
evalcond[4]=((-0.21769375)+(((-0.01178)*x871))+(((0.044536)*x870))+(((-0.044536)*sj3*x871))+(((-0.00798)*cj3*x871))+(((0.1925675)*cj3))+pp+(((-0.00798)*x872))+(((-0.0813775)*sj3))+(((-0.05206)*x861)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x874=cj3*cj3;
IkReal x875=(npy*sj6);
IkReal x876=(cj3*sj3);
IkReal x877=(cj6*npx);
IkReal x878=(cj4*sj3);
IkReal x879=((0.293)*cj3);
IkReal x880=(cj4*npz);
IkReal x881=((0.0525)*sj3);
CheckValue<IkReal> x882 = IKatan2WithCheck(IkReal(((-0.1200625)+(((0.200705)*cj3))+(((-0.0359625)*sj3))+(((0.030765)*x876))+(npz*npz)+(((-0.08309275)*x874)))),IkReal(((((-0.04192625)*cj4))+(((0.030765)*cj4*x874))+(((-0.10442125)*x878))+(((0.00472625)*cj3*cj4))+(((0.08309275)*cj4*x876))+(((-1.0)*npz*x877))+((npz*x875))+(((0.076)*npz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x882.valid){
continue;
}
CheckValue<IkReal> x883=IKPowWithIntegerCheck(IKsign(((0.02603)+(((-0.0775)*x880))+(((-0.0525)*cj3*x880))+(((0.3425)*x875))+(((-1.0)*x877*x881))+(((0.00399)*sj3))+(((-0.3425)*x877))+(((-1.0)*x875*x879))+((x875*x881))+(((-0.293)*npz*x878))+(((-0.022268)*cj3))+((x877*x879)))),-1);
if(!x883.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(x882.value)+(((1.5707963267949)*(x883.value))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[5];
IkReal x884=IKsin(j5);
IkReal x885=IKcos(j5);
IkReal x886=(npy*sj6);
IkReal x887=((0.293)*sj3);
IkReal x888=((0.293)*cj3);
IkReal x889=((0.0525)*cj4);
IkReal x890=((0.0775)*cj4);
IkReal x891=((1.0)*npz);
IkReal x892=((0.0525)*sj3);
IkReal x893=(cj3*x884);
IkReal x894=(cj4*x885);
IkReal x895=(sj3*x884);
IkReal x896=((1.0)*cj6*npx);
evalcond[0]=((0.3425)+(((-1.0)*x884*x896))+(((-1.0)*x888))+(((0.076)*x884))+(((-1.0)*x885*x891))+x892+((x884*x886)));
evalcond[1]=(((cj3*x889))+(((0.076)*x885))+((npz*x884))+((cj4*x887))+(((-1.0)*x885*x896))+x890+((x885*x886)));
evalcond[2]=((((-1.0)*x884*x890))+(((-1.0)*cj4*x884*x887))+(((0.3425)*x885))+(((-1.0)*x891))+(((-1.0)*x889*x893))+((x885*x892))+(((-1.0)*x885*x888)));
evalcond[3]=((0.076)+((x884*x892))+(((0.3425)*x884))+(((-1.0)*x896))+((cj3*x885*x889))+x886+((x885*x890))+(((-1.0)*x884*x888))+((x887*x894)));
evalcond[4]=((-0.21769375)+(((-0.044536)*sj3*x894))+(((-0.00798)*x895))+(((0.1925675)*cj3))+(((-0.01178)*x894))+pp+(((-0.0813775)*sj3))+(((0.044536)*x893))+(((-0.00798)*cj3*x894))+(((-0.05206)*x884)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

} else
{
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
IkReal x897=((0.076)+(((-1.0)*cj6*npx))+((npy*sj6)));
CheckValue<IkReal> x900 = IKatan2WithCheck(IkReal(((-1.0)*npz)),IkReal(x897),IKFAST_ATAN2_MAGTHRESH);
if(!x900.valid){
continue;
}
IkReal x898=((1.0)*(x900.value));
if((((x897*x897)+(npz*npz))) < -0.00001)
continue;
CheckValue<IkReal> x901=IKPowWithIntegerCheck(IKabs(IKsqrt(((x897*x897)+(npz*npz)))),-1);
if(!x901.valid){
continue;
}
if( (((x901.value)*(((0.3425)+(((-0.293)*cj3))+(((0.0525)*sj3)))))) < -1-IKFAST_SINCOS_THRESH || (((x901.value)*(((0.3425)+(((-0.293)*cj3))+(((0.0525)*sj3)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x899=IKasin(((x901.value)*(((0.3425)+(((-0.293)*cj3))+(((0.0525)*sj3))))));
j5array[0]=((((-1.0)*x898))+(((-1.0)*x899)));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1]=((3.14159265358979)+(((-1.0)*x898))+x899);
sj5array[1]=IKsin(j5array[1]);
cj5array[1]=IKcos(j5array[1]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
if( j5array[1] > IKPI )
{
    j5array[1]-=IK2PI;
}
else if( j5array[1] < -IKPI )
{    j5array[1]+=IK2PI;
}
j5valid[1] = true;
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
IkReal j4eval[3];
j4eval[0]=((-1.47619047619048)+(((-5.58095238095238)*sj3))+(((-1.0)*cj3)));
j4eval[1]=((IKabs((((cj6*npy))+((npx*sj6)))))+(IKabs((((npz*sj5))+(((0.076)*cj5))+((cj5*npy*sj6))+(((-1.0)*cj5*cj6*npx))))));
j4eval[2]=IKsign(((-0.0775)+(((-0.0525)*cj3))+(((-0.293)*sj3))));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
IkReal x902=((1.0)*cj3);
IkReal x903=((5.58095238095238)*sj3);
j4eval[0]=((-1.47619047619048)+(((-1.0)*x903))+(((-1.0)*x902)));
j4eval[1]=((((-1.47619047619048)*sj5))+(((-1.0)*sj5*x903))+(((-1.0)*sj5*x902)));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
IkReal x904=((5.58095238095238)*sj3);
j4eval[0]=((-1.47619047619048)+(((-1.0)*x904))+(((-1.0)*cj3)));
j4eval[1]=(((cj3*cj5))+((cj5*x904))+(((1.47619047619048)*cj5)));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.2276868576215)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x905=((819672131.147541)*sj6);
IkReal x906=((819672131.147541)*cj6);
if( IKabs((((npx*x905))+((npy*x906)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj5*npy*x905))+(((-1.0)*cj5*npx*x906))+(((62295081.9672131)*cj5))+(((819672131.147541)*npz*sj5)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((npx*x905))+((npy*x906))))+IKsqr((((cj5*npy*x905))+(((-1.0)*cj5*npx*x906))+(((62295081.9672131)*cj5))+(((819672131.147541)*npz*sj5))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((((npx*x905))+((npy*x906))), (((cj5*npy*x905))+(((-1.0)*cj5*npx*x906))+(((62295081.9672131)*cj5))+(((819672131.147541)*npz*sj5))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[5];
IkReal x907=IKcos(j4);
IkReal x908=((1.0)*cj6);
IkReal x909=(npy*sj6);
IkReal x910=((1.22e-9)*x907);
evalcond[0]=((-0.402550535123675)+(((1.8544e-10)*cj5*x907))+pp+(((-0.09574486331028)*sj5)));
evalcond[1]=(((sj5*x910))+(((-1.0)*npz))+(((0.629900416515)*cj5)));
evalcond[2]=((((-1.0)*npx*sj6))+(((1.22e-9)*(IKsin(j4))))+(((-1.0)*npy*x908)));
evalcond[3]=((0.076)+(((0.629900416515)*sj5))+(((-1.0)*cj5*x910))+(((-1.0)*npx*x908))+x909);
evalcond[4]=(((npz*sj5))+(((-1.0)*x910))+((cj5*x909))+(((-1.0)*cj5*npx*x908))+(((0.076)*cj5)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-5.8424922655324)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x911=((51305507480.2948)*cj5);
if( IKabs(((((-51305507480.2948)*npx*sj6))+(((-51305507480.2948)*cj6*npy)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-51305507480.2948)*npz*sj5))+((cj6*npx*x911))+(((-3899218568.5024)*cj5))+(((-1.0)*npy*sj6*x911)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-51305507480.2948)*npx*sj6))+(((-51305507480.2948)*cj6*npy))))+IKsqr(((((-51305507480.2948)*npz*sj5))+((cj6*npx*x911))+(((-3899218568.5024)*cj5))+(((-1.0)*npy*sj6*x911))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((-51305507480.2948)*npx*sj6))+(((-51305507480.2948)*cj6*npy))), ((((-51305507480.2948)*npz*sj5))+((cj6*npx*x911))+(((-3899218568.5024)*cj5))+(((-1.0)*npy*sj6*x911))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[5];
IkReal x912=IKcos(j4);
IkReal x913=((1.0)*cj6);
IkReal x914=(npy*sj6);
IkReal x915=((1.94910848583668e-11)*x912);
evalcond[0]=((-0.00881196444384667)+(((-2.96264489847176e-12)*cj5*x912))+(((-0.0083751366350445)*sj5))+pp);
evalcond[1]=((((-1.0)*sj5*x915))+(((-1.0)*npz))+(((0.0550995831252928)*cj5)));
evalcond[2]=((((-1.94910848583668e-11)*(IKsin(j4))))+(((-1.0)*npx*sj6))+(((-1.0)*npy*x913)));
evalcond[3]=((0.076)+(((0.0550995831252928)*sj5))+(((-1.0)*npx*x913))+((cj5*x915))+x914);
evalcond[4]=(((npz*sj5))+(((-1.0)*cj5*npx*x913))+(((0.076)*cj5))+((cj5*x914))+x915);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[2];
sj5=1.0;
cj5=0;
j5=1.5707963267949;
j4eval[0]=((-1.47619047619048)+(((-5.58095238095238)*sj3))+(((-1.0)*cj3)));
j4eval[1]=((1.0)+(((2.27928949646302)*sj3))+(((-1.61351824021864)*pp)));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.2276868576215)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((((819672131.147541)*npx*sj6))+(((819672131.147541)*cj6*npy)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((819672131.147541)*npz)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((819672131.147541)*npx*sj6))+(((819672131.147541)*cj6*npy))))+IKsqr(((819672131.147541)*npz))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((819672131.147541)*npx*sj6))+(((819672131.147541)*cj6*npy))), ((819672131.147541)*npz));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
evalcond[0]=(npz+(((-1.22e-9)*(IKcos(j4)))));
evalcond[1]=((((-1.0)*cj6*npy))+(((-1.0)*npx*sj6))+(((1.22e-9)*(IKsin(j4)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-5.8424922655324)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((((-51305507480.2948)*npx*sj6))+(((-51305507480.2948)*cj6*npy)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-51305507480.2948)*npz)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-51305507480.2948)*npx*sj6))+(((-51305507480.2948)*cj6*npy))))+IKsqr(((-51305507480.2948)*npz))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((-51305507480.2948)*npx*sj6))+(((-51305507480.2948)*cj6*npy))), ((-51305507480.2948)*npz));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
evalcond[0]=((((1.94910848583668e-11)*(IKcos(j4))))+npz);
evalcond[1]=((((-1.94910848583668e-11)*(IKsin(j4))))+(((-1.0)*cj6*npy))+(((-1.0)*npx*sj6)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst0=((-0.43873321118348)+(((0.70790403883424)*pp)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((0.43873321118348)+sj3+(((-0.70790403883424)*pp)))))+(IKabs(((-1.0)+(IKsign(cj3)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[2];
IkReal x916=((-0.438733210502659)+(((0.707904040266035)*pp)));
sj5=1.0;
cj5=0;
j5=1.5707963267949;
sj3=x916;
if((((0.807513169404632)+(((0.621162024335002)*pp))+(((-0.501128128197829)*(pp*pp))))) < -0.00001)
continue;
cj3=IKsqrt(((0.807513169404632)+(((0.621162024335002)*pp))+(((-0.501128128197829)*(pp*pp)))));
if( (x916) < -1-IKFAST_SINCOS_THRESH || (x916) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=((1.0)*(IKasin(x916)));
IkReal gconst0=((-0.43873321118348)+(((0.70790403883424)*pp)));
if((((0.807513169404632)+(((0.621162024335002)*pp))+(((-0.501128128197829)*(pp*pp))))) < -0.00001)
continue;
j4eval[0]=((1.0)+(((-1.02842708252996)*(IKsqrt(((0.807513169404632)+(((0.621162024335002)*pp))+(((-0.501128128197829)*(pp*pp))))))))+(((-4.06308785227994)*pp)));
j4eval[1]=((1.0)+(((2.10304031018803)*pp)));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j4]

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if((((0.807513169404632)+(((0.621162024335002)*pp))+(((-0.501128128197829)*(pp*pp))))) < -0.00001)
continue;
CheckValue<IkReal> x917=IKPowWithIntegerCheck(((0.051048830677279)+(((-0.0525)*(IKsqrt(((0.807513169404632)+(((0.621162024335002)*pp))+(((-0.501128128197829)*(pp*pp))))))))+(((-0.207415883797948)*pp))),-1);
if(!x917.valid){
continue;
}
CheckValue<IkReal> x918=IKPowWithIntegerCheck(((2.1295119821753e-10)+(((4.47844953954308e-10)*pp))),-1);
if(!x918.valid){
continue;
}
if( IKabs(((x917.value)*((((cj6*npy))+((npx*sj6)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*npz*(x918.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x917.value)*((((cj6*npy))+((npx*sj6))))))+IKsqr(((-1.0)*npz*(x918.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x917.value)*((((cj6*npy))+((npx*sj6))))), ((-1.0)*npz*(x918.value)));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
IkReal x919=IKcos(j4);
IkReal x920=IKsin(j4);
evalcond[0]=(npz+(((4.47844953954308e-10)*pp*x919))+(((2.1295119821753e-10)*x919)));
if((((0.807513169404632)+(((0.621162024335002)*pp))+(((-0.501128128197829)*(pp*pp))))) < -0.00001)
continue;
evalcond[1]=((((0.051048830677279)*x920))+(((-1.0)*cj6*npy))+(((-1.0)*npx*sj6))+(((-0.0525)*x920*(IKsqrt(((0.807513169404632)+(((0.621162024335002)*pp))+(((-0.501128128197829)*(pp*pp))))))))+(((-0.207415883797948)*pp*x920)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst0=((-0.43873321118348)+(((0.70790403883424)*pp)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((0.43873321118348)+sj3+(((-0.70790403883424)*pp)))))+(IKabs(((1.0)+(IKsign(cj3)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[2];
IkReal x921=((-0.438733210502659)+(((0.707904040266035)*pp)));
sj5=1.0;
cj5=0;
j5=1.5707963267949;
sj3=x921;
if((((0.807513169404632)+(((0.621162024335002)*pp))+(((-0.501128128197829)*(pp*pp))))) < -0.00001)
continue;
cj3=((-1.0)*(IKsqrt(((0.807513169404632)+(((0.621162024335002)*pp))+(((-0.501128128197829)*(pp*pp)))))));
if( (x921) < -1-IKFAST_SINCOS_THRESH || (x921) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=((3.14159265)+(((-1.0)*(IKasin(x921)))));
IkReal gconst0=((-0.43873321118348)+(((0.70790403883424)*pp)));
if((((0.807513169404632)+(((0.621162024335002)*pp))+(((-0.501128128197829)*(pp*pp))))) < -0.00001)
continue;
j4eval[0]=((1.0)+(((1.02842708252996)*(IKsqrt(((0.807513169404632)+(((0.621162024335002)*pp))+(((-0.501128128197829)*(pp*pp))))))))+(((-4.06308785227994)*pp)));
j4eval[1]=((1.0)+(((2.10304031018803)*pp)));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j4]

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if((((0.807513169404632)+(((0.621162024335002)*pp))+(((-0.501128128197829)*(pp*pp))))) < -0.00001)
continue;
CheckValue<IkReal> x922=IKPowWithIntegerCheck(((0.051048830677279)+(((-0.207415883797948)*pp))+(((0.0525)*(IKsqrt(((0.807513169404632)+(((0.621162024335002)*pp))+(((-0.501128128197829)*(pp*pp))))))))),-1);
if(!x922.valid){
continue;
}
CheckValue<IkReal> x923=IKPowWithIntegerCheck(((2.1295119821753e-10)+(((4.47844953954308e-10)*pp))),-1);
if(!x923.valid){
continue;
}
if( IKabs(((x922.value)*((((cj6*npy))+((npx*sj6)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*npz*(x923.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x922.value)*((((cj6*npy))+((npx*sj6))))))+IKsqr(((-1.0)*npz*(x923.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x922.value)*((((cj6*npy))+((npx*sj6))))), ((-1.0)*npz*(x923.value)));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
IkReal x924=IKcos(j4);
IkReal x925=IKsin(j4);
evalcond[0]=(npz+(((2.1295119821753e-10)*x924))+(((4.47844953954308e-10)*pp*x924)));
if((((0.807513169404632)+(((0.621162024335002)*pp))+(((-0.501128128197829)*(pp*pp))))) < -0.00001)
continue;
evalcond[1]=((((0.0525)*x925*(IKsqrt(((0.807513169404632)+(((0.621162024335002)*pp))+(((-0.501128128197829)*(pp*pp))))))))+(((0.051048830677279)*x925))+(((-1.0)*cj6*npy))+(((-1.0)*npx*sj6))+(((-0.207415883797948)*pp*x925)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x926=IKPowWithIntegerCheck(((-0.0775)+(((-0.0525)*cj3))+(((-0.293)*sj3))),-1);
if(!x926.valid){
continue;
}
CheckValue<IkReal> x927=IKPowWithIntegerCheck(((0.137229493132746)+(((0.312785742302412)*sj3))+(((-0.221422290265643)*pp))),-1);
if(!x927.valid){
continue;
}
if( IKabs(((x926.value)*((((cj6*npy))+((npx*sj6)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*npz*(x927.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x926.value)*((((cj6*npy))+((npx*sj6))))))+IKsqr(((-1.0)*npz*(x927.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x926.value)*((((cj6*npy))+((npx*sj6))))), ((-1.0)*npz*(x927.value)));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
IkReal x928=IKcos(j4);
IkReal x929=IKsin(j4);
evalcond[0]=((((0.137229493132746)*x928))+(((0.312785742302412)*sj3*x928))+npz+(((-0.221422290265643)*pp*x928)));
evalcond[1]=((((-0.0525)*cj3*x929))+(((-1.0)*cj6*npy))+(((-1.0)*npx*sj6))+(((-0.0775)*x929))+(((-0.293)*sj3*x929)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[2];
sj5=-1.0;
cj5=0;
j5=-1.5707963267949;
j4eval[0]=((-1.47619047619048)+(((-5.58095238095238)*sj3))+(((-1.0)*cj3)));
j4eval[1]=((1.0)+(((-2.6031061688317)*pp))+(((2.34163522357165)*sj3)));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.2276868576215)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((((819672131.147541)*npx*sj6))+(((819672131.147541)*cj6*npy)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-819672131.147541)*npz)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((819672131.147541)*npx*sj6))+(((819672131.147541)*cj6*npy))))+IKsqr(((-819672131.147541)*npz))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((819672131.147541)*npx*sj6))+(((819672131.147541)*cj6*npy))), ((-819672131.147541)*npz));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
evalcond[0]=((((-1.0)*npz))+(((-1.22e-9)*(IKcos(j4)))));
evalcond[1]=((((-1.0)*cj6*npy))+(((-1.0)*npx*sj6))+(((1.22e-9)*(IKsin(j4)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-5.8424922655324)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((((-51305507480.2948)*npx*sj6))+(((-51305507480.2948)*cj6*npy)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((51305507480.2948)*npz)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-51305507480.2948)*npx*sj6))+(((-51305507480.2948)*cj6*npy))))+IKsqr(((51305507480.2948)*npz))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((-51305507480.2948)*npx*sj6))+(((-51305507480.2948)*cj6*npy))), ((51305507480.2948)*npz));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
evalcond[0]=((((1.94910848583668e-11)*(IKcos(j4))))+(((-1.0)*npz)));
evalcond[1]=((((-1.94910848583668e-11)*(IKsin(j4))))+(((-1.0)*cj6*npy))+(((-1.0)*npx*sj6)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst1=((-0.427051997652615)+(((1.11166168950142)*pp)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((0.427051997652615)+(((-1.11166168950142)*pp))+sj3)))+(IKabs(((-1.0)+(IKsign(cj3)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[2];
IkReal x930=((1.11166169244379)*pp);
sj5=-1.0;
cj5=0;
j5=-1.5707963267949;
sj3=((-0.427052)+x930);
if((((0.817626591300911)+(((0.949474690430929)*pp))+(((-1.23579171190516)*(pp*pp))))) < -0.00001)
continue;
cj3=IKsqrt(((0.817626591300911)+(((0.949474690430929)*pp))+(((-1.23579171190516)*(pp*pp)))));
if( (((-0.427052)+x930)) < -1-IKFAST_SINCOS_THRESH || (((-0.427052)+x930)) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=((1.0)*(IKasin(((-0.427052)+x930))));
IkReal gconst1=((-0.427051997652615)+(((1.11166168950142)*pp)));
if((((0.817626591300911)+(((0.949474690430929)*pp))+(((-1.23579171190516)*(pp*pp))))) < -0.00001)
continue;
j4eval[0]=((1.0)+(((-1.10233359612966)*(IKsqrt(((0.817626591300911)+(((0.949474690430929)*pp))+(((-1.23579171190516)*(pp*pp))))))))+(((-6.83902200220125)*pp)));
j4eval[1]=((-1.0)+(((1.2534635127096)*pp)));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j4]

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if((((0.817626591300911)+(((0.949474690430929)*pp))+(((-1.23579171190516)*(pp*pp))))) < -0.00001)
continue;
CheckValue<IkReal> x931=IKPowWithIntegerCheck(((0.047626236)+(((-0.325716875886029)*pp))+(((-0.0525)*(IKsqrt(((0.817626591300911)+(((0.949474690430929)*pp))+(((-1.23579171190516)*(pp*pp))))))))),-1);
if(!x931.valid){
continue;
}
CheckValue<IkReal> x932=IKPowWithIntegerCheck(((-7.48887905614683e-10)+(((9.38703664797514e-10)*pp))),-1);
if(!x932.valid){
continue;
}
if( IKabs(((x931.value)*((((cj6*npy))+((npx*sj6)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((npz*(x932.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x931.value)*((((cj6*npy))+((npx*sj6))))))+IKsqr((npz*(x932.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x931.value)*((((cj6*npy))+((npx*sj6))))), (npz*(x932.value)));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
IkReal x933=IKcos(j4);
IkReal x934=IKsin(j4);
evalcond[0]=((((-1.0)*npz))+(((9.38703664797514e-10)*pp*x933))+(((-7.48887905614683e-10)*x933)));
if((((0.817626591300911)+(((0.949474690430929)*pp))+(((-1.23579171190516)*(pp*pp))))) < -0.00001)
continue;
evalcond[1]=((((-1.0)*cj6*npy))+(((-1.0)*npx*sj6))+(((-0.0525)*x934*(IKsqrt(((0.817626591300911)+(((0.949474690430929)*pp))+(((-1.23579171190516)*(pp*pp))))))))+(((0.047626236)*x934))+(((-0.325716875886029)*pp*x934)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst1=((-0.427051997652615)+(((1.11166168950142)*pp)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((0.427051997652615)+(((-1.11166168950142)*pp))+sj3)))+(IKabs(((1.0)+(IKsign(cj3)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[2];
IkReal x935=((1.11166169244379)*pp);
sj5=-1.0;
cj5=0;
j5=-1.5707963267949;
sj3=((-0.427052)+x935);
if((((0.817626591300911)+(((0.949474690430929)*pp))+(((-1.23579171190516)*(pp*pp))))) < -0.00001)
continue;
cj3=((-1.0)*(IKsqrt(((0.817626591300911)+(((0.949474690430929)*pp))+(((-1.23579171190516)*(pp*pp)))))));
if( (((0.427052)+(((-1.0)*x935)))) < -1-IKFAST_SINCOS_THRESH || (((0.427052)+(((-1.0)*x935)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=((3.14159265)+(IKasin(((0.427052)+(((-1.0)*x935))))));
IkReal gconst1=((-0.427051997652615)+(((1.11166168950142)*pp)));
if((((0.817626591300911)+(((0.949474690430929)*pp))+(((-1.23579171190516)*(pp*pp))))) < -0.00001)
continue;
j4eval[0]=((1.0)+(((1.10233359612966)*(IKsqrt(((0.817626591300911)+(((0.949474690430929)*pp))+(((-1.23579171190516)*(pp*pp))))))))+(((-6.83902200220125)*pp)));
j4eval[1]=((-1.0)+(((1.2534635127096)*pp)));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j4]

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if((((0.817626591300911)+(((0.949474690430929)*pp))+(((-1.23579171190516)*(pp*pp))))) < -0.00001)
continue;
CheckValue<IkReal> x936=IKPowWithIntegerCheck(((0.047626236)+(((-0.325716875886029)*pp))+(((0.0525)*(IKsqrt(((0.817626591300911)+(((0.949474690430929)*pp))+(((-1.23579171190516)*(pp*pp))))))))),-1);
if(!x936.valid){
continue;
}
CheckValue<IkReal> x937=IKPowWithIntegerCheck(((-7.48887905614683e-10)+(((9.38703664797514e-10)*pp))),-1);
if(!x937.valid){
continue;
}
if( IKabs(((x936.value)*((((cj6*npy))+((npx*sj6)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((npz*(x937.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x936.value)*((((cj6*npy))+((npx*sj6))))))+IKsqr((npz*(x937.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x936.value)*((((cj6*npy))+((npx*sj6))))), (npz*(x937.value)));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
IkReal x938=IKcos(j4);
IkReal x939=IKsin(j4);
evalcond[0]=((((-1.0)*npz))+(((9.38703664797514e-10)*pp*x938))+(((-7.48887905614683e-10)*x938)));
if((((0.817626591300911)+(((0.949474690430929)*pp))+(((-1.23579171190516)*(pp*pp))))) < -0.00001)
continue;
evalcond[1]=((((-1.0)*cj6*npy))+(((-1.0)*npx*sj6))+(((0.047626236)*x939))+(((-0.325716875886029)*pp*x939))+(((0.0525)*x939*(IKsqrt(((0.817626591300911)+(((0.949474690430929)*pp))+(((-1.23579171190516)*(pp*pp)))))))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x940=IKPowWithIntegerCheck(((-0.0775)+(((-0.0525)*cj3))+(((-0.293)*sj3))),-1);
if(!x940.valid){
continue;
}
CheckValue<IkReal> x941=IKPowWithIntegerCheck(((0.136242712699662)+(((-0.354654245886855)*pp))+(((0.31903073501248)*sj3))),-1);
if(!x941.valid){
continue;
}
if( IKabs(((x940.value)*((((cj6*npy))+((npx*sj6)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((npz*(x941.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x940.value)*((((cj6*npy))+((npx*sj6))))))+IKsqr((npz*(x941.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x940.value)*((((cj6*npy))+((npx*sj6))))), (npz*(x941.value)));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
IkReal x942=IKcos(j4);
IkReal x943=IKsin(j4);
evalcond[0]=((((0.31903073501248)*sj3*x942))+(((-1.0)*npz))+(((0.136242712699662)*x942))+(((-0.354654245886855)*pp*x942)));
evalcond[1]=((((-0.0525)*cj3*x943))+(((-1.0)*cj6*npy))+(((-1.0)*npx*sj6))+(((-0.293)*sj3*x943))+(((-0.0775)*x943)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[2];
sj5=0;
cj5=1.0;
j5=0;
j4eval[0]=((-1.47619047619048)+(((-5.58095238095238)*sj3))+(((-1.0)*cj3)));
j4eval[1]=((-1.0)+(((1.29028294061626)*npz))+(((-2.17763509569598)*sj3)));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.2276868576215)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((((819672131.147541)*npx*sj6))+(((819672131.147541)*cj6*npy)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((2170785888.28556)+(((-5392579810.18119)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((819672131.147541)*npx*sj6))+(((819672131.147541)*cj6*npy))))+IKsqr(((2170785888.28556)+(((-5392579810.18119)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((819672131.147541)*npx*sj6))+(((819672131.147541)*cj6*npy))), ((2170785888.28556)+(((-5392579810.18119)*pp))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[3];
IkReal x944=IKcos(j4);
evalcond[0]=((-0.402550535123675)+pp+(((1.8544e-10)*x944)));
evalcond[1]=((2.64835878370839)+(((-6.57894736842105)*pp))+(((-1.22e-9)*x944)));
evalcond[2]=((((-1.0)*cj6*npy))+(((-1.0)*npx*sj6))+(((1.22e-9)*(IKsin(j4)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-5.8424922655324)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((((-51305507480.2948)*npx*sj6))+(((-51305507480.2948)*cj6*npy)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-2974357287.43333)+(((337536233422.992)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-51305507480.2948)*npx*sj6))+(((-51305507480.2948)*cj6*npy))))+IKsqr(((-2974357287.43333)+(((337536233422.992)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((-51305507480.2948)*npx*sj6))+(((-51305507480.2948)*cj6*npy))), ((-2974357287.43333)+(((337536233422.992)*pp))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[3];
IkReal x945=IKcos(j4);
evalcond[0]=((-0.00881196444384667)+(((-2.96264489847176e-12)*x945))+pp);
evalcond[1]=((0.0579734502884649)+(((-6.57894736842105)*pp))+(((1.94910848583668e-11)*x945)));
evalcond[2]=((((-1.94910848583668e-11)*(IKsin(j4))))+(((-1.0)*cj6*npy))+(((-1.0)*npx*sj6)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst2=((-0.459213759907003)+(((0.592515680504259)*npz)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((0.459213759907003)+sj3+(((-0.592515680504259)*npz)))))+(IKabs(((-1.0)+(IKsign(cj3)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[2];
IkReal x946=((0.59251568)*npz);
sj5=0;
cj5=1.0;
j5=0;
sj3=((-0.45921376)+x946);
if((((0.789122722712073)+(((0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz))))) < -0.00001)
continue;
cj3=IKsqrt(((0.789122722712073)+(((0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz)))));
if( (((-0.45921376)+x946)) < -1-IKFAST_SINCOS_THRESH || (((-0.45921376)+x946)) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=IKasin(((-0.45921376)+x946));
IkReal gconst2=((-0.459213759907003)+(((0.592515680504259)*npz)));
if((((0.789122722712073)+(((0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz))))) < -0.00001)
continue;
j4eval[0]=((1.08665965104762)+(((-3.30680179504762)*npz))+(((-1.0)*(IKsqrt(((0.789122722712073)+(((0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz)))))))));
j4eval[1]=((1.0)+(((5.42233009708738)*npz)));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j4]

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if((((0.789122722712073)+(((0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz))))) < -0.00001)
continue;
CheckValue<IkReal> x947=IKPowWithIntegerCheck(((0.05704963168)+(((-0.0525)*(IKsqrt(((0.789122722712073)+(((0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz))))))))+(((-0.17360709424)*npz))),-1);
if(!x947.valid){
continue;
}
CheckValue<IkReal> x948=IKPowWithIntegerCheck(((4.27467576791809e-12)+(((2.31787030716724e-11)*npz))),-1);
if(!x948.valid){
continue;
}
if( IKabs(((x947.value)*((((cj6*npy))+((npx*sj6)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x948.value)*(((-0.028931250004359)+(((0.684999999976364)*npz))+(((-1.0)*pp)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x947.value)*((((cj6*npy))+((npx*sj6))))))+IKsqr(((x948.value)*(((-0.028931250004359)+(((0.684999999976364)*npz))+(((-1.0)*pp))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x947.value)*((((cj6*npy))+((npx*sj6))))), ((x948.value)*(((-0.028931250004359)+(((0.684999999976364)*npz))+(((-1.0)*pp))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[3];
IkReal x949=IKcos(j4);
IkReal x950=IKsin(j4);
IkReal x951=(npz*x949);
evalcond[0]=((0.028931250004359)+(((4.27467576791809e-12)*x949))+pp+(((2.31787030716724e-11)*x951))+(((-0.684999999976364)*npz)));
evalcond[1]=((-0.19033717108131)+(((-1.52491467576792e-10)*x951))+(((-6.57894736842105)*pp))+(((4.50657894721292)*npz))+(((-2.8122866894198e-11)*x949)));
if((((0.789122722712073)+(((0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz))))) < -0.00001)
continue;
evalcond[2]=((((-0.0525)*x950*(IKsqrt(((0.789122722712073)+(((0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz))))))))+(((-1.0)*cj6*npy))+(((0.05704963168)*x950))+(((-1.0)*npx*sj6))+(((-0.17360709424)*npz*x950)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst2=((-0.459213759907003)+(((0.592515680504259)*npz)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.0)+(IKsign(cj3)))))+(IKabs(((0.459213759907003)+sj3+(((-0.592515680504259)*npz)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[2];
IkReal x952=((0.59251568)*npz);
sj5=0;
cj5=1.0;
j5=0;
sj3=((-0.45921376)+x952);
if((((0.789122722712073)+(((0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz))))) < -0.00001)
continue;
cj3=((-1.0)*(IKsqrt(((0.789122722712073)+(((0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz)))))));
if( (((0.45921376)+(((-1.0)*x952)))) < -1-IKFAST_SINCOS_THRESH || (((0.45921376)+(((-1.0)*x952)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=((3.14159265)+(((1.0)*(IKasin(((0.45921376)+(((-1.0)*x952))))))));
IkReal gconst2=((-0.459213759907003)+(((0.592515680504259)*npz)));
if((((0.789122722712073)+(((0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz))))) < -0.00001)
continue;
j4eval[0]=((1.08665965104762)+(((-3.30680179504762)*npz))+(IKsqrt(((0.789122722712073)+(((0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz)))))));
j4eval[1]=((1.0)+(((5.42233009708738)*npz)));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j4]

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if((((0.789122722712073)+(((0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz))))) < -0.00001)
continue;
CheckValue<IkReal> x953=IKPowWithIntegerCheck(((0.05704963168)+(((-0.17360709424)*npz))+(((0.0525)*(IKsqrt(((0.789122722712073)+(((0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz))))))))),-1);
if(!x953.valid){
continue;
}
CheckValue<IkReal> x954=IKPowWithIntegerCheck(((4.27467576791809e-12)+(((2.31787030716724e-11)*npz))),-1);
if(!x954.valid){
continue;
}
if( IKabs(((x953.value)*((((cj6*npy))+((npx*sj6)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x954.value)*(((-0.028931250004359)+(((0.684999999976364)*npz))+(((-1.0)*pp)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x953.value)*((((cj6*npy))+((npx*sj6))))))+IKsqr(((x954.value)*(((-0.028931250004359)+(((0.684999999976364)*npz))+(((-1.0)*pp))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x953.value)*((((cj6*npy))+((npx*sj6))))), ((x954.value)*(((-0.028931250004359)+(((0.684999999976364)*npz))+(((-1.0)*pp))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[3];
IkReal x955=IKcos(j4);
IkReal x956=IKsin(j4);
IkReal x957=(npz*x955);
evalcond[0]=((0.028931250004359)+(((4.27467576791809e-12)*x955))+pp+(((2.31787030716724e-11)*x957))+(((-0.684999999976364)*npz)));
evalcond[1]=((-0.19033717108131)+(((-1.52491467576792e-10)*x957))+(((-6.57894736842105)*pp))+(((4.50657894721292)*npz))+(((-2.8122866894198e-11)*x955)));
if((((0.789122722712073)+(((0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz))))) < -0.00001)
continue;
evalcond[2]=((((-1.0)*cj6*npy))+(((0.05704963168)*x956))+(((0.0525)*x956*(IKsqrt(((0.789122722712073)+(((0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz))))))))+(((-1.0)*npx*sj6))+(((-0.17360709424)*npz*x956)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x958=IKPowWithIntegerCheck(((-0.0775)+(((-0.0525)*cj3))+(((-0.293)*sj3))),-1);
if(!x958.valid){
continue;
}
CheckValue<IkReal> x959=IKPowWithIntegerCheck(((-0.021108156996587)+(((-0.0459658634812287)*sj3))+(((0.0272354948805461)*npz))),-1);
if(!x959.valid){
continue;
}
if( IKabs(((x958.value)*((((cj6*npy))+((npx*sj6)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x959.value)*(((-0.00740648464163822)+(((0.657226962457338)*npz))+(((0.0468730844709898)*sj3))+(((-1.0)*pp)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x958.value)*((((cj6*npy))+((npx*sj6))))))+IKsqr(((x959.value)*(((-0.00740648464163822)+(((0.657226962457338)*npz))+(((0.0468730844709898)*sj3))+(((-1.0)*pp))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x958.value)*((((cj6*npy))+((npx*sj6))))), ((x959.value)*(((-0.00740648464163822)+(((0.657226962457338)*npz))+(((0.0468730844709898)*sj3))+(((-1.0)*pp))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[3];
IkReal x960=IKsin(j4);
IkReal x961=IKcos(j4);
IkReal x962=(npz*x961);
IkReal x963=(sj3*x961);
evalcond[0]=((((-0.293)*sj3*x960))+(((-1.0)*cj6*npy))+(((-0.0775)*x960))+(((-1.0)*npx*sj6))+(((-0.0525)*cj3*x960)));
evalcond[1]=((0.00740648464163822)+(((-0.0459658634812287)*x963))+(((-0.657226962457338)*npz))+(((-0.0468730844709898)*sj3))+pp+(((0.0272354948805461)*x962))+(((-0.021108156996587)*x961)));
evalcond[2]=((-0.0487268726423567)+(((-0.179180887372014)*x962))+(((-6.57894736842105)*pp))+(((0.302406996587031)*x963))+(((4.32386159511406)*npz))+(((0.138869453924915)*x961))+(((0.308375555730196)*sj3)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[2];
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
j4eval[0]=((-1.47619047619048)+(((-5.58095238095238)*sj3))+(((-1.0)*cj3)));
j4eval[1]=((1.0)+(((1.29028294061626)*npz))+(((2.17763509569598)*sj3)));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.2276868576215)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((((819672131.147541)*npx*sj6))+(((819672131.147541)*cj6*npy)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-2170785888.28556)+(((5392579810.18119)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((819672131.147541)*npx*sj6))+(((819672131.147541)*cj6*npy))))+IKsqr(((-2170785888.28556)+(((5392579810.18119)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((819672131.147541)*npx*sj6))+(((819672131.147541)*cj6*npy))), ((-2170785888.28556)+(((5392579810.18119)*pp))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[3];
IkReal x964=IKcos(j4);
evalcond[0]=((-0.402550535123675)+(((-1.8544e-10)*x964))+pp);
evalcond[1]=((-2.64835878370839)+(((-1.22e-9)*x964))+(((6.57894736842105)*pp)));
evalcond[2]=((((-1.0)*cj6*npy))+(((-1.0)*npx*sj6))+(((1.22e-9)*(IKsin(j4)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-5.8424922655324)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((((-51305507480.2948)*npx*sj6))+(((-51305507480.2948)*cj6*npy)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((2974357287.43333)+(((-337536233422.992)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-51305507480.2948)*npx*sj6))+(((-51305507480.2948)*cj6*npy))))+IKsqr(((2974357287.43333)+(((-337536233422.992)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((-51305507480.2948)*npx*sj6))+(((-51305507480.2948)*cj6*npy))), ((2974357287.43333)+(((-337536233422.992)*pp))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[3];
IkReal x965=IKcos(j4);
evalcond[0]=((-0.00881196444384667)+(((2.96264489847176e-12)*x965))+pp);
evalcond[1]=((-0.0579734502884649)+(((1.94910848583668e-11)*x965))+(((6.57894736842105)*pp)));
evalcond[2]=((((-1.94910848583668e-11)*(IKsin(j4))))+(((-1.0)*cj6*npy))+(((-1.0)*npx*sj6)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst3=((-0.459213759907003)+(((-0.592515680504259)*npz)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((0.459213759907003)+sj3+(((0.592515680504259)*npz)))))+(IKabs(((-1.0)+(IKsign(cj3)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[2];
IkReal x966=((0.59251568)*npz);
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj3=((-0.45921376)+(((-1.0)*x966)));
if((((0.789122722712073)+(((-0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz))))) < -0.00001)
continue;
cj3=IKsqrt(((0.789122722712073)+(((-0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz)))));
if( (((0.45921376)+x966)) < -1-IKFAST_SINCOS_THRESH || (((0.45921376)+x966)) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=((-1.0)*(IKasin(((0.45921376)+x966))));
IkReal gconst3=((-0.459213759907003)+(((-0.592515680504259)*npz)));
if((((0.789122722712073)+(((-0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz))))) < -0.00001)
continue;
j4eval[0]=((1.08665965104762)+(((3.30680179504762)*npz))+(((-1.0)*(IKsqrt(((0.789122722712073)+(((-0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz)))))))));
j4eval[1]=((-1.0)+(((5.42233009708738)*npz)));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j4]

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if((((0.789122722712073)+(((-0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz))))) < -0.00001)
continue;
CheckValue<IkReal> x967=IKPowWithIntegerCheck(((0.05704963168)+(((0.17360709424)*npz))+(((-0.0525)*(IKsqrt(((0.789122722712073)+(((-0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz))))))))),-1);
if(!x967.valid){
continue;
}
CheckValue<IkReal> x968=IKPowWithIntegerCheck(((-4.27467576791809e-12)+(((2.31787030716724e-11)*npz))),-1);
if(!x968.valid){
continue;
}
if( IKabs(((x967.value)*((((cj6*npy))+((npx*sj6)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x968.value)*(((-0.028931250004359)+(((-1.0)*pp))+(((-0.684999999976364)*npz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x967.value)*((((cj6*npy))+((npx*sj6))))))+IKsqr(((x968.value)*(((-0.028931250004359)+(((-1.0)*pp))+(((-0.684999999976364)*npz))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x967.value)*((((cj6*npy))+((npx*sj6))))), ((x968.value)*(((-0.028931250004359)+(((-1.0)*pp))+(((-0.684999999976364)*npz))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[3];
IkReal x969=IKcos(j4);
IkReal x970=IKsin(j4);
IkReal x971=(npz*x969);
evalcond[0]=((0.028931250004359)+(((0.684999999976364)*npz))+pp+(((2.31787030716724e-11)*x971))+(((-4.27467576791809e-12)*x969)));
evalcond[1]=((0.19033717108131)+(((4.50657894721292)*npz))+(((6.57894736842105)*pp))+(((1.52491467576792e-10)*x971))+(((-2.8122866894198e-11)*x969)));
if((((0.789122722712073)+(((-0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz))))) < -0.00001)
continue;
evalcond[2]=((((0.05704963168)*x970))+(((-0.0525)*x970*(IKsqrt(((0.789122722712073)+(((-0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz))))))))+(((-1.0)*cj6*npy))+(((-1.0)*npx*sj6))+(((0.17360709424)*npz*x970)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst3=((-0.459213759907003)+(((-0.592515680504259)*npz)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((0.459213759907003)+sj3+(((0.592515680504259)*npz)))))+(IKabs(((1.0)+(IKsign(cj3)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[2];
IkReal x972=((0.59251568)*npz);
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj3=((-0.45921376)+(((-1.0)*x972)));
if((((0.789122722712073)+(((-0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz))))) < -0.00001)
continue;
cj3=((-1.0)*(IKsqrt(((0.789122722712073)+(((-0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz)))))));
if( (((0.45921376)+x972)) < -1-IKFAST_SINCOS_THRESH || (((0.45921376)+x972)) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=((3.14159265)+(IKasin(((0.45921376)+x972))));
IkReal gconst3=((-0.459213759907003)+(((-0.592515680504259)*npz)));
if((((0.789122722712073)+(((-0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz))))) < -0.00001)
continue;
j4eval[0]=((1.08665965104762)+(IKsqrt(((0.789122722712073)+(((-0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz))))))+(((3.30680179504762)*npz)));
j4eval[1]=((-1.0)+(((5.42233009708738)*npz)));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j4]

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if((((0.789122722712073)+(((-0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz))))) < -0.00001)
continue;
CheckValue<IkReal> x973=IKPowWithIntegerCheck(((0.05704963168)+(((0.0525)*(IKsqrt(((0.789122722712073)+(((-0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz))))))))+(((0.17360709424)*npz))),-1);
if(!x973.valid){
continue;
}
CheckValue<IkReal> x974=IKPowWithIntegerCheck(((-4.27467576791809e-12)+(((2.31787030716724e-11)*npz))),-1);
if(!x974.valid){
continue;
}
if( IKabs(((x973.value)*((((cj6*npy))+((npx*sj6)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x974.value)*(((-0.028931250004359)+(((-1.0)*pp))+(((-0.684999999976364)*npz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x973.value)*((((cj6*npy))+((npx*sj6))))))+IKsqr(((x974.value)*(((-0.028931250004359)+(((-1.0)*pp))+(((-0.684999999976364)*npz))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x973.value)*((((cj6*npy))+((npx*sj6))))), ((x974.value)*(((-0.028931250004359)+(((-1.0)*pp))+(((-0.684999999976364)*npz))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[3];
IkReal x975=IKcos(j4);
IkReal x976=IKsin(j4);
IkReal x977=(npz*x975);
evalcond[0]=((0.028931250004359)+(((-4.27467576791809e-12)*x975))+(((0.684999999976364)*npz))+pp+(((2.31787030716724e-11)*x977)));
evalcond[1]=((0.19033717108131)+(((4.50657894721292)*npz))+(((-2.8122866894198e-11)*x975))+(((6.57894736842105)*pp))+(((1.52491467576792e-10)*x977)));
if((((0.789122722712073)+(((-0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz))))) < -0.00001)
continue;
evalcond[2]=((((0.0525)*x976*(IKsqrt(((0.789122722712073)+(((-0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz))))))))+(((0.05704963168)*x976))+(((-1.0)*cj6*npy))+(((-1.0)*npx*sj6))+(((0.17360709424)*npz*x976)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x978=IKPowWithIntegerCheck(((-0.0775)+(((-0.0525)*cj3))+(((-0.293)*sj3))),-1);
if(!x978.valid){
continue;
}
CheckValue<IkReal> x979=IKPowWithIntegerCheck(((0.021108156996587)+(((0.0459658634812287)*sj3))+(((0.0272354948805461)*npz))),-1);
if(!x979.valid){
continue;
}
if( IKabs(((x978.value)*((((cj6*npy))+((npx*sj6)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x979.value)*(((-0.00740648464163822)+(((0.0468730844709898)*sj3))+(((-0.657226962457338)*npz))+(((-1.0)*pp)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x978.value)*((((cj6*npy))+((npx*sj6))))))+IKsqr(((x979.value)*(((-0.00740648464163822)+(((0.0468730844709898)*sj3))+(((-0.657226962457338)*npz))+(((-1.0)*pp))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x978.value)*((((cj6*npy))+((npx*sj6))))), ((x979.value)*(((-0.00740648464163822)+(((0.0468730844709898)*sj3))+(((-0.657226962457338)*npz))+(((-1.0)*pp))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[3];
IkReal x980=IKsin(j4);
IkReal x981=IKcos(j4);
IkReal x982=(npz*x981);
IkReal x983=(sj3*x981);
evalcond[0]=((((-0.293)*sj3*x980))+(((-0.0775)*x980))+(((-1.0)*cj6*npy))+(((-1.0)*npx*sj6))+(((-0.0525)*cj3*x980)));
evalcond[1]=((0.00740648464163822)+(((0.657226962457338)*npz))+(((0.0459658634812287)*x983))+(((-0.0468730844709898)*sj3))+(((0.0272354948805461)*x982))+pp+(((0.021108156996587)*x981)));
evalcond[2]=((0.0487268726423567)+(((0.179180887372014)*x982))+(((-0.308375555730196)*sj3))+(((4.32386159511406)*npz))+(((0.302406996587031)*x983))+(((0.138869453924915)*x981))+(((6.57894736842105)*pp)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x984=((0.0525)*cj3);
IkReal x985=((0.293)*sj3);
CheckValue<IkReal> x986=IKPowWithIntegerCheck(((-0.0775)+(((-1.0)*x985))+(((-1.0)*x984))),-1);
if(!x986.valid){
continue;
}
CheckValue<IkReal> x987=IKPowWithIntegerCheck((((cj5*x984))+((cj5*x985))+(((0.0775)*cj5))),-1);
if(!x987.valid){
continue;
}
if( IKabs(((x986.value)*((((cj6*npy))+((npx*sj6)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x987.value)*(((-0.076)+((cj6*npx))+(((-0.3425)*sj5))+(((-0.0525)*sj3*sj5))+(((0.293)*cj3*sj5))+(((-1.0)*npy*sj6)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x986.value)*((((cj6*npy))+((npx*sj6))))))+IKsqr(((x987.value)*(((-0.076)+((cj6*npx))+(((-0.3425)*sj5))+(((-0.0525)*sj3*sj5))+(((0.293)*cj3*sj5))+(((-1.0)*npy*sj6))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x986.value)*((((cj6*npy))+((npx*sj6))))), ((x987.value)*(((-0.076)+((cj6*npx))+(((-0.3425)*sj5))+(((-0.0525)*sj3*sj5))+(((0.293)*cj3*sj5))+(((-1.0)*npy*sj6))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[5];
IkReal x988=IKsin(j4);
IkReal x989=IKcos(j4);
IkReal x990=(npy*sj6);
IkReal x991=((1.0)*npx);
IkReal x992=((0.293)*cj3);
IkReal x993=((0.0525)*sj3);
IkReal x994=(sj3*x989);
IkReal x995=((0.0775)*x989);
IkReal x996=(cj5*x989);
IkReal x997=((0.0525)*cj3*x989);
evalcond[0]=((((-1.0)*sj6*x991))+(((-0.293)*sj3*x988))+(((-0.0775)*x988))+(((-1.0)*cj6*npy))+(((-0.0525)*cj3*x988)));
evalcond[1]=(((cj5*x990))+((npz*sj5))+(((-1.0)*cj5*cj6*x991))+(((0.076)*cj5))+x997+x995+(((0.293)*x994)));
evalcond[2]=((((0.3425)*cj5))+(((-0.293)*sj5*x994))+(((-1.0)*cj5*x992))+((cj5*x993))+(((-1.0)*npz))+(((-1.0)*sj5*x997))+(((-1.0)*sj5*x995)));
evalcond[3]=((0.076)+((cj5*x995))+(((0.0525)*cj3*x996))+(((-1.0)*sj5*x992))+((sj5*x993))+(((0.3425)*sj5))+(((-1.0)*cj6*x991))+x990+(((0.293)*cj5*x994)));
evalcond[4]=((-0.21769375)+(((-0.05206)*sj5))+(((-0.00798)*cj3*x996))+(((-0.044536)*cj5*x994))+(((0.1925675)*cj3))+(((-0.00798)*sj3*sj5))+pp+(((-0.01178)*x996))+(((-0.0813775)*sj3))+(((0.044536)*cj3*sj5)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x998=((0.293)*sj3);
IkReal x999=((0.0525)*cj3);
CheckValue<IkReal> x1000=IKPowWithIntegerCheck(((-0.0775)+(((-1.0)*x998))+(((-1.0)*x999))),-1);
if(!x1000.valid){
continue;
}
CheckValue<IkReal> x1001=IKPowWithIntegerCheck(((((-0.0775)*sj5))+(((-1.0)*sj5*x998))+(((-1.0)*sj5*x999))),-1);
if(!x1001.valid){
continue;
}
if( IKabs(((x1000.value)*((((cj6*npy))+((npx*sj6)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1001.value)*((npz+(((-0.3425)*cj5))+(((0.293)*cj3*cj5))+(((-0.0525)*cj5*sj3)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1000.value)*((((cj6*npy))+((npx*sj6))))))+IKsqr(((x1001.value)*((npz+(((-0.3425)*cj5))+(((0.293)*cj3*cj5))+(((-0.0525)*cj5*sj3))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x1000.value)*((((cj6*npy))+((npx*sj6))))), ((x1001.value)*((npz+(((-0.3425)*cj5))+(((0.293)*cj3*cj5))+(((-0.0525)*cj5*sj3))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[5];
IkReal x1002=IKsin(j4);
IkReal x1003=IKcos(j4);
IkReal x1004=(npy*sj6);
IkReal x1005=((1.0)*npx);
IkReal x1006=((0.293)*cj3);
IkReal x1007=((0.0525)*sj3);
IkReal x1008=(sj3*x1003);
IkReal x1009=((0.0775)*x1003);
IkReal x1010=(cj5*x1003);
IkReal x1011=((0.0525)*cj3*x1003);
evalcond[0]=((((-0.0525)*cj3*x1002))+(((-0.0775)*x1002))+(((-1.0)*cj6*npy))+(((-1.0)*sj6*x1005))+(((-0.293)*sj3*x1002)));
evalcond[1]=(x1011+x1009+(((-1.0)*cj5*cj6*x1005))+((npz*sj5))+((cj5*x1004))+(((0.293)*x1008))+(((0.076)*cj5)));
evalcond[2]=((((0.3425)*cj5))+(((-1.0)*cj5*x1006))+(((-1.0)*npz))+((cj5*x1007))+(((-0.293)*sj5*x1008))+(((-1.0)*sj5*x1011))+(((-1.0)*sj5*x1009)));
evalcond[3]=((0.076)+x1004+((cj5*x1009))+(((0.293)*cj5*x1008))+(((0.0525)*cj3*x1010))+((sj5*x1007))+(((-1.0)*cj6*x1005))+(((0.3425)*sj5))+(((-1.0)*sj5*x1006)));
evalcond[4]=((-0.21769375)+(((-0.05206)*sj5))+(((-0.00798)*cj3*x1010))+(((-0.044536)*cj5*x1008))+(((0.1925675)*cj3))+(((-0.00798)*sj3*sj5))+pp+(((-0.0813775)*sj3))+(((0.044536)*cj3*sj5))+(((-0.01178)*x1010)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x1012 = IKatan2WithCheck(IkReal((((cj6*npy))+((npx*sj6)))),IkReal((((npz*sj5))+(((0.076)*cj5))+((cj5*npy*sj6))+(((-1.0)*cj5*cj6*npx)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1012.valid){
continue;
}
CheckValue<IkReal> x1013=IKPowWithIntegerCheck(IKsign(((-0.0775)+(((-0.0525)*cj3))+(((-0.293)*sj3)))),-1);
if(!x1013.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(x1012.value)+(((1.5707963267949)*(x1013.value))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[5];
IkReal x1014=IKsin(j4);
IkReal x1015=IKcos(j4);
IkReal x1016=(npy*sj6);
IkReal x1017=((1.0)*npx);
IkReal x1018=((0.293)*cj3);
IkReal x1019=((0.0525)*sj3);
IkReal x1020=(sj3*x1015);
IkReal x1021=((0.0775)*x1015);
IkReal x1022=(cj5*x1015);
IkReal x1023=((0.0525)*cj3*x1015);
evalcond[0]=((((-0.0775)*x1014))+(((-0.0525)*cj3*x1014))+(((-1.0)*cj6*npy))+(((-0.293)*sj3*x1014))+(((-1.0)*sj6*x1017)));
evalcond[1]=(x1021+x1023+((npz*sj5))+(((-1.0)*cj5*cj6*x1017))+((cj5*x1016))+(((0.293)*x1020))+(((0.076)*cj5)));
evalcond[2]=((((-0.293)*sj5*x1020))+(((0.3425)*cj5))+(((-1.0)*npz))+(((-1.0)*cj5*x1018))+((cj5*x1019))+(((-1.0)*sj5*x1021))+(((-1.0)*sj5*x1023)));
evalcond[3]=((0.076)+x1016+(((0.0525)*cj3*x1022))+((cj5*x1021))+(((0.293)*cj5*x1020))+((sj5*x1019))+(((-1.0)*sj5*x1018))+(((-1.0)*cj6*x1017))+(((0.3425)*sj5)));
evalcond[4]=((-0.21769375)+(((-0.05206)*sj5))+(((-0.01178)*x1022))+(((-0.00798)*cj3*x1022))+(((-0.044536)*cj5*x1020))+(((0.1925675)*cj3))+(((-0.00798)*sj3*sj5))+pp+(((-0.0813775)*sj3))+(((0.044536)*cj3*sj5)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}
}
}

}

}
}
return solutions.GetNumSolutions()>0;
}
inline void rotationfunction0(IkSolutionListBase<IkReal>& solutions) {
for(int rotationiter = 0; rotationiter < 1; ++rotationiter) {
IkReal x98=((1.0)*sj4);
IkReal x99=((1.0)*sj5);
IkReal x100=((1.0)*sj3);
IkReal x101=((1.0)*cj5);
IkReal x102=((1.0)*cj4);
IkReal x103=((1.0)*sj6);
IkReal x104=((-1.0)*sj4);
IkReal x105=((-1.0)*sj5);
IkReal x106=((-1.0)*cj5);
IkReal x107=((((-1.0)*r01*x103))+((cj6*r00)));
IkReal x108=(((r00*sj6))+((cj6*r01)));
IkReal x109=((((-1.0)*r11*x103))+((cj6*r10)));
IkReal x110=(((r10*sj6))+((cj6*r11)));
IkReal x111=((((-1.0)*r21*x103))+((cj6*r20)));
IkReal x112=(((cj6*r21))+((r20*sj6)));
IkReal x113=(cj5*x107);
IkReal x114=(cj5*x109);
IkReal x115=(cj5*x111);
IkReal x116=(x113+(((-1.0)*r02*x99)));
IkReal x117=((((-1.0)*r12*x99))+x114);
IkReal x118=(x115+(((-1.0)*r22*x99)));
new_r00=(((cj3*((((cj4*x116))+(((-1.0)*x108*x98))))))+(((-1.0)*x100*((((r02*x106))+((x105*x107)))))));
new_r01=((((-1.0)*x116*x98))+(((-1.0)*x102*x108)));
new_r02=(((cj3*(((((-1.0)*x107*x99))+(((-1.0)*r02*x101))))))+((sj3*((((cj4*((((r02*x105))+x113))))+((x104*x108)))))));
new_r10=(((cj3*(((((-1.0)*x110*x98))+((cj4*x117))))))+(((-1.0)*x100*((((r12*x106))+((x105*x109)))))));
new_r11=((((-1.0)*x117*x98))+(((-1.0)*x102*x110)));
new_r12=(((sj3*((((cj4*((x114+((r12*x105))))))+((x104*x110))))))+((cj3*(((((-1.0)*r12*x101))+(((-1.0)*x109*x99)))))));
new_r20=(((cj3*((((cj4*((((r22*x105))+x115))))+((x104*x112))))))+(((-1.0)*x100*(((((-1.0)*x111*x99))+(((-1.0)*r22*x101)))))));
new_r21=((((-1.0)*x118*x98))+(((-1.0)*x102*x112)));
new_r22=(((cj3*((((r22*x106))+((x105*x111))))))+((sj3*(((((-1.0)*x112*x98))+((cj4*x118)))))));
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
cj1array[0]=new_r22;
if( cj1array[0] >= -1-IKFAST_SINCOS_THRESH && cj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKacos(cj1array[0]);
    sj1array[0] = IKsin(j1array[0]);
    cj1array[1] = cj1array[0];
    j1array[1] = -j1array[0];
    sj1array[1] = -sj1array[0];
}
else if( isnan(cj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

{
IkReal j0eval[3];
j0eval[0]=sj1;
j0eval[1]=((IKabs(new_r12))+(IKabs(new_r02)));
j0eval[2]=IKsign(sj1);
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[3];
j2eval[0]=sj1;
j2eval[1]=IKsign(sj1);
j2eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[2];
j0eval[0]=new_r12;
j0eval[1]=sj1;
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j1))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
IkReal j2mul = 1;
j2=0;
j0mul=-1.0;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0=IKatan2(((-1.0)*new_r01), new_r00);
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].fmul = j0mul;
vinfos[0].freeind = 0;
vinfos[0].maxsolutions = 0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].fmul = j2mul;
vinfos[2].freeind = 0;
vinfos[2].maxsolutions = 0;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(1);
vfree[0] = 2;
solutions.AddSolution(vinfos,vfree);
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j1)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
IkReal j2mul = 1;
j2=0;
j0mul=1.0;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(((-1.0)*new_r00))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0=IKatan2(((-1.0)*new_r01), ((-1.0)*new_r00));
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].fmul = j0mul;
vinfos[0].freeind = 0;
vinfos[0].maxsolutions = 0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].fmul = j2mul;
vinfos[2].freeind = 0;
vinfos[2].maxsolutions = 0;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(1);
vfree[0] = 2;
solutions.AddSolution(vinfos,vfree);
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r12))+(IKabs(new_r02)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
IkReal x119=new_r22*new_r22;
IkReal x120=((16.0)*new_r10);
IkReal x121=((16.0)*new_r01);
IkReal x122=((16.0)*new_r22);
IkReal x123=((8.0)*new_r11);
IkReal x124=((8.0)*new_r00);
IkReal x125=(x119*x120);
IkReal x126=(x119*x121);
j0eval[0]=((IKabs(((((16.0)*new_r00))+(((-32.0)*new_r00*x119))+((new_r11*x122)))))+(IKabs((((new_r22*x123))+(((-1.0)*x124)))))+(IKabs(((((-1.0)*new_r22*x124))+((x119*x123)))))+(IKabs(((((-1.0)*x120))+x125)))+(IKabs(((((32.0)*new_r11))+(((-1.0)*new_r00*x122))+(((-16.0)*new_r11*x119)))))+(IKabs(((((-1.0)*x125))+x120)))+(IKabs(((((-1.0)*x121))+x126)))+(IKabs(((((-1.0)*x126))+x121))));
if( IKabs(j0eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j0, j2]

} else
{
IkReal op[4+1], zeror[4];
int numroots;
IkReal j0evalpoly[1];
IkReal x127=new_r22*new_r22;
IkReal x128=((16.0)*new_r10);
IkReal x129=(new_r11*new_r22);
IkReal x130=(x127*x128);
IkReal x131=((((-8.0)*new_r00))+(((8.0)*x129)));
op[0]=x131;
op[1]=(x128+(((-1.0)*x130)));
op[2]=((((16.0)*x129))+(((16.0)*new_r00))+(((-32.0)*new_r00*x127)));
op[3]=((((-1.0)*x128))+x130);
op[4]=x131;
polyroots4(op,zeror,numroots);
IkReal j0array[4], cj0array[4], sj0array[4], tempj0array[1];
int numsolutions = 0;
for(int ij0 = 0; ij0 < numroots; ++ij0)
{
IkReal htj0 = zeror[ij0];
tempj0array[0]=((2.0)*(atan(htj0)));
for(int kj0 = 0; kj0 < 1; ++kj0)
{
j0array[numsolutions] = tempj0array[kj0];
if( j0array[numsolutions] > IKPI )
{
    j0array[numsolutions]-=IK2PI;
}
else if( j0array[numsolutions] < -IKPI )
{
    j0array[numsolutions]+=IK2PI;
}
sj0array[numsolutions] = IKsin(j0array[numsolutions]);
cj0array[numsolutions] = IKcos(j0array[numsolutions]);
numsolutions++;
}
}
bool j0valid[4]={true,true,true,true};
_nj0 = 4;
for(int ij0 = 0; ij0 < numsolutions; ++ij0)
    {
if( !j0valid[ij0] )
{
    continue;
}
    j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
htj0 = IKtan(j0/2);

IkReal x132=((16.0)*new_r01);
IkReal x133=new_r22*new_r22;
IkReal x134=(new_r00*new_r22);
IkReal x135=((8.0)*x134);
IkReal x136=(new_r11*x133);
IkReal x137=(x132*x133);
IkReal x138=((8.0)*x136);
j0evalpoly[0]=(((htj0*((x132+(((-1.0)*x137))))))+(((htj0*htj0)*(((((32.0)*new_r11))+(((-16.0)*x134))+(((-16.0)*x136))))))+x138+(((htj0*htj0*htj0*htj0)*((x138+(((-1.0)*x135))))))+(((-1.0)*x135))+(((htj0*htj0*htj0)*((x137+(((-1.0)*x132)))))));
if( IKabs(j0evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < numsolutions; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
{
IkReal j2eval[3];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
IkReal x139=cj0*cj0;
IkReal x140=(cj0*new_r22);
IkReal x141=((-1.0)+x139+(((-1.0)*x139*(new_r22*new_r22))));
j2eval[0]=x141;
j2eval[1]=IKsign(x141);
j2eval[2]=((IKabs((((new_r01*x140))+((new_r00*sj0)))))+(IKabs((((new_r01*sj0))+(((-1.0)*new_r00*x140))))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j2eval[0]=new_r22;
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
IkReal x142=new_r22*new_r22;
j2eval[0]=(((cj0*x142))+(((-1.0)*cj0)));
j2eval[1]=((((-1.0)*sj0))+((sj0*x142)));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j0)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x143=IKsin(j2);
IkReal x144=IKcos(j2);
evalcond[0]=x143;
evalcond[1]=((-1.0)*x144);
evalcond[2]=((((-1.0)*x143))+(((-1.0)*new_r00)));
evalcond[3]=((((-1.0)*x144))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j0)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(new_r00, new_r01);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x145=IKsin(j2);
IkReal x146=IKcos(j2);
evalcond[0]=x145;
evalcond[1]=((-1.0)*x146);
evalcond[2]=((((-1.0)*x145))+new_r00);
evalcond[3]=((((-1.0)*x146))+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j0))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(new_r10, new_r11);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x147=IKsin(j2);
IkReal x148=IKcos(j2);
evalcond[0]=x147;
evalcond[1]=((-1.0)*x148);
evalcond[2]=((((-1.0)*x147))+new_r10);
evalcond[3]=((((-1.0)*x148))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j0)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r11));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x149=IKsin(j2);
IkReal x150=IKcos(j2);
evalcond[0]=x149;
evalcond[1]=((-1.0)*x150);
evalcond[2]=((((-1.0)*x149))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x150))+(((-1.0)*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
CheckValue<IkReal> x151=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x151.valid){
continue;
}
if((x151.value) < -0.00001)
continue;
IkReal gconst6=((-1.0)*(IKsqrt(x151.value)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((cj0+(((-1.0)*gconst6)))))+(IKabs(((-1.0)+(IKsign(sj0)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
if((((1.0)+(((-1.0)*(gconst6*gconst6))))) < -0.00001)
continue;
sj0=IKsqrt(((1.0)+(((-1.0)*(gconst6*gconst6)))));
cj0=gconst6;
if( (gconst6) < -1-IKFAST_SINCOS_THRESH || (gconst6) > 1+IKFAST_SINCOS_THRESH )
    continue;
j0=IKacos(gconst6);
CheckValue<IkReal> x152=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x152.valid){
continue;
}
if((x152.value) < -0.00001)
continue;
IkReal gconst6=((-1.0)*(IKsqrt(x152.value)));
j2eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if((((1.0)+(((-1.0)*(gconst6*gconst6))))) < -0.00001)
continue;
CheckValue<IkReal> x153=IKPowWithIntegerCheck(gconst6,-1);
if(!x153.valid){
continue;
}
if( IKabs((((gconst6*new_r10))+(((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst6*gconst6)))))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r11*(x153.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((gconst6*new_r10))+(((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst6*gconst6))))))))))+IKsqr((new_r11*(x153.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((((gconst6*new_r10))+(((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst6*gconst6))))))))), (new_r11*(x153.value)));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x154=IKcos(j2);
IkReal x155=IKsin(j2);
IkReal x156=((1.0)*gconst6);
if((((1.0)+(((-1.0)*gconst6*x156)))) < -0.00001)
continue;
IkReal x157=IKsqrt(((1.0)+(((-1.0)*gconst6*x156))));
IkReal x158=((1.0)*x157);
evalcond[0]=x155;
evalcond[1]=((-1.0)*x154);
evalcond[2]=((((-1.0)*x154*x156))+new_r11);
evalcond[3]=((((-1.0)*x155*x156))+new_r10);
evalcond[4]=(((x154*x157))+new_r01);
evalcond[5]=(((x155*x157))+new_r00);
evalcond[6]=(((gconst6*new_r10))+(((-1.0)*x155))+(((-1.0)*new_r00*x158)));
evalcond[7]=(((gconst6*new_r11))+(((-1.0)*x154))+(((-1.0)*new_r01*x158)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x159 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x159.valid){
continue;
}
CheckValue<IkReal> x160=IKPowWithIntegerCheck(IKsign(gconst6),-1);
if(!x160.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x159.value)+(((1.5707963267949)*(x160.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x161=IKcos(j2);
IkReal x162=IKsin(j2);
IkReal x163=((1.0)*gconst6);
if((((1.0)+(((-1.0)*gconst6*x163)))) < -0.00001)
continue;
IkReal x164=IKsqrt(((1.0)+(((-1.0)*gconst6*x163))));
IkReal x165=((1.0)*x164);
evalcond[0]=x162;
evalcond[1]=((-1.0)*x161);
evalcond[2]=((((-1.0)*x161*x163))+new_r11);
evalcond[3]=((((-1.0)*x162*x163))+new_r10);
evalcond[4]=(((x161*x164))+new_r01);
evalcond[5]=(((x162*x164))+new_r00);
evalcond[6]=((((-1.0)*new_r00*x165))+((gconst6*new_r10))+(((-1.0)*x162)));
evalcond[7]=(((gconst6*new_r11))+(((-1.0)*x161))+(((-1.0)*new_r01*x165)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
CheckValue<IkReal> x166=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x166.valid){
continue;
}
if((x166.value) < -0.00001)
continue;
IkReal gconst6=((-1.0)*(IKsqrt(x166.value)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.0)+(IKsign(sj0)))))+(IKabs((cj0+(((-1.0)*gconst6)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
if((((1.0)+(((-1.0)*(gconst6*gconst6))))) < -0.00001)
continue;
sj0=((-1.0)*(IKsqrt(((1.0)+(((-1.0)*(gconst6*gconst6)))))));
cj0=gconst6;
if( (gconst6) < -1-IKFAST_SINCOS_THRESH || (gconst6) > 1+IKFAST_SINCOS_THRESH )
    continue;
j0=((-1.0)*(IKacos(gconst6)));
CheckValue<IkReal> x167=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x167.valid){
continue;
}
if((x167.value) < -0.00001)
continue;
IkReal gconst6=((-1.0)*(IKsqrt(x167.value)));
j2eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if((((1.0)+(((-1.0)*(gconst6*gconst6))))) < -0.00001)
continue;
CheckValue<IkReal> x168=IKPowWithIntegerCheck(gconst6,-1);
if(!x168.valid){
continue;
}
if( IKabs((((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst6*gconst6))))))))+((gconst6*new_r10)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r11*(x168.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst6*gconst6))))))))+((gconst6*new_r10))))+IKsqr((new_r11*(x168.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst6*gconst6))))))))+((gconst6*new_r10))), (new_r11*(x168.value)));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x169=IKcos(j2);
IkReal x170=IKsin(j2);
IkReal x171=((1.0)*gconst6);
IkReal x172=((1.0)*x169);
IkReal x173=((1.0)*x170);
if((((1.0)+(((-1.0)*gconst6*x171)))) < -0.00001)
continue;
IkReal x174=IKsqrt(((1.0)+(((-1.0)*gconst6*x171))));
evalcond[0]=x170;
evalcond[1]=((-1.0)*x169);
evalcond[2]=(new_r11+(((-1.0)*x169*x171)));
evalcond[3]=((((-1.0)*x170*x171))+new_r10);
evalcond[4]=(new_r01+(((-1.0)*x172*x174)));
evalcond[5]=(new_r00+(((-1.0)*x173*x174)));
evalcond[6]=(((new_r00*x174))+(((-1.0)*x173))+((gconst6*new_r10)));
evalcond[7]=(((new_r01*x174))+(((-1.0)*x172))+((gconst6*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x175 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x175.valid){
continue;
}
CheckValue<IkReal> x176=IKPowWithIntegerCheck(IKsign(gconst6),-1);
if(!x176.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x175.value)+(((1.5707963267949)*(x176.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x177=IKcos(j2);
IkReal x178=IKsin(j2);
IkReal x179=((1.0)*gconst6);
IkReal x180=((1.0)*x177);
IkReal x181=((1.0)*x178);
if((((1.0)+(((-1.0)*gconst6*x179)))) < -0.00001)
continue;
IkReal x182=IKsqrt(((1.0)+(((-1.0)*gconst6*x179))));
evalcond[0]=x178;
evalcond[1]=((-1.0)*x177);
evalcond[2]=((((-1.0)*x177*x179))+new_r11);
evalcond[3]=((((-1.0)*x178*x179))+new_r10);
evalcond[4]=((((-1.0)*x180*x182))+new_r01);
evalcond[5]=(new_r00+(((-1.0)*x181*x182)));
evalcond[6]=(((new_r00*x182))+((gconst6*new_r10))+(((-1.0)*x181)));
evalcond[7]=(((new_r01*x182))+((gconst6*new_r11))+(((-1.0)*x180)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
CheckValue<IkReal> x183=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x183.valid){
continue;
}
if((x183.value) < -0.00001)
continue;
IkReal gconst7=IKsqrt(x183.value);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((cj0+(((-1.0)*gconst7)))))+(IKabs(((-1.0)+(IKsign(sj0)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
if((((1.0)+(((-1.0)*(gconst7*gconst7))))) < -0.00001)
continue;
sj0=IKsqrt(((1.0)+(((-1.0)*(gconst7*gconst7)))));
cj0=gconst7;
if( (gconst7) < -1-IKFAST_SINCOS_THRESH || (gconst7) > 1+IKFAST_SINCOS_THRESH )
    continue;
j0=IKacos(gconst7);
CheckValue<IkReal> x184=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x184.valid){
continue;
}
if((x184.value) < -0.00001)
continue;
IkReal gconst7=IKsqrt(x184.value);
j2eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if((((1.0)+(((-1.0)*(gconst7*gconst7))))) < -0.00001)
continue;
CheckValue<IkReal> x185=IKPowWithIntegerCheck(gconst7,-1);
if(!x185.valid){
continue;
}
if( IKabs(((((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst7*gconst7))))))))+((gconst7*new_r10)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r11*(x185.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst7*gconst7))))))))+((gconst7*new_r10))))+IKsqr((new_r11*(x185.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst7*gconst7))))))))+((gconst7*new_r10))), (new_r11*(x185.value)));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x186=IKcos(j2);
IkReal x187=IKsin(j2);
IkReal x188=((1.0)*gconst7);
if((((1.0)+(((-1.0)*gconst7*x188)))) < -0.00001)
continue;
IkReal x189=IKsqrt(((1.0)+(((-1.0)*gconst7*x188))));
IkReal x190=((1.0)*x189);
evalcond[0]=x187;
evalcond[1]=((-1.0)*x186);
evalcond[2]=((((-1.0)*x186*x188))+new_r11);
evalcond[3]=((((-1.0)*x187*x188))+new_r10);
evalcond[4]=(((x186*x189))+new_r01);
evalcond[5]=(((x187*x189))+new_r00);
evalcond[6]=((((-1.0)*x187))+(((-1.0)*new_r00*x190))+((gconst7*new_r10)));
evalcond[7]=((((-1.0)*x186))+(((-1.0)*new_r01*x190))+((gconst7*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x191=IKPowWithIntegerCheck(IKsign(gconst7),-1);
if(!x191.valid){
continue;
}
CheckValue<IkReal> x192 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x192.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x191.value)))+(x192.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x193=IKcos(j2);
IkReal x194=IKsin(j2);
IkReal x195=((1.0)*gconst7);
if((((1.0)+(((-1.0)*gconst7*x195)))) < -0.00001)
continue;
IkReal x196=IKsqrt(((1.0)+(((-1.0)*gconst7*x195))));
IkReal x197=((1.0)*x196);
evalcond[0]=x194;
evalcond[1]=((-1.0)*x193);
evalcond[2]=(new_r11+(((-1.0)*x193*x195)));
evalcond[3]=((((-1.0)*x194*x195))+new_r10);
evalcond[4]=(((x193*x196))+new_r01);
evalcond[5]=(((x194*x196))+new_r00);
evalcond[6]=((((-1.0)*x194))+(((-1.0)*new_r00*x197))+((gconst7*new_r10)));
evalcond[7]=((((-1.0)*x193))+(((-1.0)*new_r01*x197))+((gconst7*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
CheckValue<IkReal> x198=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x198.valid){
continue;
}
if((x198.value) < -0.00001)
continue;
IkReal gconst7=IKsqrt(x198.value);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.0)+(IKsign(sj0)))))+(IKabs((cj0+(((-1.0)*gconst7)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
if((((1.0)+(((-1.0)*(gconst7*gconst7))))) < -0.00001)
continue;
sj0=((-1.0)*(IKsqrt(((1.0)+(((-1.0)*(gconst7*gconst7)))))));
cj0=gconst7;
if( (gconst7) < -1-IKFAST_SINCOS_THRESH || (gconst7) > 1+IKFAST_SINCOS_THRESH )
    continue;
j0=((-1.0)*(IKacos(gconst7)));
CheckValue<IkReal> x199=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x199.valid){
continue;
}
if((x199.value) < -0.00001)
continue;
IkReal gconst7=IKsqrt(x199.value);
j2eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if((((1.0)+(((-1.0)*(gconst7*gconst7))))) < -0.00001)
continue;
CheckValue<IkReal> x200=IKPowWithIntegerCheck(gconst7,-1);
if(!x200.valid){
continue;
}
if( IKabs((((gconst7*new_r10))+((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst7*gconst7)))))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r11*(x200.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((gconst7*new_r10))+((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst7*gconst7))))))))))+IKsqr((new_r11*(x200.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((((gconst7*new_r10))+((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst7*gconst7))))))))), (new_r11*(x200.value)));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x201=IKcos(j2);
IkReal x202=IKsin(j2);
IkReal x203=((1.0)*x202);
IkReal x204=((1.0)*x201);
if((((1.0)+(((-1.0)*(gconst7*gconst7))))) < -0.00001)
continue;
IkReal x205=IKsqrt(((1.0)+(((-1.0)*(gconst7*gconst7)))));
evalcond[0]=x202;
evalcond[1]=((-1.0)*x201);
evalcond[2]=(new_r11+(((-1.0)*gconst7*x204)));
evalcond[3]=(new_r10+(((-1.0)*gconst7*x203)));
evalcond[4]=((((-1.0)*x204*x205))+new_r01);
evalcond[5]=((((-1.0)*x203*x205))+new_r00);
evalcond[6]=(((new_r00*x205))+(((-1.0)*x203))+((gconst7*new_r10)));
evalcond[7]=(((new_r01*x205))+(((-1.0)*x204))+((gconst7*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x206=IKPowWithIntegerCheck(IKsign(gconst7),-1);
if(!x206.valid){
continue;
}
CheckValue<IkReal> x207 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x207.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x206.value)))+(x207.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x208=IKcos(j2);
IkReal x209=IKsin(j2);
IkReal x210=((1.0)*x209);
IkReal x211=((1.0)*x208);
if((((1.0)+(((-1.0)*(gconst7*gconst7))))) < -0.00001)
continue;
IkReal x212=IKsqrt(((1.0)+(((-1.0)*(gconst7*gconst7)))));
evalcond[0]=x209;
evalcond[1]=((-1.0)*x208);
evalcond[2]=((((-1.0)*gconst7*x211))+new_r11);
evalcond[3]=((((-1.0)*gconst7*x210))+new_r10);
evalcond[4]=((((-1.0)*x211*x212))+new_r01);
evalcond[5]=((((-1.0)*x210*x212))+new_r00);
evalcond[6]=(((new_r00*x212))+(((-1.0)*x210))+((gconst7*new_r10)));
evalcond[7]=(((new_r01*x212))+(((-1.0)*x211))+((gconst7*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j2]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x213=new_r22*new_r22;
CheckValue<IkReal> x214=IKPowWithIntegerCheck((((cj0*x213))+(((-1.0)*cj0))),-1);
if(!x214.valid){
continue;
}
CheckValue<IkReal> x215=IKPowWithIntegerCheck(((((-1.0)*sj0))+((sj0*x213))),-1);
if(!x215.valid){
continue;
}
if( IKabs(((x214.value)*(((((-1.0)*new_r01*new_r22))+(((-1.0)*new_r10)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x215.value)*((((new_r10*new_r22))+new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x214.value)*(((((-1.0)*new_r01*new_r22))+(((-1.0)*new_r10))))))+IKsqr(((x215.value)*((((new_r10*new_r22))+new_r01))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((x214.value)*(((((-1.0)*new_r01*new_r22))+(((-1.0)*new_r10))))), ((x215.value)*((((new_r10*new_r22))+new_r01))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[10];
IkReal x216=IKsin(j2);
IkReal x217=IKcos(j2);
IkReal x218=(cj0*new_r22);
IkReal x219=(new_r22*sj0);
IkReal x220=((1.0)*sj0);
IkReal x221=((1.0)*x217);
IkReal x222=((1.0)*x216);
evalcond[0]=(((new_r22*x216))+((new_r11*sj0))+((cj0*new_r01)));
evalcond[1]=(x216+((new_r01*x218))+((new_r11*x219)));
evalcond[2]=(((cj0*new_r10))+(((-1.0)*x222))+(((-1.0)*new_r00*x220)));
evalcond[3]=((((-1.0)*new_r01*x220))+((cj0*new_r11))+(((-1.0)*x221)));
evalcond[4]=(((x216*x218))+((sj0*x217))+new_r01);
evalcond[5]=(((new_r10*sj0))+(((-1.0)*new_r22*x221))+((cj0*new_r00)));
evalcond[6]=(((sj0*x216))+(((-1.0)*x218*x221))+new_r00);
evalcond[7]=((((-1.0)*cj0*x221))+((x216*x219))+new_r11);
evalcond[8]=(((new_r00*x218))+((new_r10*x219))+(((-1.0)*x221)));
evalcond[9]=((((-1.0)*cj0*x222))+(((-1.0)*x219*x221))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x223=((1.0)*new_r01);
CheckValue<IkReal> x224=IKPowWithIntegerCheck(new_r22,-1);
if(!x224.valid){
continue;
}
if( IKabs(((x224.value)*(((((-1.0)*cj0*x223))+(((-1.0)*new_r11*sj0)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*sj0*x223))+((cj0*new_r11)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x224.value)*(((((-1.0)*cj0*x223))+(((-1.0)*new_r11*sj0))))))+IKsqr(((((-1.0)*sj0*x223))+((cj0*new_r11))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((x224.value)*(((((-1.0)*cj0*x223))+(((-1.0)*new_r11*sj0))))), ((((-1.0)*sj0*x223))+((cj0*new_r11))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[10];
IkReal x225=IKsin(j2);
IkReal x226=IKcos(j2);
IkReal x227=(cj0*new_r22);
IkReal x228=(new_r22*sj0);
IkReal x229=((1.0)*sj0);
IkReal x230=((1.0)*x226);
IkReal x231=((1.0)*x225);
evalcond[0]=(((new_r11*sj0))+((new_r22*x225))+((cj0*new_r01)));
evalcond[1]=(((new_r01*x227))+x225+((new_r11*x228)));
evalcond[2]=((((-1.0)*x231))+((cj0*new_r10))+(((-1.0)*new_r00*x229)));
evalcond[3]=((((-1.0)*new_r01*x229))+(((-1.0)*x230))+((cj0*new_r11)));
evalcond[4]=(((x225*x227))+((sj0*x226))+new_r01);
evalcond[5]=((((-1.0)*new_r22*x230))+((new_r10*sj0))+((cj0*new_r00)));
evalcond[6]=((((-1.0)*x227*x230))+((sj0*x225))+new_r00);
evalcond[7]=(((x225*x228))+(((-1.0)*cj0*x230))+new_r11);
evalcond[8]=(((new_r00*x227))+(((-1.0)*x230))+((new_r10*x228)));
evalcond[9]=((((-1.0)*cj0*x231))+new_r10+(((-1.0)*x228*x230)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x232=cj0*cj0;
IkReal x233=(cj0*new_r22);
CheckValue<IkReal> x234=IKPowWithIntegerCheck(IKsign(((-1.0)+x232+(((-1.0)*x232*(new_r22*new_r22))))),-1);
if(!x234.valid){
continue;
}
CheckValue<IkReal> x235 = IKatan2WithCheck(IkReal((((new_r01*x233))+((new_r00*sj0)))),IkReal(((((-1.0)*new_r00*x233))+((new_r01*sj0)))),IKFAST_ATAN2_MAGTHRESH);
if(!x235.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x234.value)))+(x235.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[10];
IkReal x236=IKsin(j2);
IkReal x237=IKcos(j2);
IkReal x238=(cj0*new_r22);
IkReal x239=(new_r22*sj0);
IkReal x240=((1.0)*sj0);
IkReal x241=((1.0)*x237);
IkReal x242=((1.0)*x236);
evalcond[0]=(((new_r11*sj0))+((new_r22*x236))+((cj0*new_r01)));
evalcond[1]=(((new_r11*x239))+((new_r01*x238))+x236);
evalcond[2]=((((-1.0)*new_r00*x240))+(((-1.0)*x242))+((cj0*new_r10)));
evalcond[3]=((((-1.0)*new_r01*x240))+(((-1.0)*x241))+((cj0*new_r11)));
evalcond[4]=(((sj0*x237))+new_r01+((x236*x238)));
evalcond[5]=(((new_r10*sj0))+(((-1.0)*new_r22*x241))+((cj0*new_r00)));
evalcond[6]=(((sj0*x236))+(((-1.0)*x238*x241))+new_r00);
evalcond[7]=((((-1.0)*cj0*x241))+new_r11+((x236*x239)));
evalcond[8]=(((new_r10*x239))+((new_r00*x238))+(((-1.0)*x241)));
evalcond[9]=((((-1.0)*cj0*x242))+new_r10+(((-1.0)*x239*x241)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0, j2]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
CheckValue<IkReal> x244=IKPowWithIntegerCheck(sj1,-1);
if(!x244.valid){
continue;
}
IkReal x243=x244.value;
CheckValue<IkReal> x245=IKPowWithIntegerCheck(new_r12,-1);
if(!x245.valid){
continue;
}
if( IKabs((x243*(x245.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj1*cj1))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r02*x243)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x243*(x245.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj1*cj1)))))))+IKsqr((new_r02*x243))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0array[0]=IKatan2((x243*(x245.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj1*cj1)))))), (new_r02*x243));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[8];
IkReal x246=IKcos(j0);
IkReal x247=IKsin(j0);
IkReal x248=((1.0)*cj1);
IkReal x249=((1.0)*sj1);
IkReal x250=(new_r12*x247);
IkReal x251=(new_r02*x246);
evalcond[0]=(new_r02+(((-1.0)*x246*x249)));
evalcond[1]=(new_r12+(((-1.0)*x247*x249)));
evalcond[2]=(((new_r12*x246))+(((-1.0)*new_r02*x247)));
evalcond[3]=(x250+x251+(((-1.0)*x249)));
evalcond[4]=(((cj1*x250))+((cj1*x251))+(((-1.0)*new_r22*x249)));
evalcond[5]=((((-1.0)*new_r20*x248))+(((-1.0)*new_r10*x247*x249))+(((-1.0)*new_r00*x246*x249)));
evalcond[6]=((((-1.0)*new_r01*x246*x249))+(((-1.0)*new_r21*x248))+(((-1.0)*new_r11*x247*x249)));
evalcond[7]=((1.0)+(((-1.0)*new_r22*x248))+(((-1.0)*x249*x250))+(((-1.0)*x249*x251)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j2eval[3];
j2eval[0]=sj1;
j2eval[1]=IKsign(sj1);
j2eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
j2eval[0]=sj0;
j2eval[1]=sj1;
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal j2eval[3];
j2eval[0]=cj0;
j2eval[1]=cj1;
j2eval[2]=sj1;
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j0)))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[3];
sj0=1.0;
cj0=0;
j0=1.5707963267949;
j2eval[0]=sj1;
j2eval[1]=IKsign(sj1);
j2eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[3];
sj0=1.0;
cj0=0;
j0=1.5707963267949;
j2eval[0]=cj1;
j2eval[1]=IKsign(cj1);
j2eval[2]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[1];
sj0=1.0;
cj0=0;
j0=1.5707963267949;
j2eval[0]=sj1;
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j1))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r12;
evalcond[3]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r11))+IKsqr(new_r10)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r11), new_r10);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x252=IKsin(j2);
IkReal x253=((1.0)*(IKcos(j2)));
evalcond[0]=(x252+new_r11);
evalcond[1]=(new_r10+(((-1.0)*x253)));
evalcond[2]=((((-1.0)*new_r00))+(((-1.0)*x252)));
evalcond[3]=((((-1.0)*new_r01))+(((-1.0)*x253)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j1)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r12;
evalcond[3]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r11)+IKsqr(((-1.0)*new_r10))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(new_r11, ((-1.0)*new_r10));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x254=IKcos(j2);
IkReal x255=((1.0)*(IKsin(j2)));
evalcond[0]=(x254+new_r10);
evalcond[1]=(new_r11+(((-1.0)*x255)));
evalcond[2]=((((-1.0)*new_r00))+(((-1.0)*x255)));
evalcond[3]=((((-1.0)*new_r01))+(((-1.0)*x254)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j1)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r11;
evalcond[3]=new_r10;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x256=IKcos(j2);
IkReal x257=((1.0)*(IKsin(j2)));
evalcond[0]=(x256+new_r20);
evalcond[1]=(new_r21+(((-1.0)*x257)));
evalcond[2]=((((-1.0)*new_r00))+(((-1.0)*x257)));
evalcond[3]=((((-1.0)*new_r01))+(((-1.0)*x256)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j1)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r11;
evalcond[3]=new_r10;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x258=IKsin(j2);
IkReal x259=((1.0)*(IKcos(j2)));
evalcond[0]=(x258+new_r21);
evalcond[1]=(new_r20+(((-1.0)*x259)));
evalcond[2]=((((-1.0)*new_r00))+(((-1.0)*x258)));
evalcond[3]=((((-1.0)*new_r01))+(((-1.0)*x259)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x260=IKsin(j2);
IkReal x261=IKcos(j2);
IkReal x262=((-1.0)*x261);
evalcond[0]=x260;
evalcond[1]=(new_r22*x260);
evalcond[2]=x262;
evalcond[3]=(new_r22*x262);
evalcond[4]=((((-1.0)*x260))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x261))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j2]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x263=IKPowWithIntegerCheck(sj1,-1);
if(!x263.valid){
continue;
}
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*(x263.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r20*(x263.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r20*(x263.value)));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x264=IKsin(j2);
IkReal x265=IKcos(j2);
IkReal x266=((1.0)*sj1);
IkReal x267=((1.0)*x265);
evalcond[0]=(new_r20+((sj1*x265)));
evalcond[1]=(((cj1*x264))+new_r11);
evalcond[2]=(new_r21+(((-1.0)*x264*x266)));
evalcond[3]=((((-1.0)*cj1*x267))+new_r10);
evalcond[4]=((((-1.0)*x264))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*new_r01))+(((-1.0)*x267)));
evalcond[6]=(((cj1*new_r11))+(((-1.0)*new_r21*x266))+x264);
evalcond[7]=(((cj1*new_r10))+(((-1.0)*new_r20*x266))+(((-1.0)*x267)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x268=IKPowWithIntegerCheck(IKsign(cj1),-1);
if(!x268.valid){
continue;
}
CheckValue<IkReal> x269 = IKatan2WithCheck(IkReal(((-1.0)*new_r11)),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x269.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x268.value)))+(x269.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x270=IKsin(j2);
IkReal x271=IKcos(j2);
IkReal x272=((1.0)*sj1);
IkReal x273=((1.0)*x271);
evalcond[0]=(new_r20+((sj1*x271)));
evalcond[1]=(((cj1*x270))+new_r11);
evalcond[2]=((((-1.0)*x270*x272))+new_r21);
evalcond[3]=((((-1.0)*cj1*x273))+new_r10);
evalcond[4]=((((-1.0)*x270))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x273))+(((-1.0)*new_r01)));
evalcond[6]=(((cj1*new_r11))+(((-1.0)*new_r21*x272))+x270);
evalcond[7]=(((cj1*new_r10))+(((-1.0)*new_r20*x272))+(((-1.0)*x273)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x274=IKPowWithIntegerCheck(IKsign(sj1),-1);
if(!x274.valid){
continue;
}
CheckValue<IkReal> x275 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x275.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x274.value)))+(x275.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x276=IKsin(j2);
IkReal x277=IKcos(j2);
IkReal x278=((1.0)*sj1);
IkReal x279=((1.0)*x277);
evalcond[0]=(new_r20+((sj1*x277)));
evalcond[1]=(((cj1*x276))+new_r11);
evalcond[2]=(new_r21+(((-1.0)*x276*x278)));
evalcond[3]=((((-1.0)*cj1*x279))+new_r10);
evalcond[4]=((((-1.0)*x276))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x279))+(((-1.0)*new_r01)));
evalcond[6]=(((cj1*new_r11))+(((-1.0)*new_r21*x278))+x276);
evalcond[7]=(((cj1*new_r10))+(((-1.0)*new_r20*x278))+(((-1.0)*x279)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j0)))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(new_r00, new_r01);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x280=IKcos(j2);
IkReal x281=IKsin(j2);
IkReal x282=((1.0)*sj1);
IkReal x283=((1.0)*new_r11);
IkReal x284=((1.0)*new_r10);
IkReal x285=((1.0)*x280);
evalcond[0]=(new_r20+((sj1*x280)));
evalcond[1]=((((-1.0)*x281))+new_r00);
evalcond[2]=((((-1.0)*x285))+new_r01);
evalcond[3]=((((-1.0)*x281*x282))+new_r21);
evalcond[4]=((((-1.0)*x283))+((cj1*x281)));
evalcond[5]=((((-1.0)*cj1*x285))+(((-1.0)*x284)));
evalcond[6]=(x281+(((-1.0)*cj1*x283))+(((-1.0)*new_r21*x282)));
evalcond[7]=((((-1.0)*cj1*x284))+(((-1.0)*x285))+(((-1.0)*new_r20*x282)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j1)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x286=IKcos(j2);
IkReal x287=IKsin(j2);
IkReal x288=((1.0)*sj0);
IkReal x289=((1.0)*x287);
IkReal x290=((1.0)*x286);
evalcond[0]=(x286+new_r20);
evalcond[1]=((((-1.0)*x289))+new_r21);
evalcond[2]=(((sj0*x286))+new_r01);
evalcond[3]=(((sj0*x287))+new_r00);
evalcond[4]=((((-1.0)*cj0*x290))+new_r11);
evalcond[5]=((((-1.0)*new_r02*x289))+new_r10);
evalcond[6]=((((-1.0)*new_r00*x288))+(((-1.0)*x289))+((cj0*new_r10)));
evalcond[7]=((((-1.0)*x290))+(((-1.0)*new_r01*x288))+((cj0*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j1)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x291=IKcos(j2);
IkReal x292=IKsin(j2);
IkReal x293=((1.0)*sj0);
IkReal x294=((1.0)*x291);
evalcond[0]=(x292+new_r21);
evalcond[1]=((((-1.0)*x294))+new_r20);
evalcond[2]=(((sj0*x291))+new_r01);
evalcond[3]=(((sj0*x292))+new_r00);
evalcond[4]=(((new_r02*x292))+new_r10);
evalcond[5]=((((-1.0)*cj0*x294))+new_r11);
evalcond[6]=((((-1.0)*x292))+((cj0*new_r10))+(((-1.0)*new_r00*x293)));
evalcond[7]=((((-1.0)*new_r01*x293))+(((-1.0)*x294))+((cj0*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j1))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x295=((1.0)*new_r01);
if( IKabs(((((-1.0)*cj0*x295))+(((-1.0)*new_r00*sj0)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*sj0*x295))+((cj0*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj0*x295))+(((-1.0)*new_r00*sj0))))+IKsqr(((((-1.0)*sj0*x295))+((cj0*new_r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*cj0*x295))+(((-1.0)*new_r00*sj0))), ((((-1.0)*sj0*x295))+((cj0*new_r00))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x296=IKsin(j2);
IkReal x297=IKcos(j2);
IkReal x298=((1.0)*sj0);
IkReal x299=((1.0)*x297);
IkReal x300=(sj0*x296);
IkReal x301=(cj0*x296);
IkReal x302=(cj0*x299);
evalcond[0]=(((new_r11*sj0))+x296+((cj0*new_r01)));
evalcond[1]=(((sj0*x297))+x301+new_r01);
evalcond[2]=(((new_r10*sj0))+(((-1.0)*x299))+((cj0*new_r00)));
evalcond[3]=((((-1.0)*x296))+((cj0*new_r10))+(((-1.0)*new_r00*x298)));
evalcond[4]=((((-1.0)*new_r01*x298))+(((-1.0)*x299))+((cj0*new_r11)));
evalcond[5]=(x300+new_r00+(((-1.0)*x302)));
evalcond[6]=(x300+new_r11+(((-1.0)*x302)));
evalcond[7]=((((-1.0)*x297*x298))+(((-1.0)*x301))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j1)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x303=((1.0)*sj0);
if( IKabs((((cj0*new_r01))+(((-1.0)*new_r00*x303)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj0*new_r00))+(((-1.0)*new_r01*x303)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj0*new_r01))+(((-1.0)*new_r00*x303))))+IKsqr(((((-1.0)*cj0*new_r00))+(((-1.0)*new_r01*x303))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((((cj0*new_r01))+(((-1.0)*new_r00*x303))), ((((-1.0)*cj0*new_r00))+(((-1.0)*new_r01*x303))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x304=IKsin(j2);
IkReal x305=IKcos(j2);
IkReal x306=((1.0)*sj0);
IkReal x307=((1.0)*x304);
IkReal x308=(sj0*x305);
IkReal x309=((1.0)*x305);
IkReal x310=(cj0*x307);
evalcond[0]=(((new_r10*sj0))+x305+((cj0*new_r00)));
evalcond[1]=(((new_r11*sj0))+((cj0*new_r01))+(((-1.0)*x307)));
evalcond[2]=(((cj0*x305))+((sj0*x304))+new_r00);
evalcond[3]=((((-1.0)*new_r00*x306))+((cj0*new_r10))+(((-1.0)*x307)));
evalcond[4]=((((-1.0)*new_r01*x306))+((cj0*new_r11))+(((-1.0)*x309)));
evalcond[5]=(x308+(((-1.0)*x310))+new_r01);
evalcond[6]=(x308+(((-1.0)*x310))+new_r10);
evalcond[7]=((((-1.0)*cj0*x309))+(((-1.0)*x304*x306))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j0))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(new_r10, new_r11);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x311=IKcos(j2);
IkReal x312=IKsin(j2);
IkReal x313=((1.0)*sj1);
IkReal x314=((1.0)*x311);
evalcond[0]=(((sj1*x311))+new_r20);
evalcond[1]=((((-1.0)*x312))+new_r10);
evalcond[2]=((((-1.0)*x314))+new_r11);
evalcond[3]=(((cj1*x312))+new_r01);
evalcond[4]=((((-1.0)*x312*x313))+new_r21);
evalcond[5]=((((-1.0)*cj1*x314))+new_r00);
evalcond[6]=((((-1.0)*new_r21*x313))+((cj1*new_r01))+x312);
evalcond[7]=((((-1.0)*new_r20*x313))+((cj1*new_r00))+(((-1.0)*x314)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j0)))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[3];
sj0=0;
cj0=-1.0;
j0=3.14159265358979;
j2eval[0]=sj1;
j2eval[1]=IKsign(sj1);
j2eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[1];
sj0=0;
cj0=-1.0;
j0=3.14159265358979;
j2eval[0]=sj1;
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
sj0=0;
cj0=-1.0;
j0=3.14159265358979;
j2eval[0]=cj1;
j2eval[1]=sj1;
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j1)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r01;
evalcond[3]=new_r00;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x315=IKcos(j2);
IkReal x316=((1.0)*(IKsin(j2)));
evalcond[0]=(x315+new_r20);
evalcond[1]=((((-1.0)*x316))+new_r21);
evalcond[2]=((((-1.0)*x316))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*new_r11))+(((-1.0)*x315)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j1)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r01;
evalcond[3]=new_r00;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x317=IKsin(j2);
IkReal x318=((1.0)*(IKcos(j2)));
evalcond[0]=(x317+new_r21);
evalcond[1]=((((-1.0)*x318))+new_r20);
evalcond[2]=((((-1.0)*new_r10))+(((-1.0)*x317)));
evalcond[3]=((((-1.0)*x318))+(((-1.0)*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j1))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(new_r01, ((-1.0)*new_r11));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x319=IKsin(j2);
IkReal x320=((1.0)*(IKcos(j2)));
evalcond[0]=(x319+(((-1.0)*new_r01)));
evalcond[1]=((((-1.0)*new_r10))+(((-1.0)*x319)));
evalcond[2]=((((-1.0)*x320))+(((-1.0)*new_r11)));
evalcond[3]=((((-1.0)*x320))+(((-1.0)*new_r00)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j1)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r10), new_r00);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x321=IKcos(j2);
IkReal x322=((1.0)*(IKsin(j2)));
evalcond[0]=(x321+(((-1.0)*new_r00)));
evalcond[1]=((((-1.0)*x322))+(((-1.0)*new_r10)));
evalcond[2]=((((-1.0)*x321))+(((-1.0)*new_r11)));
evalcond[3]=((((-1.0)*x322))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r11));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x323=IKsin(j2);
IkReal x324=IKcos(j2);
IkReal x325=((-1.0)*x324);
evalcond[0]=x323;
evalcond[1]=(new_r22*x323);
evalcond[2]=x325;
evalcond[3]=(new_r22*x325);
evalcond[4]=((((-1.0)*x323))+(((-1.0)*new_r10)));
evalcond[5]=((((-1.0)*x324))+(((-1.0)*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j2]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x326=IKPowWithIntegerCheck(cj1,-1);
if(!x326.valid){
continue;
}
CheckValue<IkReal> x327=IKPowWithIntegerCheck(sj1,-1);
if(!x327.valid){
continue;
}
if( IKabs((new_r01*(x326.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*(x327.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r01*(x326.value)))+IKsqr(((-1.0)*new_r20*(x327.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((new_r01*(x326.value)), ((-1.0)*new_r20*(x327.value)));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x328=IKsin(j2);
IkReal x329=IKcos(j2);
IkReal x330=((1.0)*new_r00);
IkReal x331=((1.0)*sj1);
IkReal x332=((1.0)*new_r01);
IkReal x333=((1.0)*x329);
evalcond[0]=(((sj1*x329))+new_r20);
evalcond[1]=((((-1.0)*x328*x331))+new_r21);
evalcond[2]=((((-1.0)*x328))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*new_r11))+(((-1.0)*x333)));
evalcond[4]=(((cj1*x328))+(((-1.0)*x332)));
evalcond[5]=((((-1.0)*x330))+(((-1.0)*cj1*x333)));
evalcond[6]=((((-1.0)*new_r21*x331))+x328+(((-1.0)*cj1*x332)));
evalcond[7]=((((-1.0)*new_r20*x331))+(((-1.0)*x333))+(((-1.0)*cj1*x330)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x334=IKPowWithIntegerCheck(sj1,-1);
if(!x334.valid){
continue;
}
if( IKabs((new_r21*(x334.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r21*(x334.value)))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((new_r21*(x334.value)), ((-1.0)*new_r11));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x335=IKsin(j2);
IkReal x336=IKcos(j2);
IkReal x337=((1.0)*new_r00);
IkReal x338=((1.0)*sj1);
IkReal x339=((1.0)*new_r01);
IkReal x340=((1.0)*x336);
evalcond[0]=(new_r20+((sj1*x336)));
evalcond[1]=(new_r21+(((-1.0)*x335*x338)));
evalcond[2]=((((-1.0)*x335))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*new_r11))+(((-1.0)*x340)));
evalcond[4]=(((cj1*x335))+(((-1.0)*x339)));
evalcond[5]=((((-1.0)*cj1*x340))+(((-1.0)*x337)));
evalcond[6]=((((-1.0)*new_r21*x338))+x335+(((-1.0)*cj1*x339)));
evalcond[7]=((((-1.0)*new_r20*x338))+(((-1.0)*cj1*x337))+(((-1.0)*x340)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x341=IKPowWithIntegerCheck(IKsign(sj1),-1);
if(!x341.valid){
continue;
}
CheckValue<IkReal> x342 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x342.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x341.value)))+(x342.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x343=IKsin(j2);
IkReal x344=IKcos(j2);
IkReal x345=((1.0)*new_r00);
IkReal x346=((1.0)*sj1);
IkReal x347=((1.0)*new_r01);
IkReal x348=((1.0)*x344);
evalcond[0]=(((sj1*x344))+new_r20);
evalcond[1]=((((-1.0)*x343*x346))+new_r21);
evalcond[2]=((((-1.0)*new_r10))+(((-1.0)*x343)));
evalcond[3]=((((-1.0)*new_r11))+(((-1.0)*x348)));
evalcond[4]=(((cj1*x343))+(((-1.0)*x347)));
evalcond[5]=((((-1.0)*cj1*x348))+(((-1.0)*x345)));
evalcond[6]=((((-1.0)*cj1*x347))+x343+(((-1.0)*new_r21*x346)));
evalcond[7]=((((-1.0)*cj1*x345))+(((-1.0)*new_r20*x346))+(((-1.0)*x348)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[1];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
j2eval[0]=IKabs(new_r22);
if( IKabs(j2eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j2]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
op[0]=new_r22;
op[1]=0;
op[2]=((-1.0)*new_r22);
polyroots2(op,zeror,numroots);
IkReal j2array[2], cj2array[2], sj2array[2], tempj2array[1];
int numsolutions = 0;
for(int ij2 = 0; ij2 < numroots; ++ij2)
{
IkReal htj2 = zeror[ij2];
tempj2array[0]=((2.0)*(atan(htj2)));
for(int kj2 = 0; kj2 < 1; ++kj2)
{
j2array[numsolutions] = tempj2array[kj2];
if( j2array[numsolutions] > IKPI )
{
    j2array[numsolutions]-=IK2PI;
}
else if( j2array[numsolutions] < -IKPI )
{
    j2array[numsolutions]+=IK2PI;
}
sj2array[numsolutions] = IKsin(j2array[numsolutions]);
cj2array[numsolutions] = IKcos(j2array[numsolutions]);
numsolutions++;
}
}
bool j2valid[2]={true,true};
_nj2 = 2;
for(int ij2 = 0; ij2 < numsolutions; ++ij2)
    {
if( !j2valid[ij2] )
{
    continue;
}
    j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
htj2 = IKtan(j2/2);

_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < numsolutions; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j2]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x350=IKPowWithIntegerCheck(sj1,-1);
if(!x350.valid){
continue;
}
IkReal x349=x350.value;
CheckValue<IkReal> x351=IKPowWithIntegerCheck(cj0,-1);
if(!x351.valid){
continue;
}
CheckValue<IkReal> x352=IKPowWithIntegerCheck(cj1,-1);
if(!x352.valid){
continue;
}
if( IKabs((x349*(x351.value)*(x352.value)*((((new_r20*sj0))+(((-1.0)*new_r01*sj1)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x349)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x349*(x351.value)*(x352.value)*((((new_r20*sj0))+(((-1.0)*new_r01*sj1))))))+IKsqr(((-1.0)*new_r20*x349))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((x349*(x351.value)*(x352.value)*((((new_r20*sj0))+(((-1.0)*new_r01*sj1))))), ((-1.0)*new_r20*x349));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[12];
IkReal x353=IKsin(j2);
IkReal x354=IKcos(j2);
IkReal x355=((1.0)*sj1);
IkReal x356=((1.0)*sj0);
IkReal x357=(cj0*new_r00);
IkReal x358=(cj0*cj1);
IkReal x359=(new_r11*sj0);
IkReal x360=(new_r10*sj0);
IkReal x361=((1.0)*x354);
IkReal x362=(cj1*x353);
IkReal x363=((1.0)*x353);
evalcond[0]=(((sj1*x354))+new_r20);
evalcond[1]=((((-1.0)*x353*x355))+new_r21);
evalcond[2]=(x359+x362+((cj0*new_r01)));
evalcond[3]=((((-1.0)*x363))+(((-1.0)*new_r00*x356))+((cj0*new_r10)));
evalcond[4]=((((-1.0)*x361))+(((-1.0)*new_r01*x356))+((cj0*new_r11)));
evalcond[5]=(((x353*x358))+((sj0*x354))+new_r01);
evalcond[6]=((((-1.0)*cj1*x361))+x357+x360);
evalcond[7]=((((-1.0)*x358*x361))+((sj0*x353))+new_r00);
evalcond[8]=(((sj0*x362))+new_r11+(((-1.0)*cj0*x361)));
evalcond[9]=((((-1.0)*cj1*x354*x356))+new_r10+(((-1.0)*cj0*x363)));
evalcond[10]=(((new_r01*x358))+((cj1*x359))+x353+(((-1.0)*new_r21*x355)));
evalcond[11]=(((cj1*x357))+(((-1.0)*x361))+((cj1*x360))+(((-1.0)*new_r20*x355)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x365=IKPowWithIntegerCheck(sj1,-1);
if(!x365.valid){
continue;
}
IkReal x364=x365.value;
CheckValue<IkReal> x366=IKPowWithIntegerCheck(sj0,-1);
if(!x366.valid){
continue;
}
if( IKabs((x364*(x366.value)*(((((-1.0)*cj0*cj1*new_r20))+(((-1.0)*new_r00*sj1)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x364)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x364*(x366.value)*(((((-1.0)*cj0*cj1*new_r20))+(((-1.0)*new_r00*sj1))))))+IKsqr(((-1.0)*new_r20*x364))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((x364*(x366.value)*(((((-1.0)*cj0*cj1*new_r20))+(((-1.0)*new_r00*sj1))))), ((-1.0)*new_r20*x364));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[12];
IkReal x367=IKsin(j2);
IkReal x368=IKcos(j2);
IkReal x369=((1.0)*sj1);
IkReal x370=((1.0)*sj0);
IkReal x371=(cj0*new_r00);
IkReal x372=(cj0*cj1);
IkReal x373=(new_r11*sj0);
IkReal x374=(new_r10*sj0);
IkReal x375=((1.0)*x368);
IkReal x376=(cj1*x367);
IkReal x377=((1.0)*x367);
evalcond[0]=(((sj1*x368))+new_r20);
evalcond[1]=((((-1.0)*x367*x369))+new_r21);
evalcond[2]=(x376+x373+((cj0*new_r01)));
evalcond[3]=((((-1.0)*new_r00*x370))+(((-1.0)*x377))+((cj0*new_r10)));
evalcond[4]=((((-1.0)*x375))+((cj0*new_r11))+(((-1.0)*new_r01*x370)));
evalcond[5]=(((x367*x372))+((sj0*x368))+new_r01);
evalcond[6]=((((-1.0)*cj1*x375))+x374+x371);
evalcond[7]=((((-1.0)*x372*x375))+((sj0*x367))+new_r00);
evalcond[8]=(((sj0*x376))+new_r11+(((-1.0)*cj0*x375)));
evalcond[9]=((((-1.0)*cj1*x368*x370))+new_r10+(((-1.0)*cj0*x377)));
evalcond[10]=(((new_r01*x372))+x367+((cj1*x373))+(((-1.0)*new_r21*x369)));
evalcond[11]=((((-1.0)*new_r20*x369))+(((-1.0)*x375))+((cj1*x374))+((cj1*x371)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x378=IKPowWithIntegerCheck(IKsign(sj1),-1);
if(!x378.valid){
continue;
}
CheckValue<IkReal> x379 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x379.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x378.value)))+(x379.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[12];
IkReal x380=IKsin(j2);
IkReal x381=IKcos(j2);
IkReal x382=((1.0)*sj1);
IkReal x383=((1.0)*sj0);
IkReal x384=(cj0*new_r00);
IkReal x385=(cj0*cj1);
IkReal x386=(new_r11*sj0);
IkReal x387=(new_r10*sj0);
IkReal x388=((1.0)*x381);
IkReal x389=(cj1*x380);
IkReal x390=((1.0)*x380);
evalcond[0]=(new_r20+((sj1*x381)));
evalcond[1]=((((-1.0)*x380*x382))+new_r21);
evalcond[2]=(x386+x389+((cj0*new_r01)));
evalcond[3]=((((-1.0)*x390))+(((-1.0)*new_r00*x383))+((cj0*new_r10)));
evalcond[4]=((((-1.0)*new_r01*x383))+(((-1.0)*x388))+((cj0*new_r11)));
evalcond[5]=(new_r01+((sj0*x381))+((x380*x385)));
evalcond[6]=((((-1.0)*cj1*x388))+x387+x384);
evalcond[7]=(new_r00+((sj0*x380))+(((-1.0)*x385*x388)));
evalcond[8]=((((-1.0)*cj0*x388))+new_r11+((sj0*x389)));
evalcond[9]=((((-1.0)*cj0*x390))+(((-1.0)*cj1*x381*x383))+new_r10);
evalcond[10]=(((cj1*x386))+((new_r01*x385))+x380+(((-1.0)*new_r21*x382)));
evalcond[11]=(((cj1*x387))+((cj1*x384))+(((-1.0)*new_r20*x382))+(((-1.0)*x388)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x391=IKPowWithIntegerCheck(IKsign(sj1),-1);
if(!x391.valid){
continue;
}
CheckValue<IkReal> x392 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x392.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x391.value)))+(x392.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[2];
evalcond[0]=(((sj1*(IKcos(j2))))+new_r20);
evalcond[1]=((((-1.0)*sj1*(IKsin(j2))))+new_r21);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0eval[3];
j0eval[0]=sj1;
j0eval[1]=((IKabs(new_r12))+(IKabs(new_r02)));
j0eval[2]=IKsign(sj1);
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[2];
j0eval[0]=cj2;
j0eval[1]=sj1;
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j2)))), 6.28318530717959)));
evalcond[1]=new_r20;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(new_r10)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0array[0]=IKatan2(((-1.0)*new_r00), new_r10);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[18];
IkReal x393=IKsin(j0);
IkReal x394=IKcos(j0);
IkReal x395=((1.0)*sj1);
IkReal x396=((1.0)*cj1);
IkReal x397=(new_r10*x393);
IkReal x398=(new_r01*x394);
IkReal x399=(new_r00*x394);
IkReal x400=((1.0)*x393);
IkReal x401=(new_r11*x393);
IkReal x402=(new_r12*x393);
IkReal x403=(cj1*x394);
IkReal x404=(new_r02*x394);
evalcond[0]=(x393+new_r00);
evalcond[1]=(x403+new_r01);
evalcond[2]=(((cj1*x393))+new_r11);
evalcond[3]=((((-1.0)*x394))+new_r10);
evalcond[4]=((((-1.0)*x394*x395))+new_r02);
evalcond[5]=(new_r12+(((-1.0)*x393*x395)));
evalcond[6]=(x397+x399);
evalcond[7]=((((-1.0)*new_r02*x400))+((new_r12*x394)));
evalcond[8]=(((new_r11*x394))+(((-1.0)*new_r01*x400)));
evalcond[9]=(cj1+x398+x401);
evalcond[10]=((-1.0)+(((-1.0)*new_r00*x400))+((new_r10*x394)));
evalcond[11]=(((cj1*x397))+((cj1*x399)));
evalcond[12]=((((-1.0)*x395))+x402+x404);
evalcond[13]=((((-1.0)*x395*x397))+(((-1.0)*x395*x399)));
evalcond[14]=((((-1.0)*new_r22*x395))+((cj1*x402))+((new_r02*x403)));
evalcond[15]=((1.0)+(((-1.0)*new_r21*x395))+((cj1*x398))+((cj1*x401)));
evalcond[16]=((((-1.0)*new_r21*x396))+(((-1.0)*x395*x398))+(((-1.0)*x395*x401)));
evalcond[17]=((1.0)+(((-1.0)*new_r22*x396))+(((-1.0)*x395*x404))+(((-1.0)*x395*x402)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j2)))), 6.28318530717959)));
evalcond[1]=new_r20;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(((-1.0)*new_r10))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0array[0]=IKatan2(new_r00, ((-1.0)*new_r10));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[18];
IkReal x405=IKcos(j0);
IkReal x406=IKsin(j0);
IkReal x407=((1.0)*sj1);
IkReal x408=((1.0)*cj1);
IkReal x409=(new_r10*x406);
IkReal x410=(new_r01*x405);
IkReal x411=(new_r00*x405);
IkReal x412=((1.0)*x406);
IkReal x413=(new_r11*x406);
IkReal x414=(new_r12*x406);
IkReal x415=(new_r02*x405);
evalcond[0]=(x405+new_r10);
evalcond[1]=(new_r00+(((-1.0)*x412)));
evalcond[2]=(new_r02+(((-1.0)*x405*x407)));
evalcond[3]=((((-1.0)*x406*x407))+new_r12);
evalcond[4]=(new_r01+(((-1.0)*x405*x408)));
evalcond[5]=((((-1.0)*x406*x408))+new_r11);
evalcond[6]=(x409+x411);
evalcond[7]=(((new_r12*x405))+(((-1.0)*new_r02*x412)));
evalcond[8]=(((new_r11*x405))+(((-1.0)*new_r01*x412)));
evalcond[9]=((1.0)+((new_r10*x405))+(((-1.0)*new_r00*x412)));
evalcond[10]=(((cj1*x409))+((cj1*x411)));
evalcond[11]=(x414+x415+(((-1.0)*x407)));
evalcond[12]=(x413+x410+(((-1.0)*x408)));
evalcond[13]=((((-1.0)*x407*x409))+(((-1.0)*x407*x411)));
evalcond[14]=(((cj1*x414))+((cj1*x415))+(((-1.0)*new_r22*x407)));
evalcond[15]=((-1.0)+(sj1*sj1)+((cj1*x413))+((cj1*x410)));
evalcond[16]=((((-1.0)*new_r21*x408))+(((-1.0)*x407*x413))+(((-1.0)*x407*x410)));
evalcond[17]=((1.0)+(((-1.0)*x407*x414))+(((-1.0)*x407*x415))+(((-1.0)*new_r22*x408)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j1))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x416=((1.0)*sj2);
if( IKabs(((((-1.0)*cj2*new_r01))+(((-1.0)*new_r00*x416)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj2*new_r00))+(((-1.0)*new_r01*x416)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj2*new_r01))+(((-1.0)*new_r00*x416))))+IKsqr((((cj2*new_r00))+(((-1.0)*new_r01*x416))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0array[0]=IKatan2(((((-1.0)*cj2*new_r01))+(((-1.0)*new_r00*x416))), (((cj2*new_r00))+(((-1.0)*new_r01*x416))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[8];
IkReal x417=IKcos(j0);
IkReal x418=IKsin(j0);
IkReal x419=((1.0)*cj2);
IkReal x420=((1.0)*sj2);
IkReal x421=(sj2*x418);
IkReal x422=((1.0)*x418);
IkReal x423=(x417*x419);
evalcond[0]=(sj2+((new_r11*x418))+((new_r01*x417)));
evalcond[1]=(((sj2*x417))+new_r01+((cj2*x418)));
evalcond[2]=((((-1.0)*x423))+x421+new_r00);
evalcond[3]=((((-1.0)*x423))+x421+new_r11);
evalcond[4]=(((new_r10*x418))+(((-1.0)*x419))+((new_r00*x417)));
evalcond[5]=((((-1.0)*x418*x419))+(((-1.0)*x417*x420))+new_r10);
evalcond[6]=((((-1.0)*new_r00*x422))+(((-1.0)*x420))+((new_r10*x417)));
evalcond[7]=(((new_r11*x417))+(((-1.0)*x419))+(((-1.0)*new_r01*x422)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j1)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x424=((1.0)*new_r00);
if( IKabs(((((-1.0)*sj2*x424))+(((-1.0)*cj2*new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj2*x424))+((new_r01*sj2)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*sj2*x424))+(((-1.0)*cj2*new_r01))))+IKsqr(((((-1.0)*cj2*x424))+((new_r01*sj2))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0array[0]=IKatan2(((((-1.0)*sj2*x424))+(((-1.0)*cj2*new_r01))), ((((-1.0)*cj2*x424))+((new_r01*sj2))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[8];
IkReal x425=IKcos(j0);
IkReal x426=IKsin(j0);
IkReal x427=((1.0)*sj2);
IkReal x428=(cj2*x426);
IkReal x429=(sj2*x426);
IkReal x430=((1.0)*x425);
IkReal x431=((1.0)*x426);
IkReal x432=(x425*x427);
evalcond[0]=(cj2+((new_r10*x426))+((new_r00*x425)));
evalcond[1]=(x429+((cj2*x425))+new_r00);
evalcond[2]=((((-1.0)*x432))+x428+new_r01);
evalcond[3]=((((-1.0)*x432))+x428+new_r10);
evalcond[4]=((((-1.0)*x427))+((new_r11*x426))+((new_r01*x425)));
evalcond[5]=((((-1.0)*cj2*x430))+(((-1.0)*x426*x427))+new_r11);
evalcond[6]=((((-1.0)*new_r00*x431))+(((-1.0)*x427))+((new_r10*x425)));
evalcond[7]=((((-1.0)*new_r01*x431))+((new_r11*x425))+(((-1.0)*cj2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r12))+(IKabs(new_r02)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j0eval[0]=((IKabs(new_r11))+(IKabs(new_r01)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal j0eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j0eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal j0eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j0eval[0]=((IKabs((new_r11*new_r22)))+(IKabs((new_r01*new_r22))));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j0]

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x434 = IKatan2WithCheck(IkReal((new_r01*new_r22)),IkReal((new_r11*new_r22)),IKFAST_ATAN2_MAGTHRESH);
if(!x434.valid){
continue;
}
IkReal x433=x434.value;
j0array[0]=((-1.0)*x433);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x433)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x435=IKcos(j0);
IkReal x436=IKsin(j0);
IkReal x437=(new_r10*x436);
IkReal x438=((1.0)*x436);
IkReal x439=(new_r00*x435);
evalcond[0]=(((new_r01*x435))+((new_r11*x436)));
evalcond[1]=(x439+x437);
evalcond[2]=((((-1.0)*new_r00*x438))+((new_r10*x435)));
evalcond[3]=((((-1.0)*new_r01*x438))+((new_r11*x435)));
evalcond[4]=(((new_r22*x439))+((new_r22*x437)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x441 = IKatan2WithCheck(IkReal(new_r00),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x441.valid){
continue;
}
IkReal x440=x441.value;
j0array[0]=((-1.0)*x440);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x440)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x442=IKcos(j0);
IkReal x443=IKsin(j0);
IkReal x444=((1.0)*x443);
IkReal x445=(new_r11*x443);
IkReal x446=(new_r22*x442);
evalcond[0]=(((new_r01*x442))+x445);
evalcond[1]=((((-1.0)*new_r00*x444))+((new_r10*x442)));
evalcond[2]=((((-1.0)*new_r01*x444))+((new_r11*x442)));
evalcond[3]=(((new_r22*x445))+((new_r01*x446)));
evalcond[4]=(((new_r00*x446))+((new_r10*new_r22*x443)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x448 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x448.valid){
continue;
}
IkReal x447=x448.value;
j0array[0]=((-1.0)*x447);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x447)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x449=IKcos(j0);
IkReal x450=IKsin(j0);
IkReal x451=(new_r10*x450);
IkReal x452=((1.0)*x450);
IkReal x453=(new_r00*x449);
evalcond[0]=(x453+x451);
evalcond[1]=((((-1.0)*new_r00*x452))+((new_r10*x449)));
evalcond[2]=((((-1.0)*new_r01*x452))+((new_r11*x449)));
evalcond[3]=(((new_r11*new_r22*x450))+((new_r01*new_r22*x449)));
evalcond[4]=(((new_r22*x453))+((new_r22*x451)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
CheckValue<IkReal> x455=IKPowWithIntegerCheck(sj1,-1);
if(!x455.valid){
continue;
}
IkReal x454=x455.value;
CheckValue<IkReal> x456=IKPowWithIntegerCheck(cj2,-1);
if(!x456.valid){
continue;
}
if( IKabs((x454*(x456.value)*(((((-1.0)*new_r01*sj1))+(((-1.0)*cj1*new_r02*sj2)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r02*x454)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x454*(x456.value)*(((((-1.0)*new_r01*sj1))+(((-1.0)*cj1*new_r02*sj2))))))+IKsqr((new_r02*x454))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0array[0]=IKatan2((x454*(x456.value)*(((((-1.0)*new_r01*sj1))+(((-1.0)*cj1*new_r02*sj2))))), (new_r02*x454));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[18];
IkReal x457=IKcos(j0);
IkReal x458=IKsin(j0);
IkReal x459=((1.0)*cj2);
IkReal x460=((1.0)*sj1);
IkReal x461=((1.0)*cj1);
IkReal x462=((1.0)*sj2);
IkReal x463=(new_r10*x458);
IkReal x464=(new_r01*x457);
IkReal x465=(new_r00*x457);
IkReal x466=((1.0)*x458);
IkReal x467=(new_r11*x458);
IkReal x468=(new_r12*x458);
IkReal x469=(sj2*x458);
IkReal x470=(cj1*x457);
IkReal x471=(cj2*x458);
IkReal x472=(new_r02*x457);
evalcond[0]=(new_r02+(((-1.0)*x457*x460)));
evalcond[1]=((((-1.0)*x458*x460))+new_r12);
evalcond[2]=(((new_r12*x457))+(((-1.0)*new_r02*x466)));
evalcond[3]=(x471+new_r01+((sj2*x470)));
evalcond[4]=((((-1.0)*x460))+x468+x472);
evalcond[5]=(((cj1*sj2))+x467+x464);
evalcond[6]=((((-1.0)*x459*x470))+x469+new_r00);
evalcond[7]=(((cj1*x469))+new_r11+(((-1.0)*x457*x459)));
evalcond[8]=(((new_r10*x457))+(((-1.0)*x462))+(((-1.0)*new_r00*x466)));
evalcond[9]=(((new_r11*x457))+(((-1.0)*new_r01*x466))+(((-1.0)*x459)));
evalcond[10]=((((-1.0)*cj1*x459))+x463+x465);
evalcond[11]=(new_r10+(((-1.0)*x457*x462))+(((-1.0)*cj1*x458*x459)));
evalcond[12]=(((cj1*x468))+(((-1.0)*new_r22*x460))+((new_r02*x470)));
evalcond[13]=((((-1.0)*new_r21*x460))+sj2+((cj1*x467))+((cj1*x464)));
evalcond[14]=((((-1.0)*new_r20*x461))+(((-1.0)*x460*x465))+(((-1.0)*x460*x463)));
evalcond[15]=((((-1.0)*new_r21*x461))+(((-1.0)*x460*x467))+(((-1.0)*x460*x464)));
evalcond[16]=((1.0)+(((-1.0)*x460*x472))+(((-1.0)*x460*x468))+(((-1.0)*new_r22*x461)));
evalcond[17]=((((-1.0)*new_r20*x460))+((cj1*x465))+((cj1*x463))+(((-1.0)*x459)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
CheckValue<IkReal> x473=IKPowWithIntegerCheck(IKsign(sj1),-1);
if(!x473.valid){
continue;
}
CheckValue<IkReal> x474 = IKatan2WithCheck(IkReal(new_r12),IkReal(new_r02),IKFAST_ATAN2_MAGTHRESH);
if(!x474.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x473.value)))+(x474.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[18];
IkReal x475=IKcos(j0);
IkReal x476=IKsin(j0);
IkReal x477=((1.0)*cj2);
IkReal x478=((1.0)*sj1);
IkReal x479=((1.0)*cj1);
IkReal x480=((1.0)*sj2);
IkReal x481=(new_r10*x476);
IkReal x482=(new_r01*x475);
IkReal x483=(new_r00*x475);
IkReal x484=((1.0)*x476);
IkReal x485=(new_r11*x476);
IkReal x486=(new_r12*x476);
IkReal x487=(sj2*x476);
IkReal x488=(cj1*x475);
IkReal x489=(cj2*x476);
IkReal x490=(new_r02*x475);
evalcond[0]=((((-1.0)*x475*x478))+new_r02);
evalcond[1]=((((-1.0)*x476*x478))+new_r12);
evalcond[2]=(((new_r12*x475))+(((-1.0)*new_r02*x484)));
evalcond[3]=(x489+((sj2*x488))+new_r01);
evalcond[4]=((((-1.0)*x478))+x486+x490);
evalcond[5]=(((cj1*sj2))+x482+x485);
evalcond[6]=(x487+(((-1.0)*x477*x488))+new_r00);
evalcond[7]=((((-1.0)*x475*x477))+((cj1*x487))+new_r11);
evalcond[8]=((((-1.0)*x480))+(((-1.0)*new_r00*x484))+((new_r10*x475)));
evalcond[9]=((((-1.0)*new_r01*x484))+((new_r11*x475))+(((-1.0)*x477)));
evalcond[10]=((((-1.0)*cj1*x477))+x481+x483);
evalcond[11]=((((-1.0)*x475*x480))+(((-1.0)*cj1*x476*x477))+new_r10);
evalcond[12]=(((new_r02*x488))+(((-1.0)*new_r22*x478))+((cj1*x486)));
evalcond[13]=(sj2+(((-1.0)*new_r21*x478))+((cj1*x482))+((cj1*x485)));
evalcond[14]=((((-1.0)*x478*x481))+(((-1.0)*x478*x483))+(((-1.0)*new_r20*x479)));
evalcond[15]=((((-1.0)*new_r21*x479))+(((-1.0)*x478*x482))+(((-1.0)*x478*x485)));
evalcond[16]=((1.0)+(((-1.0)*new_r22*x479))+(((-1.0)*x478*x490))+(((-1.0)*x478*x486)));
evalcond[17]=((((-1.0)*x477))+((cj1*x481))+((cj1*x483))+(((-1.0)*new_r20*x478)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
CheckValue<IkReal> x491=IKPowWithIntegerCheck(IKsign(sj1),-1);
if(!x491.valid){
continue;
}
CheckValue<IkReal> x492 = IKatan2WithCheck(IkReal(new_r12),IkReal(new_r02),IKFAST_ATAN2_MAGTHRESH);
if(!x492.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x491.value)))+(x492.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[8];
IkReal x493=IKcos(j0);
IkReal x494=IKsin(j0);
IkReal x495=((1.0)*cj1);
IkReal x496=((1.0)*sj1);
IkReal x497=(new_r12*x494);
IkReal x498=(new_r02*x493);
evalcond[0]=((((-1.0)*x493*x496))+new_r02);
evalcond[1]=((((-1.0)*x494*x496))+new_r12);
evalcond[2]=((((-1.0)*new_r02*x494))+((new_r12*x493)));
evalcond[3]=((((-1.0)*x496))+x498+x497);
evalcond[4]=((((-1.0)*new_r22*x496))+((cj1*x498))+((cj1*x497)));
evalcond[5]=((((-1.0)*new_r00*x493*x496))+(((-1.0)*new_r20*x495))+(((-1.0)*new_r10*x494*x496)));
evalcond[6]=((((-1.0)*new_r21*x495))+(((-1.0)*new_r01*x493*x496))+(((-1.0)*new_r11*x494*x496)));
evalcond[7]=((1.0)+(((-1.0)*x496*x497))+(((-1.0)*x496*x498))+(((-1.0)*new_r22*x495)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j2eval[3];
j2eval[0]=sj1;
j2eval[1]=IKsign(sj1);
j2eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
j2eval[0]=sj0;
j2eval[1]=sj1;
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal j2eval[3];
j2eval[0]=cj0;
j2eval[1]=cj1;
j2eval[2]=sj1;
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j0)))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[3];
sj0=1.0;
cj0=0;
j0=1.5707963267949;
j2eval[0]=sj1;
j2eval[1]=IKsign(sj1);
j2eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[3];
sj0=1.0;
cj0=0;
j0=1.5707963267949;
j2eval[0]=cj1;
j2eval[1]=IKsign(cj1);
j2eval[2]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[1];
sj0=1.0;
cj0=0;
j0=1.5707963267949;
j2eval[0]=sj1;
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j1))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r12;
evalcond[3]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r11))+IKsqr(new_r10)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r11), new_r10);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x499=IKsin(j2);
IkReal x500=((1.0)*(IKcos(j2)));
evalcond[0]=(x499+new_r11);
evalcond[1]=((((-1.0)*x500))+new_r10);
evalcond[2]=((((-1.0)*x499))+(((-1.0)*new_r00)));
evalcond[3]=((((-1.0)*x500))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j1)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r12;
evalcond[3]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r11)+IKsqr(((-1.0)*new_r10))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(new_r11, ((-1.0)*new_r10));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x501=IKcos(j2);
IkReal x502=((1.0)*(IKsin(j2)));
evalcond[0]=(x501+new_r10);
evalcond[1]=((((-1.0)*x502))+new_r11);
evalcond[2]=((((-1.0)*x502))+(((-1.0)*new_r00)));
evalcond[3]=((((-1.0)*new_r01))+(((-1.0)*x501)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j1)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r11;
evalcond[3]=new_r10;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x503=IKcos(j2);
IkReal x504=((1.0)*(IKsin(j2)));
evalcond[0]=(x503+new_r20);
evalcond[1]=((((-1.0)*x504))+new_r21);
evalcond[2]=((((-1.0)*x504))+(((-1.0)*new_r00)));
evalcond[3]=((((-1.0)*new_r01))+(((-1.0)*x503)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j1)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r11;
evalcond[3]=new_r10;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x505=IKsin(j2);
IkReal x506=((1.0)*(IKcos(j2)));
evalcond[0]=(x505+new_r21);
evalcond[1]=((((-1.0)*x506))+new_r20);
evalcond[2]=((((-1.0)*new_r00))+(((-1.0)*x505)));
evalcond[3]=((((-1.0)*x506))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x507=IKsin(j2);
IkReal x508=IKcos(j2);
IkReal x509=((-1.0)*x508);
evalcond[0]=x507;
evalcond[1]=(new_r22*x507);
evalcond[2]=x509;
evalcond[3]=(new_r22*x509);
evalcond[4]=((((-1.0)*new_r00))+(((-1.0)*x507)));
evalcond[5]=((((-1.0)*new_r01))+(((-1.0)*x508)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j2]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x510=IKPowWithIntegerCheck(sj1,-1);
if(!x510.valid){
continue;
}
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*(x510.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r20*(x510.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r20*(x510.value)));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x511=IKsin(j2);
IkReal x512=IKcos(j2);
IkReal x513=((1.0)*sj1);
IkReal x514=((1.0)*x512);
evalcond[0]=(new_r20+((sj1*x512)));
evalcond[1]=(((cj1*x511))+new_r11);
evalcond[2]=((((-1.0)*x511*x513))+new_r21);
evalcond[3]=((((-1.0)*cj1*x514))+new_r10);
evalcond[4]=((((-1.0)*x511))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*new_r01))+(((-1.0)*x514)));
evalcond[6]=(((cj1*new_r11))+x511+(((-1.0)*new_r21*x513)));
evalcond[7]=(((cj1*new_r10))+(((-1.0)*new_r20*x513))+(((-1.0)*x514)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x515=IKPowWithIntegerCheck(IKsign(cj1),-1);
if(!x515.valid){
continue;
}
CheckValue<IkReal> x516 = IKatan2WithCheck(IkReal(((-1.0)*new_r11)),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x516.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x515.value)))+(x516.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x517=IKsin(j2);
IkReal x518=IKcos(j2);
IkReal x519=((1.0)*sj1);
IkReal x520=((1.0)*x518);
evalcond[0]=(new_r20+((sj1*x518)));
evalcond[1]=(((cj1*x517))+new_r11);
evalcond[2]=((((-1.0)*x517*x519))+new_r21);
evalcond[3]=((((-1.0)*cj1*x520))+new_r10);
evalcond[4]=((((-1.0)*x517))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x520))+(((-1.0)*new_r01)));
evalcond[6]=(((cj1*new_r11))+x517+(((-1.0)*new_r21*x519)));
evalcond[7]=(((cj1*new_r10))+(((-1.0)*x520))+(((-1.0)*new_r20*x519)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x521=IKPowWithIntegerCheck(IKsign(sj1),-1);
if(!x521.valid){
continue;
}
CheckValue<IkReal> x522 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x522.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x521.value)))+(x522.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x523=IKsin(j2);
IkReal x524=IKcos(j2);
IkReal x525=((1.0)*sj1);
IkReal x526=((1.0)*x524);
evalcond[0]=(((sj1*x524))+new_r20);
evalcond[1]=(((cj1*x523))+new_r11);
evalcond[2]=((((-1.0)*x523*x525))+new_r21);
evalcond[3]=((((-1.0)*cj1*x526))+new_r10);
evalcond[4]=((((-1.0)*x523))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x526))+(((-1.0)*new_r01)));
evalcond[6]=(((cj1*new_r11))+(((-1.0)*new_r21*x525))+x523);
evalcond[7]=(((cj1*new_r10))+(((-1.0)*new_r20*x525))+(((-1.0)*x526)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j0)))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(new_r00, new_r01);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x527=IKcos(j2);
IkReal x528=IKsin(j2);
IkReal x529=((1.0)*sj1);
IkReal x530=((1.0)*new_r11);
IkReal x531=((1.0)*new_r10);
IkReal x532=((1.0)*x527);
evalcond[0]=(((sj1*x527))+new_r20);
evalcond[1]=((((-1.0)*x528))+new_r00);
evalcond[2]=((((-1.0)*x532))+new_r01);
evalcond[3]=((((-1.0)*x528*x529))+new_r21);
evalcond[4]=((((-1.0)*x530))+((cj1*x528)));
evalcond[5]=((((-1.0)*cj1*x532))+(((-1.0)*x531)));
evalcond[6]=((((-1.0)*cj1*x530))+(((-1.0)*new_r21*x529))+x528);
evalcond[7]=((((-1.0)*cj1*x531))+(((-1.0)*new_r20*x529))+(((-1.0)*x532)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j1)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x533=IKcos(j2);
IkReal x534=IKsin(j2);
IkReal x535=((1.0)*sj0);
IkReal x536=((1.0)*x534);
IkReal x537=((1.0)*x533);
evalcond[0]=(x533+new_r20);
evalcond[1]=((((-1.0)*x536))+new_r21);
evalcond[2]=(((sj0*x533))+new_r01);
evalcond[3]=(((sj0*x534))+new_r00);
evalcond[4]=((((-1.0)*cj0*x537))+new_r11);
evalcond[5]=(new_r10+(((-1.0)*new_r02*x536)));
evalcond[6]=((((-1.0)*new_r00*x535))+(((-1.0)*x536))+((cj0*new_r10)));
evalcond[7]=((((-1.0)*x537))+(((-1.0)*new_r01*x535))+((cj0*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j1)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x538=IKcos(j2);
IkReal x539=IKsin(j2);
IkReal x540=((1.0)*sj0);
IkReal x541=((1.0)*x538);
evalcond[0]=(x539+new_r21);
evalcond[1]=((((-1.0)*x541))+new_r20);
evalcond[2]=(((sj0*x538))+new_r01);
evalcond[3]=(((sj0*x539))+new_r00);
evalcond[4]=(((new_r02*x539))+new_r10);
evalcond[5]=((((-1.0)*cj0*x541))+new_r11);
evalcond[6]=((((-1.0)*x539))+(((-1.0)*new_r00*x540))+((cj0*new_r10)));
evalcond[7]=((((-1.0)*new_r01*x540))+(((-1.0)*x541))+((cj0*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j1))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x542=((1.0)*new_r01);
if( IKabs(((((-1.0)*cj0*x542))+(((-1.0)*new_r00*sj0)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*sj0*x542))+((cj0*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj0*x542))+(((-1.0)*new_r00*sj0))))+IKsqr(((((-1.0)*sj0*x542))+((cj0*new_r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*cj0*x542))+(((-1.0)*new_r00*sj0))), ((((-1.0)*sj0*x542))+((cj0*new_r00))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x543=IKsin(j2);
IkReal x544=IKcos(j2);
IkReal x545=((1.0)*sj0);
IkReal x546=((1.0)*x544);
IkReal x547=(sj0*x543);
IkReal x548=(cj0*x543);
IkReal x549=(cj0*x546);
evalcond[0]=(((new_r11*sj0))+x543+((cj0*new_r01)));
evalcond[1]=(((sj0*x544))+x548+new_r01);
evalcond[2]=(((new_r10*sj0))+(((-1.0)*x546))+((cj0*new_r00)));
evalcond[3]=((((-1.0)*x543))+(((-1.0)*new_r00*x545))+((cj0*new_r10)));
evalcond[4]=((((-1.0)*new_r01*x545))+(((-1.0)*x546))+((cj0*new_r11)));
evalcond[5]=((((-1.0)*x549))+x547+new_r00);
evalcond[6]=((((-1.0)*x549))+x547+new_r11);
evalcond[7]=((((-1.0)*x544*x545))+(((-1.0)*x548))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j1)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x550=((1.0)*sj0);
if( IKabs(((((-1.0)*new_r00*x550))+((cj0*new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj0*new_r00))+(((-1.0)*new_r01*x550)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r00*x550))+((cj0*new_r01))))+IKsqr(((((-1.0)*cj0*new_r00))+(((-1.0)*new_r01*x550))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*new_r00*x550))+((cj0*new_r01))), ((((-1.0)*cj0*new_r00))+(((-1.0)*new_r01*x550))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x551=IKsin(j2);
IkReal x552=IKcos(j2);
IkReal x553=((1.0)*sj0);
IkReal x554=((1.0)*x551);
IkReal x555=(sj0*x552);
IkReal x556=((1.0)*x552);
IkReal x557=(cj0*x554);
evalcond[0]=(((new_r10*sj0))+x552+((cj0*new_r00)));
evalcond[1]=(((new_r11*sj0))+(((-1.0)*x554))+((cj0*new_r01)));
evalcond[2]=(((cj0*x552))+new_r00+((sj0*x551)));
evalcond[3]=((((-1.0)*new_r00*x553))+(((-1.0)*x554))+((cj0*new_r10)));
evalcond[4]=((((-1.0)*new_r01*x553))+(((-1.0)*x556))+((cj0*new_r11)));
evalcond[5]=((((-1.0)*x557))+x555+new_r01);
evalcond[6]=((((-1.0)*x557))+x555+new_r10);
evalcond[7]=((((-1.0)*x551*x553))+(((-1.0)*cj0*x556))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j0))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(new_r10, new_r11);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x558=IKcos(j2);
IkReal x559=IKsin(j2);
IkReal x560=((1.0)*sj1);
IkReal x561=((1.0)*x558);
evalcond[0]=(((sj1*x558))+new_r20);
evalcond[1]=((((-1.0)*x559))+new_r10);
evalcond[2]=(new_r11+(((-1.0)*x561)));
evalcond[3]=(((cj1*x559))+new_r01);
evalcond[4]=((((-1.0)*x559*x560))+new_r21);
evalcond[5]=((((-1.0)*cj1*x561))+new_r00);
evalcond[6]=(((cj1*new_r01))+x559+(((-1.0)*new_r21*x560)));
evalcond[7]=((((-1.0)*new_r20*x560))+((cj1*new_r00))+(((-1.0)*x561)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j0)))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[3];
sj0=0;
cj0=-1.0;
j0=3.14159265358979;
j2eval[0]=sj1;
j2eval[1]=IKsign(sj1);
j2eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[1];
sj0=0;
cj0=-1.0;
j0=3.14159265358979;
j2eval[0]=sj1;
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
sj0=0;
cj0=-1.0;
j0=3.14159265358979;
j2eval[0]=cj1;
j2eval[1]=sj1;
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j1)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r01;
evalcond[3]=new_r00;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x562=IKcos(j2);
IkReal x563=((1.0)*(IKsin(j2)));
evalcond[0]=(x562+new_r20);
evalcond[1]=(new_r21+(((-1.0)*x563)));
evalcond[2]=((((-1.0)*new_r10))+(((-1.0)*x563)));
evalcond[3]=((((-1.0)*x562))+(((-1.0)*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j1)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r01;
evalcond[3]=new_r00;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x564=IKsin(j2);
IkReal x565=((1.0)*(IKcos(j2)));
evalcond[0]=(x564+new_r21);
evalcond[1]=(new_r20+(((-1.0)*x565)));
evalcond[2]=((((-1.0)*x564))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*new_r11))+(((-1.0)*x565)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j1))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(new_r01, ((-1.0)*new_r11));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x566=IKsin(j2);
IkReal x567=((1.0)*(IKcos(j2)));
evalcond[0]=(x566+(((-1.0)*new_r01)));
evalcond[1]=((((-1.0)*x566))+(((-1.0)*new_r10)));
evalcond[2]=((((-1.0)*new_r11))+(((-1.0)*x567)));
evalcond[3]=((((-1.0)*new_r00))+(((-1.0)*x567)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j1)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r10), new_r00);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x568=IKcos(j2);
IkReal x569=((1.0)*(IKsin(j2)));
evalcond[0]=(x568+(((-1.0)*new_r00)));
evalcond[1]=((((-1.0)*new_r10))+(((-1.0)*x569)));
evalcond[2]=((((-1.0)*x568))+(((-1.0)*new_r11)));
evalcond[3]=((((-1.0)*new_r01))+(((-1.0)*x569)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r11));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x570=IKsin(j2);
IkReal x571=IKcos(j2);
IkReal x572=((-1.0)*x571);
evalcond[0]=x570;
evalcond[1]=(new_r22*x570);
evalcond[2]=x572;
evalcond[3]=(new_r22*x572);
evalcond[4]=((((-1.0)*x570))+(((-1.0)*new_r10)));
evalcond[5]=((((-1.0)*x571))+(((-1.0)*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j2]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x573=IKPowWithIntegerCheck(cj1,-1);
if(!x573.valid){
continue;
}
CheckValue<IkReal> x574=IKPowWithIntegerCheck(sj1,-1);
if(!x574.valid){
continue;
}
if( IKabs((new_r01*(x573.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*(x574.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r01*(x573.value)))+IKsqr(((-1.0)*new_r20*(x574.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((new_r01*(x573.value)), ((-1.0)*new_r20*(x574.value)));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x575=IKsin(j2);
IkReal x576=IKcos(j2);
IkReal x577=((1.0)*new_r00);
IkReal x578=((1.0)*sj1);
IkReal x579=((1.0)*new_r01);
IkReal x580=((1.0)*x576);
evalcond[0]=(((sj1*x576))+new_r20);
evalcond[1]=((((-1.0)*x575*x578))+new_r21);
evalcond[2]=((((-1.0)*x575))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*new_r11))+(((-1.0)*x580)));
evalcond[4]=((((-1.0)*x579))+((cj1*x575)));
evalcond[5]=((((-1.0)*x577))+(((-1.0)*cj1*x580)));
evalcond[6]=((((-1.0)*cj1*x579))+x575+(((-1.0)*new_r21*x578)));
evalcond[7]=((((-1.0)*cj1*x577))+(((-1.0)*new_r20*x578))+(((-1.0)*x580)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x581=IKPowWithIntegerCheck(sj1,-1);
if(!x581.valid){
continue;
}
if( IKabs((new_r21*(x581.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r21*(x581.value)))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((new_r21*(x581.value)), ((-1.0)*new_r11));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x582=IKsin(j2);
IkReal x583=IKcos(j2);
IkReal x584=((1.0)*new_r00);
IkReal x585=((1.0)*sj1);
IkReal x586=((1.0)*new_r01);
IkReal x587=((1.0)*x583);
evalcond[0]=(((sj1*x583))+new_r20);
evalcond[1]=((((-1.0)*x582*x585))+new_r21);
evalcond[2]=((((-1.0)*x582))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*new_r11))+(((-1.0)*x587)));
evalcond[4]=((((-1.0)*x586))+((cj1*x582)));
evalcond[5]=((((-1.0)*cj1*x587))+(((-1.0)*x584)));
evalcond[6]=((((-1.0)*new_r21*x585))+x582+(((-1.0)*cj1*x586)));
evalcond[7]=((((-1.0)*new_r20*x585))+(((-1.0)*cj1*x584))+(((-1.0)*x587)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x588=IKPowWithIntegerCheck(IKsign(sj1),-1);
if(!x588.valid){
continue;
}
CheckValue<IkReal> x589 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x589.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x588.value)))+(x589.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x590=IKsin(j2);
IkReal x591=IKcos(j2);
IkReal x592=((1.0)*new_r00);
IkReal x593=((1.0)*sj1);
IkReal x594=((1.0)*new_r01);
IkReal x595=((1.0)*x591);
evalcond[0]=(((sj1*x591))+new_r20);
evalcond[1]=((((-1.0)*x590*x593))+new_r21);
evalcond[2]=((((-1.0)*x590))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x595))+(((-1.0)*new_r11)));
evalcond[4]=(((cj1*x590))+(((-1.0)*x594)));
evalcond[5]=((((-1.0)*x592))+(((-1.0)*cj1*x595)));
evalcond[6]=((((-1.0)*new_r21*x593))+(((-1.0)*cj1*x594))+x590);
evalcond[7]=((((-1.0)*new_r20*x593))+(((-1.0)*x595))+(((-1.0)*cj1*x592)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[1];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
j2eval[0]=IKabs(new_r22);
if( IKabs(j2eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j2]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
op[0]=new_r22;
op[1]=0;
op[2]=((-1.0)*new_r22);
polyroots2(op,zeror,numroots);
IkReal j2array[2], cj2array[2], sj2array[2], tempj2array[1];
int numsolutions = 0;
for(int ij2 = 0; ij2 < numroots; ++ij2)
{
IkReal htj2 = zeror[ij2];
tempj2array[0]=((2.0)*(atan(htj2)));
for(int kj2 = 0; kj2 < 1; ++kj2)
{
j2array[numsolutions] = tempj2array[kj2];
if( j2array[numsolutions] > IKPI )
{
    j2array[numsolutions]-=IK2PI;
}
else if( j2array[numsolutions] < -IKPI )
{
    j2array[numsolutions]+=IK2PI;
}
sj2array[numsolutions] = IKsin(j2array[numsolutions]);
cj2array[numsolutions] = IKcos(j2array[numsolutions]);
numsolutions++;
}
}
bool j2valid[2]={true,true};
_nj2 = 2;
for(int ij2 = 0; ij2 < numsolutions; ++ij2)
    {
if( !j2valid[ij2] )
{
    continue;
}
    j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
htj2 = IKtan(j2/2);

_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < numsolutions; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j2]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x597=IKPowWithIntegerCheck(sj1,-1);
if(!x597.valid){
continue;
}
IkReal x596=x597.value;
CheckValue<IkReal> x598=IKPowWithIntegerCheck(cj0,-1);
if(!x598.valid){
continue;
}
CheckValue<IkReal> x599=IKPowWithIntegerCheck(cj1,-1);
if(!x599.valid){
continue;
}
if( IKabs((x596*(x598.value)*(x599.value)*((((new_r20*sj0))+(((-1.0)*new_r01*sj1)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x596)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x596*(x598.value)*(x599.value)*((((new_r20*sj0))+(((-1.0)*new_r01*sj1))))))+IKsqr(((-1.0)*new_r20*x596))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((x596*(x598.value)*(x599.value)*((((new_r20*sj0))+(((-1.0)*new_r01*sj1))))), ((-1.0)*new_r20*x596));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[12];
IkReal x600=IKsin(j2);
IkReal x601=IKcos(j2);
IkReal x602=((1.0)*sj1);
IkReal x603=((1.0)*sj0);
IkReal x604=(cj0*new_r00);
IkReal x605=(cj0*cj1);
IkReal x606=(new_r11*sj0);
IkReal x607=(new_r10*sj0);
IkReal x608=((1.0)*x601);
IkReal x609=(cj1*x600);
IkReal x610=((1.0)*x600);
evalcond[0]=(((sj1*x601))+new_r20);
evalcond[1]=((((-1.0)*x600*x602))+new_r21);
evalcond[2]=(x606+x609+((cj0*new_r01)));
evalcond[3]=((((-1.0)*x610))+((cj0*new_r10))+(((-1.0)*new_r00*x603)));
evalcond[4]=((((-1.0)*x608))+(((-1.0)*new_r01*x603))+((cj0*new_r11)));
evalcond[5]=(((sj0*x601))+((x600*x605))+new_r01);
evalcond[6]=((((-1.0)*cj1*x608))+x607+x604);
evalcond[7]=(((sj0*x600))+(((-1.0)*x605*x608))+new_r00);
evalcond[8]=(((sj0*x609))+new_r11+(((-1.0)*cj0*x608)));
evalcond[9]=((((-1.0)*cj0*x610))+(((-1.0)*cj1*x601*x603))+new_r10);
evalcond[10]=(((cj1*x606))+x600+((new_r01*x605))+(((-1.0)*new_r21*x602)));
evalcond[11]=((((-1.0)*new_r20*x602))+((cj1*x607))+((cj1*x604))+(((-1.0)*x608)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x612=IKPowWithIntegerCheck(sj1,-1);
if(!x612.valid){
continue;
}
IkReal x611=x612.value;
CheckValue<IkReal> x613=IKPowWithIntegerCheck(sj0,-1);
if(!x613.valid){
continue;
}
if( IKabs((x611*(x613.value)*(((((-1.0)*cj0*cj1*new_r20))+(((-1.0)*new_r00*sj1)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x611)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x611*(x613.value)*(((((-1.0)*cj0*cj1*new_r20))+(((-1.0)*new_r00*sj1))))))+IKsqr(((-1.0)*new_r20*x611))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((x611*(x613.value)*(((((-1.0)*cj0*cj1*new_r20))+(((-1.0)*new_r00*sj1))))), ((-1.0)*new_r20*x611));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[12];
IkReal x614=IKsin(j2);
IkReal x615=IKcos(j2);
IkReal x616=((1.0)*sj1);
IkReal x617=((1.0)*sj0);
IkReal x618=(cj0*new_r00);
IkReal x619=(cj0*cj1);
IkReal x620=(new_r11*sj0);
IkReal x621=(new_r10*sj0);
IkReal x622=((1.0)*x615);
IkReal x623=(cj1*x614);
IkReal x624=((1.0)*x614);
evalcond[0]=(((sj1*x615))+new_r20);
evalcond[1]=((((-1.0)*x614*x616))+new_r21);
evalcond[2]=(x620+x623+((cj0*new_r01)));
evalcond[3]=((((-1.0)*x624))+(((-1.0)*new_r00*x617))+((cj0*new_r10)));
evalcond[4]=((((-1.0)*x622))+((cj0*new_r11))+(((-1.0)*new_r01*x617)));
evalcond[5]=(((sj0*x615))+((x614*x619))+new_r01);
evalcond[6]=((((-1.0)*cj1*x622))+x618+x621);
evalcond[7]=(((sj0*x614))+(((-1.0)*x619*x622))+new_r00);
evalcond[8]=((((-1.0)*cj0*x622))+((sj0*x623))+new_r11);
evalcond[9]=((((-1.0)*cj0*x624))+(((-1.0)*cj1*x615*x617))+new_r10);
evalcond[10]=((((-1.0)*new_r21*x616))+x614+((new_r01*x619))+((cj1*x620)));
evalcond[11]=((((-1.0)*x622))+((cj1*x618))+(((-1.0)*new_r20*x616))+((cj1*x621)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x625=IKPowWithIntegerCheck(IKsign(sj1),-1);
if(!x625.valid){
continue;
}
CheckValue<IkReal> x626 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x626.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x625.value)))+(x626.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[12];
IkReal x627=IKsin(j2);
IkReal x628=IKcos(j2);
IkReal x629=((1.0)*sj1);
IkReal x630=((1.0)*sj0);
IkReal x631=(cj0*new_r00);
IkReal x632=(cj0*cj1);
IkReal x633=(new_r11*sj0);
IkReal x634=(new_r10*sj0);
IkReal x635=((1.0)*x628);
IkReal x636=(cj1*x627);
IkReal x637=((1.0)*x627);
evalcond[0]=(((sj1*x628))+new_r20);
evalcond[1]=((((-1.0)*x627*x629))+new_r21);
evalcond[2]=(x636+x633+((cj0*new_r01)));
evalcond[3]=((((-1.0)*new_r00*x630))+(((-1.0)*x637))+((cj0*new_r10)));
evalcond[4]=((((-1.0)*new_r01*x630))+(((-1.0)*x635))+((cj0*new_r11)));
evalcond[5]=(((sj0*x628))+new_r01+((x627*x632)));
evalcond[6]=((((-1.0)*cj1*x635))+x634+x631);
evalcond[7]=(((sj0*x627))+new_r00+(((-1.0)*x632*x635)));
evalcond[8]=((((-1.0)*cj0*x635))+((sj0*x636))+new_r11);
evalcond[9]=((((-1.0)*cj1*x628*x630))+(((-1.0)*cj0*x637))+new_r10);
evalcond[10]=(((new_r01*x632))+(((-1.0)*new_r21*x629))+x627+((cj1*x633)));
evalcond[11]=((((-1.0)*x635))+(((-1.0)*new_r20*x629))+((cj1*x634))+((cj1*x631)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
}
}
}static inline void polyroots3(IkReal rawcoeffs[3+1], IkReal rawroots[3], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots2(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[3];
    const int maxsteps = 110;
    for(int i = 0; i < 3; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[3];
    IkReal err[3];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 3; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 3; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 3; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 3; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[3] = {false};
    for(int i = 0; i < 3; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 3; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {
    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];
    if( det < 0 ) {
        numroots=0;
    }
    else if( det == 0 ) {
        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];
        numroots = 1;
    }
    else {
        det = IKsqrt(det);
        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);
        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);
        numroots = 2;
    }
}
static inline void polyroots4(IkReal rawcoeffs[4+1], IkReal rawroots[4], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots3(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[4];
    const int maxsteps = 110;
    for(int i = 0; i < 4; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[4];
    IkReal err[4];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 4; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 4; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 4; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 4; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[4] = {false};
    for(int i = 0; i < 4; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 4; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "<robot:GenericRobot - xarm7_with_gripper (b0c22985b5978e1acf2a611482b6a182)>"; }

IKFAST_API const char* GetIkFastVersion() { return "0x10000049"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif
