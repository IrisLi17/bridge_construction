/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x10000049 generated on 2021-08-10 16:16:16.662867
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x10000049);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)1e-7)
#endif

// used to check input to atan2 for degenerate cases. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)1e-7)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.00001)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42,x43,x44,x45,x46,x47,x48,x49,x50,x51,x52,x53,x54,x55,x56,x57,x58,x59,x60,x61,x62,x63,x64,x65;
x0=IKcos(j[0]);
x1=IKcos(j[3]);
x2=IKsin(j[1]);
x3=IKsin(j[3]);
x4=IKcos(j[2]);
x5=IKsin(j[0]);
x6=IKcos(j[1]);
x7=IKsin(j[2]);
x8=IKcos(j[4]);
x9=IKsin(j[4]);
x10=IKcos(j[6]);
x11=IKsin(j[6]);
x12=IKcos(j[5]);
x13=IKsin(j[5]);
x14=((0.097)*x2);
x15=((0.0775)*x4);
x16=((0.3425)*x5);
x17=((1.0)*x1);
x18=((1.0)*x5);
x19=((0.3425)*x4);
x20=((1.0)*x2);
x21=((0.0525)*x4);
x22=((0.0775)*x5);
x23=((1.0)*x4);
x24=((0.293)*x2);
x25=((0.076)*x8);
x26=(x7*x9);
x27=(x1*x6);
x28=(x5*x6);
x29=(x1*x2);
x30=(x0*x7);
x31=((-1.0)*x12);
x32=(x3*x6);
x33=(x2*x3);
x34=((-1.0)*x13);
x35=(x0*x6);
x36=((-0.097)*x8);
x37=(x0*x33);
x38=(x17*x2*x4);
x39=(x20*x26);
x40=((((-1.0)*x18*x7))+((x35*x4)));
x41=(((x30*x6))+((x4*x5)));
x42=(x30+((x28*x4)));
x43=((((-1.0)*x0*x23))+((x28*x7)));
x44=((((-1.0)*x38))+x32);
x45=(x41*x8);
x46=(x3*x40);
x47=((((-1.0)*x20*x3*x4))+(((-1.0)*x17*x6)));
x48=(x41*x9);
x49=(x1*x40);
x50=(x3*x42);
x51=(x44*x8);
x52=(x43*x9);
x53=(x13*x47);
x54=(x37+x49);
x55=((((-1.0)*x0*x17*x2))+x46);
x56=((((-1.0)*x17*x2*x5))+x50);
x57=(((x33*x5))+((x1*x42)));
x58=((((-1.0)*x39))+x51);
x59=((((-1.0)*x20*x7*x8))+((x9*(((((-1.0)*x32))+x38)))));
x60=(x57*x8);
x61=(x12*x58);
x62=(x54*x8);
x63=(x48+x62);
x64=(x52+x60);
x65=(((x9*(((((-1.0)*x18*x33))+(((-1.0)*x17*x42))))))+((x43*x8)));
eerot[0]=(((x10*((((x12*x63))+((x13*x55))))))+((x11*((x45+((x9*(((((-1.0)*x37))+(((-1.0)*x49)))))))))));
IkReal x66=((1.0)*x0);
eerot[1]=(((x11*((((x31*x63))+((x34*((x46+(((-1.0)*x29*x66))))))))))+((x10*((((x9*(((((-1.0)*x20*x3*x66))+(((-1.0)*x17*x40))))))+x45)))));
eerot[2]=(((x13*(((((-1.0)*x48))+(((-1.0)*x62))))))+((x12*x55)));
IkReal x67=((1.0)*x7);
IkReal x68=(x0*x29);
eetrans[0]=(((x0*x24))+((x3*(((((-1.0)*x16*x67))+((x19*x35))))))+((x13*((((x36*x54))+(((-0.097)*x48))))))+((x13*(((((0.076)*x46))+(((-0.076)*x68))))))+((x21*x35))+((x12*(((((-0.097)*x68))+(((0.097)*x46))))))+((x1*((((x15*x35))+(((-1.0)*x22*x67))))))+(((-0.3425)*x68))+(((-0.0525)*x5*x7))+(((0.0775)*x37))+((x12*((((x25*x54))+(((0.076)*x48)))))));
eerot[3]=(((x11*x65))+((x10*((((x12*x64))+((x13*x56)))))));
eerot[4]=(((x10*x65))+((x11*((((x34*x56))+((x31*x64)))))));
eerot[5]=(((x12*x56))+((x13*(((((-1.0)*x52))+(((-1.0)*x60)))))));
eetrans[1]=(((x21*x28))+((x12*(((((0.076)*x52))+((x25*x57))))))+((x13*((((x36*x57))+(((-0.097)*x52))))))+(((-1.0)*x16*x29))+((x22*x33))+((x1*(((((0.0775)*x30))+((x15*x28))))))+((x12*(((((-1.0)*x1*x14*x5))+(((0.097)*x50))))))+((x13*(((((0.076)*x50))+(((-0.076)*x29*x5))))))+((x3*(((((0.3425)*x30))+((x16*x4*x6))))))+(((0.0525)*x30))+((x24*x5)));
eerot[6]=(((x10*((x53+x61))))+((x11*x59)));
eerot[7]=(((x10*x59))+((x11*(((((-1.0)*x53))+(((-1.0)*x61)))))));
eerot[8]=(((x13*((x39+(((-1.0)*x51))))))+((x12*x47)));
eetrans[2]=((0.267)+((x12*((((x25*x44))+(((-0.076)*x2*x26))))))+(((-1.0)*x15*x29))+((x13*((((x36*x44))+((x14*x26))))))+(((-1.0)*x2*x21))+(((-1.0)*x19*x33))+(((0.0775)*x32))+(((-0.3425)*x27))+((x13*(((((-0.076)*x27))+(((-0.076)*x33*x4))))))+(((0.293)*x6))+((x12*(((((-0.097)*x27))+(((-1.0)*x14*x3*x4)))))));
}

IKFAST_API int GetNumFreeParameters() { return 1; }
IKFAST_API int* GetFreeParameters() { static int freeparams[] = {5}; return freeparams; }
IKFAST_API int GetNumJoints() { return 7; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x67000001; }

class IKSolver {
public:
IkReal j0,cj0,sj0,htj0,j0mul,j1,cj1,sj1,htj1,j1mul,j2,cj2,sj2,htj2,j2mul,j3,cj3,sj3,htj3,j3mul,j4,cj4,sj4,htj4,j4mul,j6,cj6,sj6,htj6,j6mul,j5,cj5,sj5,htj5,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij0[2], _nj0,_ij1[2], _nj1,_ij2[2], _nj2,_ij3[2], _nj3,_ij4[2], _nj4,_ij6[2], _nj6,_ij5[2], _nj5;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j0=numeric_limits<IkReal>::quiet_NaN(); _ij0[0] = -1; _ij0[1] = -1; _nj0 = -1; j1=numeric_limits<IkReal>::quiet_NaN(); _ij1[0] = -1; _ij1[1] = -1; _nj1 = -1; j2=numeric_limits<IkReal>::quiet_NaN(); _ij2[0] = -1; _ij2[1] = -1; _nj2 = -1; j3=numeric_limits<IkReal>::quiet_NaN(); _ij3[0] = -1; _ij3[1] = -1; _nj3 = -1; j4=numeric_limits<IkReal>::quiet_NaN(); _ij4[0] = -1; _ij4[1] = -1; _nj4 = -1; j6=numeric_limits<IkReal>::quiet_NaN(); _ij6[0] = -1; _ij6[1] = -1; _nj6 = -1;  _ij5[0] = -1; _ij5[1] = -1; _nj5 = 0; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
j5=pfree[0]; cj5=cos(pfree[0]); sj5=sin(pfree[0]), htj5=tan(pfree[0]*0.5);
r00 = eerot[0*3+0];
r01 = eerot[0*3+1];
r02 = eerot[0*3+2];
r10 = eerot[1*3+0];
r11 = eerot[1*3+1];
r12 = eerot[1*3+2];
r20 = eerot[2*3+0];
r21 = eerot[2*3+1];
r22 = eerot[2*3+2];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_r00=r00;
new_r01=r01;
new_r02=r02;
new_px=((((-0.097)*r02))+px);
new_r10=r10;
new_r11=r11;
new_r12=r12;
new_py=((((-0.097)*r12))+py);
new_r20=r20;
new_r21=r21;
new_r22=r22;
new_pz=((-0.267)+(((-0.097)*r22))+pz);
r00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;
IkReal x69=((1.0)*px);
IkReal x70=((1.0)*pz);
IkReal x71=((1.0)*py);
pp=((px*px)+(py*py)+(pz*pz));
npx=(((px*r00))+((py*r10))+((pz*r20)));
npy=(((px*r01))+((py*r11))+((pz*r21)));
npz=(((px*r02))+((py*r12))+((pz*r22)));
rxp0_0=((((-1.0)*r20*x71))+((pz*r10)));
rxp0_1=(((px*r20))+(((-1.0)*r00*x70)));
rxp0_2=((((-1.0)*r10*x69))+((py*r00)));
rxp1_0=((((-1.0)*r21*x71))+((pz*r11)));
rxp1_1=(((px*r21))+(((-1.0)*r01*x70)));
rxp1_2=((((-1.0)*r11*x69))+((py*r01)));
rxp2_0=((((-1.0)*r22*x71))+((pz*r12)));
rxp2_1=(((px*r22))+(((-1.0)*r02*x70)));
rxp2_2=((((-1.0)*r12*x69))+((py*r02)));
IkReal op[8+1], zeror[8];
int numroots;
IkReal x72=((0.152)*npx);
IkReal x73=((0.076)*sj5);
IkReal x74=(npx*sj5);
IkReal x75=((-0.39870925)+pp);
IkReal x76=((-0.01357425)+pp);
IkReal x77=((((-1.0)*x72))+x76);
IkReal x78=((((-1.0)*x72))+x75);
IkReal x79=((1.0)*cj5*npz);
IkReal x80=((0.0495)+x73);
IkReal x81=((0.6355)+x73);
IkReal x82=(x76+x72);
IkReal x83=(x75+x72);
IkReal x84=((((1.0)*x74))+x79);
IkReal x85=((((-1.0)*x79))+x74+x80);
IkReal x86=((((-1.0)*x79))+x74+x81);
IkReal x87=(x80+(((-1.0)*x84)));
IkReal x88=(x81+(((-1.0)*x84)));
IkReal gconst0=x77;
IkReal gconst1=x78;
IkReal gconst2=x87;
IkReal gconst3=x88;
IkReal gconst4=x77;
IkReal gconst5=x78;
IkReal gconst6=x87;
IkReal gconst7=x88;
IkReal gconst8=x82;
IkReal gconst9=x83;
IkReal gconst10=x85;
IkReal gconst11=x86;
IkReal gconst12=x82;
IkReal gconst13=x83;
IkReal gconst14=x85;
IkReal gconst15=x86;
IkReal x89=npy*npy;
IkReal x90=sj5*sj5;
IkReal x91=(gconst1*gconst7);
IkReal x92=(gconst0*gconst11);
IkReal x93=(gconst5*gconst6);
IkReal x94=(gconst8*sj5);
IkReal x95=(gconst14*gconst9);
IkReal x96=(gconst11*sj5);
IkReal x97=(gconst11*gconst12);
IkReal x98=(gconst13*gconst14);
IkReal x99=(gconst1*gconst6);
IkReal x100=(gconst1*gconst4);
IkReal x101=(gconst0*gconst3);
IkReal x102=((1.0)*gconst7);
IkReal x103=((0.0033516)*npy);
IkReal x104=(npy*sj5);
IkReal x105=((0.05297838005)*gconst6);
IkReal x106=((0.304)*npy);
IkReal x107=((1.0)*gconst1);
IkReal x108=(gconst2*gconst5);
IkReal x109=((0.0051951396)*npy);
IkReal x110=(gconst10*sj5);
IkReal x111=((0.026489190025)*gconst6);
IkReal x112=((0.017089275)*gconst3);
IkReal x113=(gconst2*gconst7);
IkReal x114=((0.03417855)*gconst4);
IkReal x115=(gconst3*sj5);
IkReal x116=(gconst3*gconst8);
IkReal x117=(gconst12*gconst9);
IkReal x118=((2.0)*gconst0);
IkReal x119=((1.0)*gconst2);
IkReal x120=((2.0)*gconst4);
IkReal x121=(gconst10*gconst9);
IkReal x122=((2.0)*npy);
IkReal x123=(gconst0*sj5);
IkReal x124=((2.0)*gconst13);
IkReal x125=(gconst11*gconst8);
IkReal x126=(gconst2*gconst4);
IkReal x127=((1.0)*gconst15);
IkReal x128=(gconst4*gconst7);
IkReal x129=((1.0)*gconst13);
IkReal x130=(gconst10*gconst15);
IkReal x131=(gconst11*gconst14);
IkReal x132=((2.0)*gconst1);
IkReal x133=(gconst15*gconst2);
IkReal x134=(gconst1*gconst12);
IkReal x135=(gconst4*gconst9);
IkReal x136=(gconst13*gconst6);
IkReal x137=((0.011025)*x134);
IkReal x138=((0.0010188864)*x89);
IkReal x139=((0.017089275)*gconst11*gconst4);
IkReal x140=(gconst12*x112);
IkReal x141=((0.011025)*x135);
IkReal x142=((0.026489190025)*gconst14*gconst3);
IkReal x143=((0.017089275)*gconst6*gconst9);
IkReal x144=(gconst11*x111);
IkReal x145=((0.017089275)*gconst1*gconst14);
IkReal x146=(gconst2*x106);
IkReal x147=(gconst12*x89);
IkReal x148=((4.0)*x90);
IkReal x149=((0.608)*x89);
IkReal x150=(gconst12*x122);
IkReal x151=(gconst14*x125);
IkReal x152=(gconst12*x127);
IkReal x153=((0.092416)*x89);
IkReal x154=(gconst0*x89);
IkReal x155=(gconst13*x89);
IkReal x156=(gconst15*gconst9*sj5);
IkReal x157=((0.0207805584)*sj5*x89);
IkReal x158=((0.1059567601)*x89*x90);
IkReal x159=(x157+x158+x140+x141+x142+x143+x144+x145+x137+x139+x138);
op[0]=((((-0.011025)*x117))+((x117*x130))+((x125*x98))+(((-0.017089275)*x95))+(((-0.017089275)*x97))+(((-1.0)*gconst8*x127*x97))+(((-1.0)*gconst10*x129*x95))+(((-0.026489190025)*x131)));
op[1]=((((-1.0)*gconst14*x109))+(((-1.0)*x104*x124*x95))+(((-1.0)*gconst15*x106*x125))+(((-1.0)*gconst11*x109))+(((-1.0)*x104*x121*x124))+(((-1.0)*x122*x94*x97))+(((-1.0)*gconst15*x106*x97))+((x122*x94*x98))+(((-0.03417855)*gconst9*x104))+(((-0.05297838005)*gconst14*x104))+(((-0.03417855)*gconst12*x104))+(((-1.0)*gconst9*x103))+((gconst11*x106*x98))+(((-1.0)*gconst10*x106*x95))+(((-1.0)*gconst10*x106*x98))+(((-1.0)*gconst12*x103))+(((2.0)*gconst15*x104*x117))+((gconst15*x106*x121))+((gconst11*gconst13*x122*x94))+((gconst12*x106*x130))+(((-0.05297838005)*npy*x96))+((x106*x151))+(((2.0)*gconst10*x104*x117))+(((-1.0)*gconst15*x150*x94)));
op[2]=((((-1.0)*gconst10*gconst14*x153))+((gconst10*gconst7*x117))+((x149*x156))+(((0.608)*x110*x147))+(((-1.0)*sj5*x149*x95))+(((-1.0)*x159))+((x117*x133))+((x117*x148*x89))+((x92*x98))+((gconst8*x148*x155))+(((-1.0)*gconst10*gconst5*x95))+(((-1.0)*gconst8*x102*x97))+(((-0.05297838005)*x131))+(((-1.0)*gconst4*x125*x127))+(((-1.0)*gconst13*x119*x95))+(((-1.0)*gconst13*x110*x149))+(((-1.0)*gconst15*x149*x94))+(((-1.0)*gconst10*x107*x98))+(((-1.0)*gconst11*gconst15*x153))+(((-1.0)*gconst8*x147*x148))+(((-1.0)*x116*x152))+((gconst13*x149*x96))+((gconst14*x149*x94))+((x125*x136))+((x130*x134))+(((-0.03417855)*x97))+(((-0.03417855)*x95))+((gconst15*gconst4*x121))+(((-0.02205)*x117))+((x116*x98))+(((-1.0)*x152*x92))+(((-1.0)*gconst9*x148*x155))+(((-1.0)*gconst6*x121*x129))+(((-0.608)*x147*x96))+((x131*x153))+((gconst5*x151))+((x130*x153)));
op[3]=((((-2.0)*gconst15*gconst4*gconst8*npy*sj5))+(((2.0)*gconst12*gconst7*gconst9*npy*sj5))+(((0.304)*gconst15*gconst2*gconst9*npy))+(((-0.1059567601)*gconst14*npy*sj5))+(((-0.304)*gconst10*gconst6*gconst9*npy))+(((0.304)*gconst12*gconst15*gconst2*npy))+(((-0.05297838005)*gconst6*npy*sj5))+(((0.304)*gconst11*gconst6*gconst8*npy))+(((0.304)*gconst1*gconst10*gconst15*npy))+(((-0.1059567601)*gconst11*npy*sj5))+(((-0.0683571)*gconst9*npy*sj5))+(((-0.304)*gconst10*gconst14*gconst5*npy))+(((2.0)*gconst12*gconst2*gconst9*npy*sj5))+(((-2.0)*gconst12*gconst7*gconst8*npy*sj5))+(((-0.0033516)*gconst4*npy))+(((-0.304)*gconst11*gconst7*gconst8*npy))+(((-0.0051951396)*gconst3*npy))+(((-2.0)*gconst1*gconst10*gconst13*npy*sj5))+(((-0.0033516)*gconst1*npy))+(((-2.0)*gconst10*gconst5*gconst9*npy*sj5))+(((-0.304)*gconst14*gconst2*gconst9*npy))+(((2.0)*gconst10*gconst4*gconst9*npy*sj5))+(((-0.304)*gconst13*gconst14*gconst2*npy))+(((0.304)*gconst10*gconst15*gconst4*npy))+(((2.0)*gconst14*gconst5*gconst8*npy*sj5))+(((2.0)*gconst11*gconst5*gconst8*npy*sj5))+(((0.304)*gconst14*gconst3*gconst8*npy))+(((-2.0)*gconst13*gconst2*gconst9*npy*sj5))+(((-0.304)*gconst11*gconst15*gconst4*npy))+(((-2.0)*gconst14*gconst5*gconst9*npy*sj5))+(((-0.05297838005)*gconst3*npy*sj5))+(((-0.0103902792)*gconst11*npy))+(((-0.0103902792)*gconst14*npy))+(((0.304)*gconst11*gconst13*gconst6*npy))+(((2.0)*gconst0*gconst11*gconst13*npy*sj5))+(((0.304)*gconst0*gconst11*gconst14*npy))+(((-0.304)*gconst15*gconst3*gconst8*npy))+(((-0.0067032)*gconst9*npy))+(((2.0)*gconst13*gconst6*gconst8*npy*sj5))+(((2.0)*gconst1*gconst12*gconst15*npy*sj5))+(((-2.0)*gconst0*gconst11*gconst12*npy*sj5))+(((-2.0)*gconst0*gconst12*gconst15*npy*sj5))+(((-0.304)*gconst10*gconst13*gconst6*npy))+(((2.0)*gconst13*gconst3*gconst8*npy*sj5))+(((-0.0051951396)*gconst6*npy))+(((-0.304)*gconst1*gconst10*gconst14*npy))+(((2.0)*gconst1*gconst10*gconst12*npy*sj5))+(((-0.0683571)*gconst12*npy*sj5))+(((0.304)*gconst10*gconst7*gconst9*npy))+(((-0.0067032)*gconst12*npy))+(((0.304)*gconst10*gconst12*gconst7*npy))+(((-2.0)*gconst13*gconst6*gconst9*npy*sj5))+(((-0.304)*gconst11*gconst12*gconst7*npy))+(((-2.0)*gconst12*gconst3*gconst8*npy*sj5))+(((-0.304)*gconst12*gconst15*gconst3*npy))+(((-2.0)*gconst1*gconst13*gconst14*npy*sj5))+(((-0.304)*gconst0*gconst11*gconst15*npy))+(((-2.0)*gconst11*gconst4*gconst8*npy*sj5))+(((2.0)*gconst0*gconst13*gconst14*npy*sj5))+(((-0.03417855)*gconst1*npy*sj5))+(((-0.03417855)*gconst4*npy*sj5))+(((0.304)*gconst11*gconst14*gconst5*npy))+(((0.304)*gconst13*gconst14*gconst3*npy))+(((2.0)*gconst15*gconst4*gconst9*npy*sj5)));
op[4]=((((-4.0)*gconst1*gconst13*(npy*npy)*(sj5*sj5)))+(((-1.0)*gconst0*gconst11*gconst12*gconst7))+((gconst1*gconst10*gconst12*gconst7))+(((-0.608)*gconst13*gconst2*sj5*(npy*npy)))+(((0.608)*gconst10*gconst4*sj5*(npy*npy)))+(((-0.05297838005)*gconst11*gconst6))+(((-0.02205)*gconst1*gconst12))+(((-0.026489190025)*gconst11*gconst14))+(((-0.05297838005)*gconst14*gconst3))+(((-1.0)*gconst1*gconst10*gconst13*gconst6))+(((0.608)*gconst12*gconst2*sj5*(npy*npy)))+(((4.0)*gconst0*gconst13*(npy*npy)*(sj5*sj5)))+((gconst11*gconst5*gconst6*gconst8))+(((-0.03417855)*gconst1*gconst14))+(((-1.0)*gconst0*gconst12*gconst15*gconst3))+(((-0.608)*gconst6*gconst9*sj5*(npy*npy)))+(((-0.608)*gconst11*gconst4*sj5*(npy*npy)))+(((0.608)*gconst6*gconst8*sj5*(npy*npy)))+(((-0.0415611168)*sj5*(npy*npy)))+((gconst0*gconst11*gconst14*gconst5))+(((-0.017089275)*gconst1*gconst6))+((gconst12*gconst2*gconst7*gconst9))+(((-1.0)*gconst12*gconst3*gconst7*gconst8))+(((-0.2119135202)*(npy*npy)*(sj5*sj5)))+(((0.092416)*gconst11*gconst6*(npy*npy)))+(((-0.608)*gconst7*gconst8*sj5*(npy*npy)))+(((-1.0)*gconst10*gconst5*gconst6*gconst9))+(((-1.0)*gconst14*gconst2*gconst5*gconst9))+(((-4.0)*gconst5*gconst9*(npy*npy)*(sj5*sj5)))+(((-4.0)*gconst0*gconst12*(npy*npy)*(sj5*sj5)))+(((-0.092416)*gconst14*gconst2*(npy*npy)))+(((0.092416)*gconst14*gconst3*(npy*npy)))+(((4.0)*gconst1*gconst12*(npy*npy)*(sj5*sj5)))+(((-1.0)*gconst13*gconst2*gconst6*gconst9))+(((-0.017089275)*gconst3*gconst4))+(((-0.608)*gconst10*gconst5*sj5*(npy*npy)))+(((-4.0)*gconst4*gconst8*(npy*npy)*(sj5*sj5)))+(((-0.092416)*gconst15*gconst3*(npy*npy)))+((gconst15*gconst2*gconst4*gconst9))+((gconst10*gconst4*gconst7*gconst9))+((gconst0*gconst13*gconst14*gconst3))+(((-0.092416)*gconst10*gconst6*(npy*npy)))+(((4.0)*gconst5*gconst8*(npy*npy)*(sj5*sj5)))+((gconst0*gconst11*gconst13*gconst6))+(((0.608)*gconst1*gconst15*sj5*(npy*npy)))+(((-0.017089275)*gconst11*gconst12))+(((-0.608)*gconst1*gconst14*sj5*(npy*npy)))+(((-0.011025)*gconst12*gconst9))+(((-0.026489190025)*gconst3*gconst6))+((gconst1*gconst10*gconst15*gconst4))+(((-0.017089275)*gconst14*gconst9))+(((-1.0)*gconst1*gconst13*gconst14*gconst2))+((gconst14*gconst3*gconst5*gconst8))+(((-0.0020377728)*(npy*npy)))+(((-1.0)*gconst0*gconst11*gconst15*gconst4))+(((-0.03417855)*gconst12*gconst3))+((gconst13*gconst3*gconst6*gconst8))+(((0.608)*gconst7*gconst9*sj5*(npy*npy)))+((gconst1*gconst12*gconst15*gconst2))+(((-0.608)*gconst0*gconst15*sj5*(npy*npy)))+(((-0.03417855)*gconst11*gconst4))+(((0.608)*gconst0*gconst14*sj5*(npy*npy)))+(((-0.608)*gconst12*gconst3*sj5*(npy*npy)))+(((0.092416)*gconst10*gconst7*(npy*npy)))+(((0.608)*gconst13*gconst3*sj5*(npy*npy)))+(((0.092416)*gconst15*gconst2*(npy*npy)))+(((4.0)*gconst4*gconst9*(npy*npy)*(sj5*sj5)))+(((-0.092416)*gconst11*gconst7*(npy*npy)))+(((-0.02205)*gconst4*gconst9))+(((-0.03417855)*gconst6*gconst9))+(((-1.0)*gconst1*gconst10*gconst14*gconst5))+(((0.608)*gconst11*gconst5*sj5*(npy*npy)))+(((-1.0)*gconst11*gconst4*gconst7*gconst8))+(((-0.011025)*gconst1*gconst4))+(((-1.0)*gconst15*gconst3*gconst4*gconst8)));
op[5]=((((2.0)*gconst1*gconst12*gconst7*npy*sj5))+(((2.0)*gconst0*gconst13*gconst6*npy*sj5))+(((2.0)*gconst0*gconst14*gconst5*npy*sj5))+(((2.0)*gconst1*gconst10*gconst4*npy*sj5))+(((-0.304)*gconst11*gconst4*gconst7*npy))+(((-0.1059567601)*gconst3*npy*sj5))+(((-0.304)*gconst1*gconst10*gconst6*npy))+(((-0.0067032)*gconst4*npy))+(((-2.0)*gconst1*gconst14*gconst5*npy*sj5))+(((-0.05297838005)*gconst11*npy*sj5))+(((0.304)*gconst1*gconst10*gconst7*npy))+(((0.304)*gconst12*gconst2*gconst7*npy))+(((-0.304)*gconst10*gconst5*gconst6*npy))+(((-0.304)*gconst12*gconst3*gconst7*npy))+(((-0.0683571)*gconst1*npy*sj5))+(((-2.0)*gconst1*gconst13*gconst2*npy*sj5))+(((-2.0)*gconst3*gconst4*gconst8*npy*sj5))+(((2.0)*gconst4*gconst7*gconst9*npy*sj5))+(((-0.05297838005)*gconst14*npy*sj5))+(((0.304)*gconst1*gconst15*gconst2*npy))+(((-0.0103902792)*gconst6*npy))+(((2.0)*gconst1*gconst15*gconst4*npy*sj5))+(((-0.304)*gconst15*gconst3*gconst4*npy))+(((2.0)*gconst2*gconst4*gconst9*npy*sj5))+(((-2.0)*gconst4*gconst7*gconst8*npy*sj5))+(((-2.0)*gconst0*gconst12*gconst3*npy*sj5))+(((-2.0)*gconst0*gconst15*gconst4*npy*sj5))+(((-0.304)*gconst2*gconst6*gconst9*npy))+(((-0.03417855)*gconst12*npy*sj5))+(((2.0)*gconst0*gconst13*gconst3*npy*sj5))+(((-0.1059567601)*gconst6*npy*sj5))+(((-2.0)*gconst1*gconst10*gconst5*npy*sj5))+(((-0.304)*gconst0*gconst11*gconst7*npy))+(((0.304)*gconst11*gconst5*gconst6*npy))+(((-2.0)*gconst1*gconst13*gconst6*npy*sj5))+(((-2.0)*gconst0*gconst11*gconst4*npy*sj5))+(((2.0)*gconst3*gconst5*gconst8*npy*sj5))+(((0.304)*gconst2*gconst7*gconst9*npy))+(((-2.0)*gconst0*gconst12*gconst7*npy*sj5))+(((-0.0051951396)*gconst14*npy))+(((-0.304)*gconst14*gconst2*gconst5*npy))+(((-0.304)*gconst1*gconst14*gconst2*npy))+(((-0.0683571)*gconst4*npy*sj5))+(((2.0)*gconst5*gconst6*gconst8*npy*sj5))+(((-0.0067032)*gconst1*npy))+(((0.304)*gconst3*gconst6*gconst8*npy))+(((0.304)*gconst15*gconst2*gconst4*npy))+(((-0.03417855)*gconst9*npy*sj5))+(((0.304)*gconst10*gconst4*gconst7*npy))+(((0.304)*gconst14*gconst3*gconst5*npy))+(((-0.0033516)*gconst9*npy))+(((-0.0051951396)*gconst11*npy))+(((-0.304)*gconst0*gconst15*gconst3*npy))+(((0.304)*gconst13*gconst3*gconst6*npy))+(((2.0)*gconst0*gconst11*gconst5*npy*sj5))+(((-2.0)*gconst5*gconst6*gconst9*npy*sj5))+(((-0.304)*gconst13*gconst2*gconst6*npy))+(((2.0)*gconst1*gconst12*gconst2*npy*sj5))+(((-2.0)*gconst2*gconst5*gconst9*npy*sj5))+(((-0.0033516)*gconst12*npy))+(((-0.0103902792)*gconst3*npy))+(((0.304)*gconst0*gconst11*gconst6*npy))+(((0.304)*gconst0*gconst14*gconst3*npy))+(((-0.304)*gconst3*gconst7*gconst8*npy)));
op[6]=((((-1.0)*gconst3*x105))+(((-1.0)*gconst7*x123*x149))+((gconst3*gconst6*x153))+(((-1.0)*sj5*x149*x99))+(((-1.0)*x159))+((x113*x153))+(((-1.0)*gconst12*x101*x102))+((x92*x93))+(((-1.0)*gconst2*gconst6*x153))+(((-1.0)*gconst4*x101*x127))+((sj5*x149*x91))+((sj5*x126*x149))+(((-1.0)*gconst4*x102*x92))+((x100*x148*x89))+(((-1.0)*gconst13*x119*x99))+(((-1.0)*gconst10*x107*x93))+((gconst10*gconst4*x91))+((gconst5*x115*x149))+((x113*x135))+(((-1.0)*gconst4*x115*x149))+((gconst12*gconst2*x91))+(((-0.03417855)*x99))+(((-0.02205)*x100))+((gconst5*x148*x154))+(((-1.0)*gconst4*x148*x154))+(((-1.0)*gconst1*gconst5*x148*x89))+(((-1.0)*gconst9*x119*x93))+((x116*x93))+(((-1.0)*gconst4*x102*x116))+(((-1.0)*gconst14*x107*x108))+((x100*x133))+(((-1.0)*sj5*x108*x149))+((gconst14*gconst5*x101))+(((-1.0)*gconst3*x114))+((gconst6*x123*x149))+((x101*x136))+(((-1.0)*gconst3*gconst7*x153)));
op[7]=((((-1.0)*gconst3*x109))+(((-1.0)*x104*x105))+((gconst6*x101*x106))+(((2.0)*gconst5*x101*x104))+(((-1.0)*gconst7*x101*x106))+((gconst4*x106*x113))+((x104*x120*x91))+(((2.0)*gconst2*x100*x104))+((x146*x91))+(((-0.03417855)*gconst1*x104))+(((-0.05297838005)*gconst3*x104))+(((-1.0)*x104*x118*x128))+(((-1.0)*gconst6*x109))+(((-1.0)*gconst1*x103))+((x104*x118*x93))+(((-1.0)*gconst3*x106*x128))+(((-1.0)*x104*x132*x93))+(((-1.0)*x146*x93))+(((-1.0)*x146*x99))+(((-1.0)*gconst4*x103))+(((-1.0)*x104*x108*x132))+((gconst3*x106*x93))+(((-1.0)*x101*x104*x120))+(((-1.0)*x104*x114)));
op[8]=(((x126*x91))+(((-1.0)*gconst4*x101*x102))+(((-0.011025)*x100))+((x101*x93))+(((-0.017089275)*x99))+(((-1.0)*gconst2*x107*x93))+(((-1.0)*gconst4*x112))+(((-1.0)*gconst3*x111)));
polyroots8(op,zeror,numroots);
IkReal j6array[8], cj6array[8], sj6array[8], tempj6array[1];
int numsolutions = 0;
for(int ij6 = 0; ij6 < numroots; ++ij6)
{
IkReal htj6 = zeror[ij6];
tempj6array[0]=((2.0)*(atan(htj6)));
for(int kj6 = 0; kj6 < 1; ++kj6)
{
j6array[numsolutions] = tempj6array[kj6];
if( j6array[numsolutions] > IKPI )
{
    j6array[numsolutions]-=IK2PI;
}
else if( j6array[numsolutions] < -IKPI )
{
    j6array[numsolutions]+=IK2PI;
}
sj6array[numsolutions] = IKsin(j6array[numsolutions]);
cj6array[numsolutions] = IKcos(j6array[numsolutions]);
numsolutions++;
}
}
bool j6valid[8]={true,true,true,true,true,true,true,true};
_nj6 = 8;
for(int ij6 = 0; ij6 < numsolutions; ++ij6)
    {
if( !j6valid[ij6] )
{
    continue;
}
    j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
htj6 = IKtan(j6/2);

_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < numsolutions; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x160=(cj6*npx);
IkReal x161=((14.0214148455304)*sj5);
IkReal x162=(cj5*npz);
IkReal x163=(npy*sj6);
IkReal x164=((5.92533883750972)*sj5);
if( IKabs(((0.40446420063036)+(((-3.24279918241938)*x160))+((x161*x163))+(((-1.0)*x160*x161))+(((21.3342051474959)*pp))+(((-14.0214148455304)*x162))+(((1.06562752826031)*sj5))+(((3.24279918241938)*x163)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((1.24141423390134)+(((-1.0)*x160*x164))+(((0.450325751650739)*sj5))+(((0.581047635075144)*x163))+(((3.8226818097049)*pp))+(((-0.581047635075144)*x160))+(((-5.92533883750972)*x162))+((x163*x164)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.40446420063036)+(((-3.24279918241938)*x160))+((x161*x163))+(((-1.0)*x160*x161))+(((21.3342051474959)*pp))+(((-14.0214148455304)*x162))+(((1.06562752826031)*sj5))+(((3.24279918241938)*x163))))+IKsqr(((1.24141423390134)+(((-1.0)*x160*x164))+(((0.450325751650739)*sj5))+(((0.581047635075144)*x163))+(((3.8226818097049)*pp))+(((-0.581047635075144)*x160))+(((-5.92533883750972)*x162))+((x163*x164))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((0.40446420063036)+(((-3.24279918241938)*x160))+((x161*x163))+(((-1.0)*x160*x161))+(((21.3342051474959)*pp))+(((-14.0214148455304)*x162))+(((1.06562752826031)*sj5))+(((3.24279918241938)*x163))), ((1.24141423390134)+(((-1.0)*x160*x164))+(((0.450325751650739)*sj5))+(((0.581047635075144)*x163))+(((3.8226818097049)*pp))+(((-0.581047635075144)*x160))+(((-5.92533883750972)*x162))+((x163*x164))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[2];
IkReal x165=IKsin(j3);
IkReal x166=IKcos(j3);
IkReal x167=(npy*sj6);
IkReal x168=(cj6*npx);
evalcond[0]=((-0.20614175)+(((-0.0813775)*x165))+(((-0.152)*x168))+(((0.1925675)*x166))+pp+(((0.152)*x167)));
evalcond[1]=((0.3425)+(((0.0525)*x165))+(((0.076)*sj5))+(((-1.0)*sj5*x168))+(((-1.0)*cj5*npz))+(((-0.293)*x166))+((sj5*x167)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j4eval[2];
IkReal x169=((1.0)*cj3);
IkReal x170=((5.58095238095238)*sj3);
j4eval[0]=((-1.47619047619048)+(((-1.0)*x169))+(((-1.0)*x170)));
j4eval[1]=((((-1.47619047619048)*sj5))+(((-1.0)*sj5*x169))+(((-1.0)*sj5*x170)));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
IkReal x171=((5.58095238095238)*sj3);
j4eval[0]=((-1.47619047619048)+(((-1.0)*x171))+(((-1.0)*cj3)));
j4eval[1]=(((cj5*x171))+((cj3*cj5))+(((1.47619047619048)*cj5)));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
IkReal x172=(npx*sj6);
IkReal x173=((5.58095238095238)*sj3);
IkReal x174=(cj6*npy);
j4eval[0]=((-1.47619047619048)+(((-1.0)*x173))+(((-1.0)*cj3)));
j4eval[1]=(((x172*x173))+((x173*x174))+(((1.47619047619048)*x172))+(((1.47619047619048)*x174))+((cj3*x172))+((cj3*x174)));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.2276868576215)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
sj3=-0.08598789;
cj3=-0.99629618;
j3=3.22768551701203;
j4eval[0]=sj5;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
sj3=-0.08598789;
cj3=-0.99629618;
j3=3.22768551701203;
j4eval[0]=cj5;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
sj3=-0.08598789;
cj3=-0.99629618;
j3=3.22768551701203;
j4eval[0]=(((cj5*cj6*npy))+((cj5*npx*sj6)));
j4eval[1]=cj5;
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((((819672131.147541)*npx*sj6))+(((819672131.147541)*cj6*npy)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((819672131.147541)*npz)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((819672131.147541)*npx*sj6))+(((819672131.147541)*cj6*npy))))+IKsqr(((819672131.147541)*npz))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((819672131.147541)*npx*sj6))+(((819672131.147541)*cj6*npy))), ((819672131.147541)*npz));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x175=IKsin(j4);
IkReal x176=IKcos(j4);
IkReal x177=(cj6*npy);
IkReal x178=((1.0)*npx*sj6);
evalcond[0]=((((1.22e-9)*x176))+(((-1.0)*npz)));
evalcond[1]=((((1.22e-9)*x175))+(((-1.0)*x178))+(((-1.0)*x177)));
evalcond[2]=((-1.22e-9)+((npz*x176))+((npx*sj6*x175))+((x175*x177)));
evalcond[3]=(((npz*x175))+(((-1.0)*x176*x178))+(((-1.0)*x176*x177)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((((819672131.147541)*npx*sj6))+(((819672131.147541)*cj6*npy)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-819672131.147541)*npz)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((819672131.147541)*npx*sj6))+(((819672131.147541)*cj6*npy))))+IKsqr(((-819672131.147541)*npz))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((819672131.147541)*npx*sj6))+(((819672131.147541)*cj6*npy))), ((-819672131.147541)*npz));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x721=IKsin(j4);
IkReal x722=IKcos(j4);
IkReal x723=((1.0)*npz);
IkReal x724=(cj6*npy);
IkReal x725=((1.0)*npx*sj6);
evalcond[0]=((((-1.0)*x723))+(((-1.22e-9)*x722)));
evalcond[1]=((((1.22e-9)*x721))+(((-1.0)*x725))+(((-1.0)*x724)));
evalcond[2]=((-1.22e-9)+((x721*x724))+(((-1.0)*x722*x723))+((npx*sj6*x721)));
evalcond[3]=((((-1.0)*x722*x725))+(((-1.0)*x722*x724))+(((-1.0)*x721*x723)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((((819672131.147541)*npx*sj6))+(((819672131.147541)*cj6*npy)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((2170785888.28556)+(((-5392579810.18119)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((819672131.147541)*npx*sj6))+(((819672131.147541)*cj6*npy))))+IKsqr(((2170785888.28556)+(((-5392579810.18119)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((819672131.147541)*npx*sj6))+(((819672131.147541)*cj6*npy))), ((2170785888.28556)+(((-5392579810.18119)*pp))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[5];
IkReal x726=IKcos(j4);
IkReal x727=IKsin(j4);
IkReal x728=((1.0)*cj6);
IkReal x729=(npx*x727);
IkReal x730=((1.0)*npx*sj6);
IkReal x731=(npy*x727);
IkReal x732=(npy*x726);
evalcond[0]=((-0.402550535123675)+(((1.8544e-10)*x726))+pp);
evalcond[1]=((2.64835878370839)+(((-6.57894736842105)*pp))+(((-1.22e-9)*x726)));
evalcond[2]=((((1.22e-9)*x727))+(((-1.0)*npy*x728))+(((-1.0)*x730)));
evalcond[3]=((-1.22e-9)+(((0.076)*x726))+((cj6*x731))+((sj6*x729))+((sj6*x732))+(((-1.0)*npx*x726*x728)));
evalcond[4]=((((0.076)*x727))+((sj6*x731))+(((-1.0)*x726*x730))+(((-1.0)*x728*x732))+(((-1.0)*x728*x729)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((((819672131.147541)*npx*sj6))+(((819672131.147541)*cj6*npy)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-2170785888.28556)+(((5392579810.18119)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((819672131.147541)*npx*sj6))+(((819672131.147541)*cj6*npy))))+IKsqr(((-2170785888.28556)+(((5392579810.18119)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((819672131.147541)*npx*sj6))+(((819672131.147541)*cj6*npy))), ((-2170785888.28556)+(((5392579810.18119)*pp))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[5];
IkReal x733=IKcos(j4);
IkReal x734=IKsin(j4);
IkReal x735=((1.0)*npy);
IkReal x736=((1.0)*npx);
IkReal x737=(sj6*x733);
IkReal x738=(cj6*x734);
IkReal x739=(cj6*x733);
IkReal x740=(sj6*x734);
evalcond[0]=((-0.402550535123675)+(((-1.8544e-10)*x733))+pp);
evalcond[1]=((2.64835878370839)+(((1.22e-9)*x733))+(((-6.57894736842105)*pp)));
evalcond[2]=((((1.22e-9)*x734))+(((-1.0)*cj6*x735))+(((-1.0)*sj6*x736)));
evalcond[3]=((-1.22e-9)+((npx*x740))+(((-0.076)*x733))+(((-1.0)*x735*x737))+((npy*x738))+((npx*x739)));
evalcond[4]=((((-1.0)*x736*x737))+(((-0.076)*x734))+(((-1.0)*x735*x739))+((npx*x738))+(((-1.0)*x735*x740)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x741=((2.99202697844625e+22)*npz);
IkReal x742=(cj5*cj6);
IkReal x743=((2.99202697844625e+22)*sj5);
IkReal x744=(cj5*sj6);
IkReal x745=((3.125e+23)*pp);
IkReal x746=(npz*sj5);
CheckValue<IkReal> x747=IKPowWithIntegerCheck(((((57950000000000.0)*npy*x742))+(((57950000000000.0)*npx*x744))),-1);
if(!x747.valid){
continue;
}
CheckValue<IkReal> x748=IKPowWithIntegerCheck(cj5,-1);
if(!x748.valid){
continue;
}
if( IKabs(((x747.value)*((((x745*x746))+(((-1.0)*npx*x742*x745))+(((-1.25797042226148e+23)*x746))+(((-2.27394050361915e+21)*cj5*sj5))+(((2.375e+22)*cj5*pp))+((npx*x742*x743))+(((1.25797042226148e+23)*npx*x742))+(((-9.56057520918728e+21)*cj5))+((npy*x744*x745))+((x741*(cj5*cj5)))+(((-1.25797042226148e+23)*npy*x744))+(((-1.0)*x741))+(((-1.0)*npy*x743*x744)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((0.000862812769628991)*(x748.value)*(((2515940844522.97)+(((598405395689.25)*sj5))+(((-6250000000000.0)*pp)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x747.value)*((((x745*x746))+(((-1.0)*npx*x742*x745))+(((-1.25797042226148e+23)*x746))+(((-2.27394050361915e+21)*cj5*sj5))+(((2.375e+22)*cj5*pp))+((npx*x742*x743))+(((1.25797042226148e+23)*npx*x742))+(((-9.56057520918728e+21)*cj5))+((npy*x744*x745))+((x741*(cj5*cj5)))+(((-1.25797042226148e+23)*npy*x744))+(((-1.0)*x741))+(((-1.0)*npy*x743*x744))))))+IKsqr(((0.000862812769628991)*(x748.value)*(((2515940844522.97)+(((598405395689.25)*sj5))+(((-6250000000000.0)*pp))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x747.value)*((((x745*x746))+(((-1.0)*npx*x742*x745))+(((-1.25797042226148e+23)*x746))+(((-2.27394050361915e+21)*cj5*sj5))+(((2.375e+22)*cj5*pp))+((npx*x742*x743))+(((1.25797042226148e+23)*npx*x742))+(((-9.56057520918728e+21)*cj5))+((npy*x744*x745))+((x741*(cj5*cj5)))+(((-1.25797042226148e+23)*npy*x744))+(((-1.0)*x741))+(((-1.0)*npy*x743*x744))))), ((0.000862812769628991)*(x748.value)*(((2515940844522.97)+(((598405395689.25)*sj5))+(((-6250000000000.0)*pp))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x749=IKcos(j4);
IkReal x750=IKsin(j4);
IkReal x751=(npy*sj6);
IkReal x752=((1.0)*cj6);
IkReal x753=(npz*sj5);
IkReal x754=((1.22e-9)*x749);
IkReal x755=(cj5*x749);
IkReal x756=((1.0)*npx*sj6);
IkReal x757=(cj5*x750);
evalcond[0]=((-0.402550535123675)+(((1.8544e-10)*x755))+pp+(((-0.09574486331028)*sj5)));
evalcond[1]=((((-1.0)*npz))+(((0.629900416515)*cj5))+((sj5*x754)));
evalcond[2]=((((1.22e-9)*x750))+(((-1.0)*x756))+(((-1.0)*npy*x752)));
evalcond[3]=((0.076)+(((-1.0)*npx*x752))+(((-1.0)*cj5*x754))+(((0.629900416515)*sj5))+x751);
evalcond[4]=((-1.22e-9)+((npx*sj6*x750))+((x751*x755))+(((-1.0)*npx*x752*x755))+(((0.076)*x755))+((cj6*npy*x750))+((x749*x753)));
evalcond[5]=(((x751*x757))+(((-1.0)*npx*x752*x757))+(((0.076)*x757))+(((-1.0)*x749*x756))+(((-1.0)*npy*x749*x752))+((x750*x753)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x758=IKPowWithIntegerCheck(cj5,-1);
if(!x758.valid){
continue;
}
if( IKabs(((((819672131.147541)*npx*sj6))+(((819672131.147541)*cj6*npy)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((0.000862812769628991)*(x758.value)*(((2515940844522.97)+(((598405395689.25)*sj5))+(((-6250000000000.0)*pp)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((819672131.147541)*npx*sj6))+(((819672131.147541)*cj6*npy))))+IKsqr(((0.000862812769628991)*(x758.value)*(((2515940844522.97)+(((598405395689.25)*sj5))+(((-6250000000000.0)*pp))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((819672131.147541)*npx*sj6))+(((819672131.147541)*cj6*npy))), ((0.000862812769628991)*(x758.value)*(((2515940844522.97)+(((598405395689.25)*sj5))+(((-6250000000000.0)*pp))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x759=IKcos(j4);
IkReal x760=IKsin(j4);
IkReal x761=(npy*sj6);
IkReal x762=((1.0)*cj6);
IkReal x763=(npz*sj5);
IkReal x764=((1.22e-9)*x759);
IkReal x765=(cj5*x759);
IkReal x766=((1.0)*npx*sj6);
IkReal x767=(cj5*x760);
evalcond[0]=((-0.402550535123675)+pp+(((1.8544e-10)*x765))+(((-0.09574486331028)*sj5)));
evalcond[1]=((((-1.0)*npz))+(((0.629900416515)*cj5))+((sj5*x764)));
evalcond[2]=((((-1.0)*x766))+(((-1.0)*npy*x762))+(((1.22e-9)*x760)));
evalcond[3]=((0.076)+(((-1.0)*npx*x762))+(((0.629900416515)*sj5))+x761+(((-1.0)*cj5*x764)));
evalcond[4]=((-1.22e-9)+((npx*sj6*x760))+(((-1.0)*npx*x762*x765))+((x759*x763))+((x761*x765))+(((0.076)*x765))+((cj6*npy*x760)));
evalcond[5]=((((-1.0)*npx*x762*x767))+((x760*x763))+((x761*x767))+(((-1.0)*npy*x759*x762))+(((0.076)*x767))+(((-1.0)*x759*x766)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x768=IKPowWithIntegerCheck(sj5,-1);
if(!x768.valid){
continue;
}
if( IKabs(((((819672131.147541)*npx*sj6))+(((819672131.147541)*cj6*npy)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((0.0163934426229508)*(x768.value)*(((((50000000000.0)*npz))+(((-31495020825.75)*cj5)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((819672131.147541)*npx*sj6))+(((819672131.147541)*cj6*npy))))+IKsqr(((0.0163934426229508)*(x768.value)*(((((50000000000.0)*npz))+(((-31495020825.75)*cj5))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((819672131.147541)*npx*sj6))+(((819672131.147541)*cj6*npy))), ((0.0163934426229508)*(x768.value)*(((((50000000000.0)*npz))+(((-31495020825.75)*cj5))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x769=IKcos(j4);
IkReal x770=IKsin(j4);
IkReal x771=(npy*sj6);
IkReal x772=((1.0)*cj6);
IkReal x773=(npz*sj5);
IkReal x774=((1.22e-9)*x769);
IkReal x775=(cj5*x769);
IkReal x776=((1.0)*npx*sj6);
IkReal x777=(cj5*x770);
evalcond[0]=((-0.402550535123675)+(((1.8544e-10)*x775))+pp+(((-0.09574486331028)*sj5)));
evalcond[1]=((((-1.0)*npz))+(((0.629900416515)*cj5))+((sj5*x774)));
evalcond[2]=((((-1.0)*npy*x772))+(((-1.0)*x776))+(((1.22e-9)*x770)));
evalcond[3]=((0.076)+(((-1.0)*npx*x772))+(((-1.0)*cj5*x774))+(((0.629900416515)*sj5))+x771);
evalcond[4]=((-1.22e-9)+((npx*sj6*x770))+((x771*x775))+((x769*x773))+(((0.076)*x775))+(((-1.0)*npx*x772*x775))+((cj6*npy*x770)));
evalcond[5]=(((x771*x777))+((x770*x773))+(((-1.0)*npy*x769*x772))+(((0.076)*x777))+(((-1.0)*npx*x772*x777))+(((-1.0)*x769*x776)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-5.8424922655324)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
sj3=-0.426566392851566;
cj3=0.90445625;
j3=5.84249356263499;
j4eval[0]=sj5;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
sj3=-0.426566392851566;
cj3=0.90445625;
j3=5.84249356263499;
j4eval[0]=cj5;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
sj3=-0.426566392851566;
cj3=0.90445625;
j3=5.84249356263499;
j4eval[0]=(((cj5*cj6*npy))+((cj5*npx*sj6)));
j4eval[1]=cj5;
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((((-51305507480.2948)*npx*sj6))+(((-51305507480.2948)*cj6*npy)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-51305507480.2948)*npz)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-51305507480.2948)*npx*sj6))+(((-51305507480.2948)*cj6*npy))))+IKsqr(((-51305507480.2948)*npz))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((-51305507480.2948)*npx*sj6))+(((-51305507480.2948)*cj6*npy))), ((-51305507480.2948)*npz));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x778=IKsin(j4);
IkReal x779=IKcos(j4);
IkReal x780=(cj6*npy);
IkReal x781=((1.0)*npx*sj6);
evalcond[0]=((((-1.0)*npz))+(((-1.94910848583668e-11)*x779)));
evalcond[1]=((((-1.0)*x781))+(((-1.0)*x780))+(((-1.94910848583668e-11)*x778)));
evalcond[2]=((1.94910848583668e-11)+((npx*sj6*x778))+((x778*x780))+((npz*x779)));
evalcond[3]=(((npz*x778))+(((-1.0)*x779*x780))+(((-1.0)*x779*x781)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((((-51305507480.2948)*npx*sj6))+(((-51305507480.2948)*cj6*npy)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((51305507480.2948)*npz)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-51305507480.2948)*npx*sj6))+(((-51305507480.2948)*cj6*npy))))+IKsqr(((51305507480.2948)*npz))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((-51305507480.2948)*npx*sj6))+(((-51305507480.2948)*cj6*npy))), ((51305507480.2948)*npz));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x782=IKsin(j4);
IkReal x783=IKcos(j4);
IkReal x784=((1.0)*npz);
IkReal x785=(cj6*npy);
IkReal x786=((1.0)*npx*sj6);
evalcond[0]=((((-1.0)*x784))+(((1.94910848583668e-11)*x783)));
evalcond[1]=((((-1.0)*x786))+(((-1.94910848583668e-11)*x782))+(((-1.0)*x785)));
evalcond[2]=((1.94910848583668e-11)+((npx*sj6*x782))+((x782*x785))+(((-1.0)*x783*x784)));
evalcond[3]=((((-1.0)*x782*x784))+(((-1.0)*x783*x785))+(((-1.0)*x783*x786)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((((-51305507480.2948)*npx*sj6))+(((-51305507480.2948)*cj6*npy)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-2974357287.43333)+(((337536233422.992)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-51305507480.2948)*npx*sj6))+(((-51305507480.2948)*cj6*npy))))+IKsqr(((-2974357287.43333)+(((337536233422.992)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((-51305507480.2948)*npx*sj6))+(((-51305507480.2948)*cj6*npy))), ((-2974357287.43333)+(((337536233422.992)*pp))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[5];
IkReal x787=IKcos(j4);
IkReal x788=IKsin(j4);
IkReal x789=((1.0)*cj6);
IkReal x790=(npx*x788);
IkReal x791=((1.0)*npx*sj6);
IkReal x792=(npy*x788);
IkReal x793=(npy*x787);
evalcond[0]=((-0.00881196444384667)+pp+(((-2.96264489847176e-12)*x787)));
evalcond[1]=((0.0579734502884649)+(((-6.57894736842105)*pp))+(((1.94910848583668e-11)*x787)));
evalcond[2]=((((-1.0)*x791))+(((-1.94910848583668e-11)*x788))+(((-1.0)*npy*x789)));
evalcond[3]=((1.94910848583668e-11)+((cj6*x792))+((sj6*x793))+((sj6*x790))+(((-1.0)*npx*x787*x789))+(((0.076)*x787)));
evalcond[4]=(((sj6*x792))+(((-1.0)*x787*x791))+(((-1.0)*x789*x790))+(((-1.0)*x789*x793))+(((0.076)*x788)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((((-51305507480.2948)*npx*sj6))+(((-51305507480.2948)*cj6*npy)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((2974357287.43333)+(((-337536233422.992)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-51305507480.2948)*npx*sj6))+(((-51305507480.2948)*cj6*npy))))+IKsqr(((2974357287.43333)+(((-337536233422.992)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((-51305507480.2948)*npx*sj6))+(((-51305507480.2948)*cj6*npy))), ((2974357287.43333)+(((-337536233422.992)*pp))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[5];
IkReal x794=IKcos(j4);
IkReal x795=IKsin(j4);
IkReal x796=((1.0)*npy);
IkReal x797=((1.0)*npx);
IkReal x798=(sj6*x794);
IkReal x799=(cj6*x795);
IkReal x800=(cj6*x794);
IkReal x801=(sj6*x795);
evalcond[0]=((-0.00881196444384667)+(((2.96264489847176e-12)*x794))+pp);
evalcond[1]=((0.0579734502884649)+(((-6.57894736842105)*pp))+(((-1.94910848583668e-11)*x794)));
evalcond[2]=((((-1.0)*cj6*x796))+(((-1.94910848583668e-11)*x795))+(((-1.0)*sj6*x797)));
evalcond[3]=((1.94910848583668e-11)+((npy*x799))+(((-1.0)*x796*x798))+(((-0.076)*x794))+((npx*x801))+((npx*x800)));
evalcond[4]=((((-1.0)*x796*x801))+(((-1.0)*x796*x800))+(((-0.076)*x795))+(((-1.0)*x797*x798))+((npx*x799)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x802=(cj5*sj5);
IkReal x803=(npy*sj6);
IkReal x804=((9.4264589453434e+30)*npz);
IkReal x805=(cj5*npx);
IkReal x806=((1.1255289741662e+33)*pp);
IkReal x807=(npz*sj5);
CheckValue<IkReal> x808=IKPowWithIntegerCheck(((((3.33454267339565e+21)*sj6*x805))+(((3.33454267339565e+21)*cj5*cj6*npy))),-1);
if(!x808.valid){
continue;
}
CheckValue<IkReal> x809=IKPowWithIntegerCheck(cj5,-1);
if(!x809.valid){
continue;
}
if( IKabs(((x808.value)*(((((9.91812130087177e+30)*x807))+(((7.53777218866255e+29)*cj5))+(((9.91812130087177e+30)*cj5*x803))+(((-1.0)*x806*x807))+(((7.16410879846099e+29)*x802))+(((9.4264589453434e+30)*x802*x803))+(((-1.0)*x804*(cj5*cj5)))+(((-9.91812130087177e+30)*cj6*x805))+(((-9.4264589453434e+30)*cj6*npx*x802))+(((-8.55402020366313e+31)*cj5*pp))+(((-1.0)*cj5*x803*x806))+x804+((cj6*x805*x806)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((8.99885084674687e-7)*(x809.value)*(((-3.30526345873215e+15)+(((-3.14141452318634e+15)*sj5))+(((3.75088152e+17)*pp)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x808.value)*(((((9.91812130087177e+30)*x807))+(((7.53777218866255e+29)*cj5))+(((9.91812130087177e+30)*cj5*x803))+(((-1.0)*x806*x807))+(((7.16410879846099e+29)*x802))+(((9.4264589453434e+30)*x802*x803))+(((-1.0)*x804*(cj5*cj5)))+(((-9.91812130087177e+30)*cj6*x805))+(((-9.4264589453434e+30)*cj6*npx*x802))+(((-8.55402020366313e+31)*cj5*pp))+(((-1.0)*cj5*x803*x806))+x804+((cj6*x805*x806))))))+IKsqr(((8.99885084674687e-7)*(x809.value)*(((-3.30526345873215e+15)+(((-3.14141452318634e+15)*sj5))+(((3.75088152e+17)*pp))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x808.value)*(((((9.91812130087177e+30)*x807))+(((7.53777218866255e+29)*cj5))+(((9.91812130087177e+30)*cj5*x803))+(((-1.0)*x806*x807))+(((7.16410879846099e+29)*x802))+(((9.4264589453434e+30)*x802*x803))+(((-1.0)*x804*(cj5*cj5)))+(((-9.91812130087177e+30)*cj6*x805))+(((-9.4264589453434e+30)*cj6*npx*x802))+(((-8.55402020366313e+31)*cj5*pp))+(((-1.0)*cj5*x803*x806))+x804+((cj6*x805*x806))))), ((8.99885084674687e-7)*(x809.value)*(((-3.30526345873215e+15)+(((-3.14141452318634e+15)*sj5))+(((3.75088152e+17)*pp))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x810=IKcos(j4);
IkReal x811=IKsin(j4);
IkReal x812=(npy*sj6);
IkReal x813=(cj6*npy);
IkReal x814=(npz*sj5);
IkReal x815=((1.0)*npx*sj6);
IkReal x816=(cj5*x810);
IkReal x817=((1.0)*cj6*npx);
IkReal x818=(cj5*x811);
evalcond[0]=((-0.00881196444384667)+(((-0.0083751366350445)*sj5))+pp+(((-2.96264489847176e-12)*x816)));
evalcond[1]=((((-1.94910848583668e-11)*sj5*x810))+(((-1.0)*npz))+(((0.0550995831252928)*cj5)));
evalcond[2]=((((-1.0)*x815))+(((-1.0)*x813))+(((-1.94910848583668e-11)*x811)));
evalcond[3]=((0.076)+(((0.0550995831252928)*sj5))+(((-1.0)*x817))+(((1.94910848583668e-11)*x816))+x812);
evalcond[4]=((1.94910848583668e-11)+(((-1.0)*x816*x817))+((x812*x816))+((x810*x814))+((npx*sj6*x811))+(((0.076)*x816))+((x811*x813)));
evalcond[5]=((((-1.0)*x810*x813))+((x812*x818))+(((-1.0)*x817*x818))+(((0.076)*x818))+(((-1.0)*x810*x815))+((x811*x814)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x819=IKPowWithIntegerCheck(cj5,-1);
if(!x819.valid){
continue;
}
if( IKabs(((((-51305507480.2948)*npx*sj6))+(((-51305507480.2948)*cj6*npy)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((8.99885084674687e-7)*(x819.value)*(((-3.30526345873215e+15)+(((-3.14141452318634e+15)*sj5))+(((3.75088152e+17)*pp)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-51305507480.2948)*npx*sj6))+(((-51305507480.2948)*cj6*npy))))+IKsqr(((8.99885084674687e-7)*(x819.value)*(((-3.30526345873215e+15)+(((-3.14141452318634e+15)*sj5))+(((3.75088152e+17)*pp))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((-51305507480.2948)*npx*sj6))+(((-51305507480.2948)*cj6*npy))), ((8.99885084674687e-7)*(x819.value)*(((-3.30526345873215e+15)+(((-3.14141452318634e+15)*sj5))+(((3.75088152e+17)*pp))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x820=IKcos(j4);
IkReal x821=IKsin(j4);
IkReal x822=(npy*sj6);
IkReal x823=(cj6*npy);
IkReal x824=(npz*sj5);
IkReal x825=((1.0)*npx*sj6);
IkReal x826=(cj5*x820);
IkReal x827=((1.0)*cj6*npx);
IkReal x828=(cj5*x821);
evalcond[0]=((-0.00881196444384667)+(((-0.0083751366350445)*sj5))+pp+(((-2.96264489847176e-12)*x826)));
evalcond[1]=((((-1.94910848583668e-11)*sj5*x820))+(((-1.0)*npz))+(((0.0550995831252928)*cj5)));
evalcond[2]=((((-1.94910848583668e-11)*x821))+(((-1.0)*x825))+(((-1.0)*x823)));
evalcond[3]=((0.076)+(((0.0550995831252928)*sj5))+(((-1.0)*x827))+x822+(((1.94910848583668e-11)*x826)));
evalcond[4]=((1.94910848583668e-11)+((x820*x824))+((x821*x823))+(((0.076)*x826))+((npx*sj6*x821))+(((-1.0)*x826*x827))+((x822*x826)));
evalcond[5]=(((x821*x824))+(((0.076)*x828))+(((-1.0)*x827*x828))+((x822*x828))+(((-1.0)*x820*x825))+(((-1.0)*x820*x823)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x829=IKPowWithIntegerCheck(sj5,-1);
if(!x829.valid){
continue;
}
if( IKabs(((((-51305507480.2948)*npx*sj6))+(((-51305507480.2948)*cj6*npy)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((1.70978166088191e-5)*(x829.value)*(((((-3.000705216e+15)*npz))+(((165337606483492.0)*cj5)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-51305507480.2948)*npx*sj6))+(((-51305507480.2948)*cj6*npy))))+IKsqr(((1.70978166088191e-5)*(x829.value)*(((((-3.000705216e+15)*npz))+(((165337606483492.0)*cj5))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((-51305507480.2948)*npx*sj6))+(((-51305507480.2948)*cj6*npy))), ((1.70978166088191e-5)*(x829.value)*(((((-3.000705216e+15)*npz))+(((165337606483492.0)*cj5))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x830=IKcos(j4);
IkReal x831=IKsin(j4);
IkReal x832=(npy*sj6);
IkReal x833=(cj6*npy);
IkReal x834=(npz*sj5);
IkReal x835=((1.0)*npx*sj6);
IkReal x836=(cj5*x830);
IkReal x837=((1.0)*cj6*npx);
IkReal x838=(cj5*x831);
evalcond[0]=((-0.00881196444384667)+(((-0.0083751366350445)*sj5))+(((-2.96264489847176e-12)*x836))+pp);
evalcond[1]=((((-1.94910848583668e-11)*sj5*x830))+(((-1.0)*npz))+(((0.0550995831252928)*cj5)));
evalcond[2]=((((-1.0)*x835))+(((-1.0)*x833))+(((-1.94910848583668e-11)*x831)));
evalcond[3]=((0.076)+(((0.0550995831252928)*sj5))+(((1.94910848583668e-11)*x836))+(((-1.0)*x837))+x832);
evalcond[4]=((1.94910848583668e-11)+((x831*x833))+((x832*x836))+(((-1.0)*x836*x837))+((npx*sj6*x831))+((x830*x834))+(((0.076)*x836)));
evalcond[5]=(((x831*x834))+((x832*x838))+(((-1.0)*x837*x838))+(((-1.0)*x830*x835))+(((0.076)*x838))+(((-1.0)*x830*x833)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[3];
sj5=1.0;
cj5=0;
j5=1.5707963267949;
j4eval[0]=((-1.0)+(((-2.27928949646302)*sj3))+(((1.61351824021864)*pp)));
j4eval[1]=((IKabs((((cj6*npy))+((npx*sj6)))))+(IKabs(npz)));
j4eval[2]=IKsign(((-0.137229493132746)+(((0.221422290265643)*pp))+(((-0.312785742302412)*sj3))));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
sj5=1.0;
cj5=0;
j5=1.5707963267949;
j4eval[0]=((-1.47619047619048)+(((-5.58095238095238)*sj3))+(((-1.0)*cj3)));
j4eval[1]=((-1.0)+(((-2.27928949646302)*sj3))+(((1.61351824021864)*pp)));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
sj5=1.0;
cj5=0;
j5=1.5707963267949;
IkReal x839=(npx*sj6);
IkReal x840=((5.58095238095238)*sj3);
IkReal x841=(cj6*npy);
j4eval[0]=((-1.47619047619048)+(((-1.0)*x840))+(((-1.0)*cj3)));
j4eval[1]=((((1.47619047619048)*x839))+(((1.47619047619048)*x841))+((x840*x841))+((x839*x840))+((cj3*x839))+((cj3*x841)));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
IkReal gconst32=((-0.43873321118348)+(((0.70790403883424)*pp)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((0.43873321118348)+sj3+(((-0.70790403883424)*pp)))))+(IKabs(((-1.0)+(IKsign(cj3)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[3];
IkReal x842=((-0.438733210502659)+(((0.707904040266035)*pp)));
sj5=1.0;
cj5=0;
j5=1.5707963267949;
sj3=x842;
if((((0.807513169404632)+(((0.621162024335002)*pp))+(((-0.501128128197829)*(pp*pp))))) < -0.00001)
continue;
cj3=IKsqrt(((0.807513169404632)+(((0.621162024335002)*pp))+(((-0.501128128197829)*(pp*pp)))));
if( (x842) < -1-IKFAST_SINCOS_THRESH || (x842) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=((1.0)*(IKasin(x842)));
IkReal gconst32=((-0.43873321118348)+(((0.70790403883424)*pp)));
j4eval[0]=((-1.0)+(((-2.10304031018803)*pp)));
j4eval[1]=((IKabs((((cj6*npy))+((npx*sj6)))))+(IKabs(npz)));
j4eval[2]=IKsign(((-2.1295119821753e-10)+(((-4.47844953954308e-10)*pp))));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
IkReal x843=((-0.438733210502659)+(((0.707904040266035)*pp)));
sj5=1.0;
cj5=0;
j5=1.5707963267949;
sj3=x843;
if((((0.807513169404632)+(((0.621162024335002)*pp))+(((-0.501128128197829)*(pp*pp))))) < -0.00001)
continue;
cj3=IKsqrt(((0.807513169404632)+(((0.621162024335002)*pp))+(((-0.501128128197829)*(pp*pp)))));
if( (x843) < -1-IKFAST_SINCOS_THRESH || (x843) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=((1.0)*(IKasin(x843)));
IkReal gconst32=((-0.43873321118348)+(((0.70790403883424)*pp)));
if((((0.807513169404632)+(((0.621162024335002)*pp))+(((-0.501128128197829)*(pp*pp))))) < -0.00001)
continue;
j4eval[0]=((1.0)+(((-1.02842708252996)*(IKsqrt(((0.807513169404632)+(((0.621162024335002)*pp))+(((-0.501128128197829)*(pp*pp))))))))+(((-4.06308785227994)*pp)));
j4eval[1]=((-1.0)+(((-2.10304031018803)*pp)));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
IkReal x844=((-0.438733210502659)+(((0.707904040266035)*pp)));
sj5=1.0;
cj5=0;
j5=1.5707963267949;
sj3=x844;
if((((0.807513169404632)+(((0.621162024335002)*pp))+(((-0.501128128197829)*(pp*pp))))) < -0.00001)
continue;
cj3=IKsqrt(((0.807513169404632)+(((0.621162024335002)*pp))+(((-0.501128128197829)*(pp*pp)))));
if( (x844) < -1-IKFAST_SINCOS_THRESH || (x844) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=((1.0)*(IKasin(x844)));
IkReal gconst32=((-0.43873321118348)+(((0.70790403883424)*pp)));
IkReal x845=((2.10304031018803)*pp);
IkReal x846=(cj6*npy);
IkReal x847=(npx*sj6);
j4eval[0]=((((-1.0)*x846))+(((-1.0)*x847))+(((-1.0)*x845*x847))+(((-1.0)*x845*x846)));
j4eval[1]=((-1.0)+(((-1.0)*x845)));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j4]

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x848=pp*pp;
IkReal x849=((4.47844953954308e-10)*pp);
IkReal x850=(cj6*npy);
IkReal x851=(npx*sj6);
if((((0.807513169404632)+(((0.621162024335002)*pp))+(((-0.501128128197829)*x848)))) < -0.00001)
continue;
IkReal x852=IKsqrt(((0.807513169404632)+(((0.621162024335002)*pp))+(((-0.501128128197829)*x848))));
CheckValue<IkReal> x853=IKPowWithIntegerCheck(((((-1.0)*x849*x851))+(((-1.0)*x849*x850))+(((-2.1295119821753e-10)*x850))+(((-2.1295119821753e-10)*x851))),-1);
if(!x853.valid){
continue;
}
CheckValue<IkReal> x854=IKPowWithIntegerCheck(((-2.1295119821753e-10)+(((-1.0)*x849))),-1);
if(!x854.valid){
continue;
}
if( IKabs(((x853.value)*(((-1.08709096603304e-11)+(((1.11799379064203e-11)*x852))+(((2.13074997600338e-11)*pp))+(((-1.0)*(npz*npz)))+(((2.35118600826012e-11)*pp*x852))+(((9.28901569288842e-11)*x848)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((npz*(x854.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x853.value)*(((-1.08709096603304e-11)+(((1.11799379064203e-11)*x852))+(((2.13074997600338e-11)*pp))+(((-1.0)*(npz*npz)))+(((2.35118600826012e-11)*pp*x852))+(((9.28901569288842e-11)*x848))))))+IKsqr((npz*(x854.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x853.value)*(((-1.08709096603304e-11)+(((1.11799379064203e-11)*x852))+(((2.13074997600338e-11)*pp))+(((-1.0)*(npz*npz)))+(((2.35118600826012e-11)*pp*x852))+(((9.28901569288842e-11)*x848))))), (npz*(x854.value)));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x855=IKcos(j4);
IkReal x856=IKsin(j4);
IkReal x857=(cj6*npy);
IkReal x858=((0.207415883797948)*pp);
IkReal x859=((1.0)*npx*sj6);
IkReal x860=x852;
IkReal x861=((0.0525)*x860);
evalcond[0]=((((-1.0)*npz))+(((-2.1295119821753e-10)*x855))+(((-4.47844953954308e-10)*pp*x855)));
evalcond[1]=((((-1.0)*x855*x859))+(((-1.0)*x855*x857))+((npz*x856)));
evalcond[2]=((-0.051048830677279)+((npx*sj6*x856))+((x856*x857))+x858+x861+((npz*x855)));
evalcond[3]=((((-1.0)*x859))+(((-1.0)*x857))+(((-1.0)*x856*x861))+(((0.051048830677279)*x856))+(((-1.0)*x856*x858)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if((((0.807513169404632)+(((0.621162024335002)*pp))+(((-0.501128128197829)*(pp*pp))))) < -0.00001)
continue;
CheckValue<IkReal> x862=IKPowWithIntegerCheck(((0.051048830677279)+(((-0.0525)*(IKsqrt(((0.807513169404632)+(((0.621162024335002)*pp))+(((-0.501128128197829)*(pp*pp))))))))+(((-0.207415883797948)*pp))),-1);
if(!x862.valid){
continue;
}
CheckValue<IkReal> x863=IKPowWithIntegerCheck(((-2.1295119821753e-10)+(((-4.47844953954308e-10)*pp))),-1);
if(!x863.valid){
continue;
}
if( IKabs(((x862.value)*((((cj6*npy))+((npx*sj6)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((npz*(x863.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x862.value)*((((cj6*npy))+((npx*sj6))))))+IKsqr((npz*(x863.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x862.value)*((((cj6*npy))+((npx*sj6))))), (npz*(x863.value)));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x864=IKcos(j4);
IkReal x865=IKsin(j4);
IkReal x866=(cj6*npy);
IkReal x867=((0.207415883797948)*pp);
IkReal x868=((1.0)*npx*sj6);
if((((0.807513169404632)+(((0.621162024335002)*pp))+(((-0.501128128197829)*(pp*pp))))) < -0.00001)
continue;
IkReal x869=IKsqrt(((0.807513169404632)+(((0.621162024335002)*pp))+(((-0.501128128197829)*(pp*pp)))));
IkReal x870=((0.0525)*x869);
evalcond[0]=((((-4.47844953954308e-10)*pp*x864))+(((-1.0)*npz))+(((-2.1295119821753e-10)*x864)));
evalcond[1]=((((-1.0)*x864*x868))+(((-1.0)*x864*x866))+((npz*x865)));
evalcond[2]=((-0.051048830677279)+((npx*sj6*x865))+((npz*x864))+x867+x870+((x865*x866)));
evalcond[3]=((((-1.0)*x868))+(((-1.0)*x865*x867))+(((-1.0)*x866))+(((0.051048830677279)*x865))+(((-1.0)*x865*x870)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x871 = IKatan2WithCheck(IkReal((((cj6*npy))+((npx*sj6)))),IkReal(npz),IKFAST_ATAN2_MAGTHRESH);
if(!x871.valid){
continue;
}
CheckValue<IkReal> x872=IKPowWithIntegerCheck(IKsign(((-2.1295119821753e-10)+(((-4.47844953954308e-10)*pp)))),-1);
if(!x872.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(x871.value)+(((1.5707963267949)*(x872.value))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x873=IKcos(j4);
IkReal x874=IKsin(j4);
IkReal x875=(cj6*npy);
IkReal x876=((0.207415883797948)*pp);
IkReal x877=((1.0)*npx*sj6);
if((((0.807513169404632)+(((0.621162024335002)*pp))+(((-0.501128128197829)*(pp*pp))))) < -0.00001)
continue;
IkReal x878=IKsqrt(((0.807513169404632)+(((0.621162024335002)*pp))+(((-0.501128128197829)*(pp*pp)))));
IkReal x879=((0.0525)*x878);
evalcond[0]=((((-2.1295119821753e-10)*x873))+(((-1.0)*npz))+(((-4.47844953954308e-10)*pp*x873)));
evalcond[1]=((((-1.0)*x873*x877))+(((-1.0)*x873*x875))+((npz*x874)));
evalcond[2]=((-0.051048830677279)+((npx*sj6*x874))+((x874*x875))+x879+x876+((npz*x873)));
evalcond[3]=((((-1.0)*x875))+(((-1.0)*x874*x879))+(((-1.0)*x874*x876))+(((0.051048830677279)*x874))+(((-1.0)*x877)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst32=((-0.43873321118348)+(((0.70790403883424)*pp)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((0.43873321118348)+sj3+(((-0.70790403883424)*pp)))))+(IKabs(((1.0)+(IKsign(cj3)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[3];
IkReal x880=((-0.438733210502659)+(((0.707904040266035)*pp)));
sj5=1.0;
cj5=0;
j5=1.5707963267949;
sj3=x880;
if((((0.807513169404632)+(((0.621162024335002)*pp))+(((-0.501128128197829)*(pp*pp))))) < -0.00001)
continue;
cj3=((-1.0)*(IKsqrt(((0.807513169404632)+(((0.621162024335002)*pp))+(((-0.501128128197829)*(pp*pp)))))));
if( (x880) < -1-IKFAST_SINCOS_THRESH || (x880) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=((3.14159265)+(((-1.0)*(IKasin(x880)))));
IkReal gconst32=((-0.43873321118348)+(((0.70790403883424)*pp)));
j4eval[0]=((-1.0)+(((-2.10304031018803)*pp)));
j4eval[1]=((IKabs((((cj6*npy))+((npx*sj6)))))+(IKabs(npz)));
j4eval[2]=IKsign(((-2.1295119821753e-10)+(((-4.47844953954308e-10)*pp))));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
IkReal x881=((-0.438733210502659)+(((0.707904040266035)*pp)));
sj5=1.0;
cj5=0;
j5=1.5707963267949;
sj3=x881;
if((((0.807513169404632)+(((0.621162024335002)*pp))+(((-0.501128128197829)*(pp*pp))))) < -0.00001)
continue;
cj3=((-1.0)*(IKsqrt(((0.807513169404632)+(((0.621162024335002)*pp))+(((-0.501128128197829)*(pp*pp)))))));
if( (x881) < -1-IKFAST_SINCOS_THRESH || (x881) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=((3.14159265)+(((-1.0)*(IKasin(x881)))));
IkReal gconst32=((-0.43873321118348)+(((0.70790403883424)*pp)));
if((((0.807513169404632)+(((0.621162024335002)*pp))+(((-0.501128128197829)*(pp*pp))))) < -0.00001)
continue;
j4eval[0]=((1.0)+(((1.02842708252996)*(IKsqrt(((0.807513169404632)+(((0.621162024335002)*pp))+(((-0.501128128197829)*(pp*pp))))))))+(((-4.06308785227994)*pp)));
j4eval[1]=((-1.0)+(((-2.10304031018803)*pp)));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
IkReal x882=((-0.438733210502659)+(((0.707904040266035)*pp)));
sj5=1.0;
cj5=0;
j5=1.5707963267949;
sj3=x882;
if((((0.807513169404632)+(((0.621162024335002)*pp))+(((-0.501128128197829)*(pp*pp))))) < -0.00001)
continue;
cj3=((-1.0)*(IKsqrt(((0.807513169404632)+(((0.621162024335002)*pp))+(((-0.501128128197829)*(pp*pp)))))));
if( (x882) < -1-IKFAST_SINCOS_THRESH || (x882) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=((3.14159265)+(((-1.0)*(IKasin(x882)))));
IkReal gconst32=((-0.43873321118348)+(((0.70790403883424)*pp)));
IkReal x883=((2.10304031018803)*pp);
IkReal x884=(cj6*npy);
IkReal x885=(npx*sj6);
j4eval[0]=((((-1.0)*x883*x884))+(((-1.0)*x883*x885))+(((-1.0)*x885))+(((-1.0)*x884)));
j4eval[1]=((-1.0)+(((-1.0)*x883)));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j4]

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x886=pp*pp;
IkReal x887=(npx*sj6);
IkReal x888=((4.47844953954308e-10)*pp);
IkReal x889=(cj6*npy);
if((((0.807513169404632)+(((-0.501128128197829)*x886))+(((0.621162024335002)*pp)))) < -0.00001)
continue;
IkReal x890=IKsqrt(((0.807513169404632)+(((-0.501128128197829)*x886))+(((0.621162024335002)*pp))));
CheckValue<IkReal> x891=IKPowWithIntegerCheck(((((-1.0)*x887*x888))+(((-1.0)*x888*x889))+(((-2.1295119821753e-10)*x887))+(((-2.1295119821753e-10)*x889))),-1);
if(!x891.valid){
continue;
}
CheckValue<IkReal> x892=IKPowWithIntegerCheck(((-2.1295119821753e-10)+(((-1.0)*x888))),-1);
if(!x892.valid){
continue;
}
if( IKabs(((x891.value)*(((-1.08709096603304e-11)+(((-1.11799379064203e-11)*x890))+(((2.13074997600338e-11)*pp))+(((-1.0)*(npz*npz)))+(((-2.35118600826012e-11)*pp*x890))+(((9.28901569288842e-11)*x886)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((npz*(x892.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x891.value)*(((-1.08709096603304e-11)+(((-1.11799379064203e-11)*x890))+(((2.13074997600338e-11)*pp))+(((-1.0)*(npz*npz)))+(((-2.35118600826012e-11)*pp*x890))+(((9.28901569288842e-11)*x886))))))+IKsqr((npz*(x892.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x891.value)*(((-1.08709096603304e-11)+(((-1.11799379064203e-11)*x890))+(((2.13074997600338e-11)*pp))+(((-1.0)*(npz*npz)))+(((-2.35118600826012e-11)*pp*x890))+(((9.28901569288842e-11)*x886))))), (npz*(x892.value)));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x893=IKcos(j4);
IkReal x894=IKsin(j4);
IkReal x895=(cj6*npy);
IkReal x896=((0.207415883797948)*pp);
IkReal x897=((1.0)*npx*sj6);
IkReal x898=x890;
IkReal x899=((0.0525)*x898);
evalcond[0]=((((-1.0)*npz))+(((-2.1295119821753e-10)*x893))+(((-4.47844953954308e-10)*pp*x893)));
evalcond[1]=(((npz*x894))+(((-1.0)*x893*x897))+(((-1.0)*x893*x895)));
evalcond[2]=((-0.051048830677279)+((x894*x895))+(((-1.0)*x899))+((npx*sj6*x894))+((npz*x893))+x896);
evalcond[3]=((((0.051048830677279)*x894))+((x894*x899))+(((-1.0)*x897))+(((-1.0)*x895))+(((-1.0)*x894*x896)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if((((0.807513169404632)+(((0.621162024335002)*pp))+(((-0.501128128197829)*(pp*pp))))) < -0.00001)
continue;
CheckValue<IkReal> x900=IKPowWithIntegerCheck(((0.051048830677279)+(((-0.207415883797948)*pp))+(((0.0525)*(IKsqrt(((0.807513169404632)+(((0.621162024335002)*pp))+(((-0.501128128197829)*(pp*pp))))))))),-1);
if(!x900.valid){
continue;
}
CheckValue<IkReal> x901=IKPowWithIntegerCheck(((-2.1295119821753e-10)+(((-4.47844953954308e-10)*pp))),-1);
if(!x901.valid){
continue;
}
if( IKabs(((x900.value)*((((cj6*npy))+((npx*sj6)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((npz*(x901.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x900.value)*((((cj6*npy))+((npx*sj6))))))+IKsqr((npz*(x901.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x900.value)*((((cj6*npy))+((npx*sj6))))), (npz*(x901.value)));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x902=IKcos(j4);
IkReal x903=IKsin(j4);
IkReal x904=(cj6*npy);
IkReal x905=((0.207415883797948)*pp);
IkReal x906=((1.0)*npx*sj6);
if((((0.807513169404632)+(((0.621162024335002)*pp))+(((-0.501128128197829)*(pp*pp))))) < -0.00001)
continue;
IkReal x907=IKsqrt(((0.807513169404632)+(((0.621162024335002)*pp))+(((-0.501128128197829)*(pp*pp)))));
IkReal x908=((0.0525)*x907);
evalcond[0]=((((-2.1295119821753e-10)*x902))+(((-1.0)*npz))+(((-4.47844953954308e-10)*pp*x902)));
evalcond[1]=((((-1.0)*x902*x904))+(((-1.0)*x902*x906))+((npz*x903)));
evalcond[2]=((-0.051048830677279)+((x903*x904))+(((-1.0)*x908))+((npz*x902))+((npx*sj6*x903))+x905);
evalcond[3]=((((-1.0)*x903*x905))+((x903*x908))+(((-1.0)*x906))+(((0.051048830677279)*x903))+(((-1.0)*x904)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x909 = IKatan2WithCheck(IkReal((((cj6*npy))+((npx*sj6)))),IkReal(npz),IKFAST_ATAN2_MAGTHRESH);
if(!x909.valid){
continue;
}
CheckValue<IkReal> x910=IKPowWithIntegerCheck(IKsign(((-2.1295119821753e-10)+(((-4.47844953954308e-10)*pp)))),-1);
if(!x910.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(x909.value)+(((1.5707963267949)*(x910.value))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x911=IKcos(j4);
IkReal x912=IKsin(j4);
IkReal x913=(cj6*npy);
IkReal x914=((0.207415883797948)*pp);
IkReal x915=((1.0)*npx*sj6);
if((((0.807513169404632)+(((0.621162024335002)*pp))+(((-0.501128128197829)*(pp*pp))))) < -0.00001)
continue;
IkReal x916=IKsqrt(((0.807513169404632)+(((0.621162024335002)*pp))+(((-0.501128128197829)*(pp*pp)))));
IkReal x917=((0.0525)*x916);
evalcond[0]=((((-4.47844953954308e-10)*pp*x911))+(((-2.1295119821753e-10)*x911))+(((-1.0)*npz)));
evalcond[1]=((((-1.0)*x911*x913))+((npz*x912))+(((-1.0)*x911*x915)));
evalcond[2]=((-0.051048830677279)+(((-1.0)*x917))+((x912*x913))+((npx*sj6*x912))+((npz*x911))+x914);
evalcond[3]=((((-1.0)*x915))+(((0.051048830677279)*x912))+(((-1.0)*x913))+(((-1.0)*x912*x914))+((x912*x917)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x918=((0.293)*sj3);
IkReal x919=(npx*sj6);
IkReal x920=(cj6*npy);
IkReal x921=((1.0)*npz);
IkReal x922=((0.0525)*cj3);
CheckValue<IkReal> x923=IKPowWithIntegerCheck(((-0.0775)+(((-1.0)*x922))+(((-1.0)*x918))),-1);
if(!x923.valid){
continue;
}
CheckValue<IkReal> x924=IKPowWithIntegerCheck((((x918*x920))+((x919*x922))+((x920*x922))+(((0.0775)*x920))+(((0.0775)*x919))+((x918*x919))),-1);
if(!x924.valid){
continue;
}
if( IKabs(((x923.value)*((x920+x919)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x924.value)*(((((-1.0)*x920*x921))+(((-1.0)*x919*x921)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x923.value)*((x920+x919))))+IKsqr(((x924.value)*(((((-1.0)*x920*x921))+(((-1.0)*x919*x921))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x923.value)*((x920+x919))), ((x924.value)*(((((-1.0)*x920*x921))+(((-1.0)*x919*x921))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x925=IKcos(j4);
IkReal x926=IKsin(j4);
IkReal x927=((0.293)*sj3);
IkReal x928=(cj6*npy);
IkReal x929=((0.0525)*cj3);
IkReal x930=((1.0)*npx*sj6);
evalcond[0]=(((npz*x926))+(((-1.0)*x925*x930))+(((-1.0)*x925*x928)));
evalcond[1]=((((-1.0)*npz))+(((-0.312785742302412)*sj3*x925))+(((-0.137229493132746)*x925))+(((0.221422290265643)*pp*x925)));
evalcond[2]=((0.0775)+((npz*x925))+((npx*sj6*x926))+((x926*x928))+x929+x927);
evalcond[3]=((((-1.0)*x928))+(((-1.0)*x926*x929))+(((-1.0)*x926*x927))+(((-0.0775)*x926))+(((-1.0)*x930)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x931=IKPowWithIntegerCheck(((-0.0775)+(((-0.0525)*cj3))+(((-0.293)*sj3))),-1);
if(!x931.valid){
continue;
}
CheckValue<IkReal> x932=IKPowWithIntegerCheck(((-0.137229493132746)+(((0.221422290265643)*pp))+(((-0.312785742302412)*sj3))),-1);
if(!x932.valid){
continue;
}
if( IKabs(((x931.value)*((((cj6*npy))+((npx*sj6)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((npz*(x932.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x931.value)*((((cj6*npy))+((npx*sj6))))))+IKsqr((npz*(x932.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x931.value)*((((cj6*npy))+((npx*sj6))))), (npz*(x932.value)));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x933=IKcos(j4);
IkReal x934=IKsin(j4);
IkReal x935=((0.293)*sj3);
IkReal x936=(cj6*npy);
IkReal x937=((0.0525)*cj3);
IkReal x938=((1.0)*npx*sj6);
evalcond[0]=(((npz*x934))+(((-1.0)*x933*x938))+(((-1.0)*x933*x936)));
evalcond[1]=((((-1.0)*npz))+(((-0.312785742302412)*sj3*x933))+(((-0.137229493132746)*x933))+(((0.221422290265643)*pp*x933)));
evalcond[2]=((0.0775)+((npz*x933))+((npx*sj6*x934))+((x934*x936))+x935+x937);
evalcond[3]=((((-1.0)*x934*x935))+(((-1.0)*x934*x937))+(((-1.0)*x936))+(((-0.0775)*x934))+(((-1.0)*x938)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x939=IKPowWithIntegerCheck(IKsign(((-0.137229493132746)+(((0.221422290265643)*pp))+(((-0.312785742302412)*sj3)))),-1);
if(!x939.valid){
continue;
}
CheckValue<IkReal> x940 = IKatan2WithCheck(IkReal((((cj6*npy))+((npx*sj6)))),IkReal(npz),IKFAST_ATAN2_MAGTHRESH);
if(!x940.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x939.value)))+(x940.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x941=IKcos(j4);
IkReal x942=IKsin(j4);
IkReal x943=((0.293)*sj3);
IkReal x944=(cj6*npy);
IkReal x945=((0.0525)*cj3);
IkReal x946=((1.0)*npx*sj6);
evalcond[0]=(((npz*x942))+(((-1.0)*x941*x944))+(((-1.0)*x941*x946)));
evalcond[1]=((((0.221422290265643)*pp*x941))+(((-1.0)*npz))+(((-0.137229493132746)*x941))+(((-0.312785742302412)*sj3*x941)));
evalcond[2]=((0.0775)+((npz*x941))+((x942*x944))+((npx*sj6*x942))+x943+x945);
evalcond[3]=((((-1.0)*x946))+(((-1.0)*x942*x943))+(((-1.0)*x942*x945))+(((-1.0)*x944))+(((-0.0775)*x942)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[3];
sj5=-1.0;
cj5=0;
j5=-1.5707963267949;
j4eval[0]=((1.0)+(((-2.6031061688317)*pp))+(((2.34163522357165)*sj3)));
j4eval[1]=IKsign(((0.136242712699662)+(((-0.354654245886855)*pp))+(((0.31903073501248)*sj3))));
j4eval[2]=((IKabs(npz))+(IKabs(((((-1.0)*cj6*npy))+(((-1.0)*npx*sj6))))));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
sj5=-1.0;
cj5=0;
j5=-1.5707963267949;
j4eval[0]=((-1.47619047619048)+(((-5.58095238095238)*sj3))+(((-1.0)*cj3)));
j4eval[1]=((1.0)+(((-2.6031061688317)*pp))+(((2.34163522357165)*sj3)));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
sj5=-1.0;
cj5=0;
j5=-1.5707963267949;
IkReal x947=(npx*sj6);
IkReal x948=((5.58095238095238)*sj3);
IkReal x949=(cj6*npy);
j4eval[0]=((-1.47619047619048)+(((-1.0)*x948))+(((-1.0)*cj3)));
j4eval[1]=((((1.47619047619048)*x947))+(((1.47619047619048)*x949))+((x948*x949))+((x947*x948))+((cj3*x949))+((cj3*x947)));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
IkReal gconst34=((-0.427051997652615)+(((1.11166168950142)*pp)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((0.427051997652615)+(((-1.11166168950142)*pp))+sj3)))+(IKabs(((-1.0)+(IKsign(cj3)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[3];
IkReal x950=((1.11166169244379)*pp);
sj5=-1.0;
cj5=0;
j5=-1.5707963267949;
sj3=((-0.427052)+x950);
if((((0.817626591300911)+(((0.949474690430929)*pp))+(((-1.23579171190516)*(pp*pp))))) < -0.00001)
continue;
cj3=IKsqrt(((0.817626591300911)+(((0.949474690430929)*pp))+(((-1.23579171190516)*(pp*pp)))));
if( (((0.427052)+(((-1.0)*x950)))) < -1-IKFAST_SINCOS_THRESH || (((0.427052)+(((-1.0)*x950)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=((-1.0)*(IKasin(((0.427052)+(((-1.0)*x950))))));
IkReal gconst34=((-0.427051997652615)+(((1.11166168950142)*pp)));
j4eval[0]=((-1.0)+(((1.2534635127096)*pp)));
j4eval[1]=((IKabs(npz))+(IKabs(((((-1.0)*cj6*npy))+(((-1.0)*npx*sj6))))));
j4eval[2]=IKsign(((-7.48887905614683e-10)+(((9.38703664797514e-10)*pp))));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
IkReal x951=((1.11166169244379)*pp);
sj5=-1.0;
cj5=0;
j5=-1.5707963267949;
sj3=((-0.427052)+x951);
if((((0.817626591300911)+(((0.949474690430929)*pp))+(((-1.23579171190516)*(pp*pp))))) < -0.00001)
continue;
cj3=IKsqrt(((0.817626591300911)+(((0.949474690430929)*pp))+(((-1.23579171190516)*(pp*pp)))));
if( (((0.427052)+(((-1.0)*x951)))) < -1-IKFAST_SINCOS_THRESH || (((0.427052)+(((-1.0)*x951)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=((-1.0)*(IKasin(((0.427052)+(((-1.0)*x951))))));
IkReal gconst34=((-0.427051997652615)+(((1.11166168950142)*pp)));
if((((0.817626591300911)+(((0.949474690430929)*pp))+(((-1.23579171190516)*(pp*pp))))) < -0.00001)
continue;
j4eval[0]=((1.0)+(((-1.10233359612966)*(IKsqrt(((0.817626591300911)+(((0.949474690430929)*pp))+(((-1.23579171190516)*(pp*pp))))))))+(((-6.83902200220125)*pp)));
j4eval[1]=((-1.0)+(((1.2534635127096)*pp)));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
IkReal x952=((1.11166169244379)*pp);
sj5=-1.0;
cj5=0;
j5=-1.5707963267949;
sj3=((-0.427052)+x952);
if((((0.817626591300911)+(((0.949474690430929)*pp))+(((-1.23579171190516)*(pp*pp))))) < -0.00001)
continue;
cj3=IKsqrt(((0.817626591300911)+(((0.949474690430929)*pp))+(((-1.23579171190516)*(pp*pp)))));
if( (((0.427052)+(((-1.0)*x952)))) < -1-IKFAST_SINCOS_THRESH || (((0.427052)+(((-1.0)*x952)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=((-1.0)*(IKasin(((0.427052)+(((-1.0)*x952))))));
IkReal gconst34=((-0.427051997652615)+(((1.11166168950142)*pp)));
IkReal x953=((1.2534635127096)*pp);
IkReal x954=(cj6*npy);
IkReal x955=(npx*sj6);
j4eval[0]=((((-1.0)*x955))+(((-1.0)*x954))+((x953*x954))+((x953*x955)));
j4eval[1]=((-1.0)+x953);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j4]

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x956=pp*pp;
IkReal x957=(npx*sj6);
IkReal x958=(cj6*npy);
IkReal x959=((9.38703664797514e-10)*pp);
if((((0.817626591300911)+(((-1.23579171190516)*x956))+(((0.949474690430929)*pp)))) < -0.00001)
continue;
IkReal x960=IKsqrt(((0.817626591300911)+(((-1.23579171190516)*x956))+(((0.949474690430929)*pp))));
CheckValue<IkReal> x961=IKPowWithIntegerCheck(((((-7.48887905614683e-10)*x958))+(((-7.48887905614683e-10)*x957))+((x957*x959))+((x958*x959))),-1);
if(!x961.valid){
continue;
}
CheckValue<IkReal> x962=IKPowWithIntegerCheck(((-7.48887905614683e-10)+x959),-1);
if(!x962.valid){
continue;
}
if( IKabs(((x961.value)*(((-3.56667121303506e-11)+(((-3.05751625080612e-10)*x956))+(((-4.92819424018695e-11)*pp*x960))+(((2.88632351279357e-10)*pp))+(((3.93166150447709e-11)*x960))+(npz*npz))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((npz*(x962.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x961.value)*(((-3.56667121303506e-11)+(((-3.05751625080612e-10)*x956))+(((-4.92819424018695e-11)*pp*x960))+(((2.88632351279357e-10)*pp))+(((3.93166150447709e-11)*x960))+(npz*npz)))))+IKsqr((npz*(x962.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x961.value)*(((-3.56667121303506e-11)+(((-3.05751625080612e-10)*x956))+(((-4.92819424018695e-11)*pp*x960))+(((2.88632351279357e-10)*pp))+(((3.93166150447709e-11)*x960))+(npz*npz)))), (npz*(x962.value)));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x963=IKcos(j4);
IkReal x964=IKsin(j4);
IkReal x965=((0.325716875886029)*pp);
IkReal x966=((1.0)*npz);
IkReal x967=(cj6*npy);
IkReal x968=((1.0)*npx*sj6);
IkReal x969=x960;
IkReal x970=((0.0525)*x969);
evalcond[0]=((((-7.48887905614683e-10)*x963))+(((9.38703664797514e-10)*pp*x963))+(((-1.0)*x966)));
evalcond[1]=((((-1.0)*x963*x967))+(((-1.0)*x963*x968))+(((-1.0)*x964*x966)));
evalcond[2]=((((-1.0)*x967))+(((-1.0)*x964*x965))+(((-1.0)*x964*x970))+(((0.047626236)*x964))+(((-1.0)*x968)));
evalcond[3]=((-0.047626236)+(((-1.0)*x963*x966))+((npx*sj6*x964))+((x964*x967))+x970+x965);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if((((0.817626591300911)+(((0.949474690430929)*pp))+(((-1.23579171190516)*(pp*pp))))) < -0.00001)
continue;
CheckValue<IkReal> x971=IKPowWithIntegerCheck(((0.047626236)+(((-0.325716875886029)*pp))+(((-0.0525)*(IKsqrt(((0.817626591300911)+(((0.949474690430929)*pp))+(((-1.23579171190516)*(pp*pp))))))))),-1);
if(!x971.valid){
continue;
}
CheckValue<IkReal> x972=IKPowWithIntegerCheck(((-7.48887905614683e-10)+(((9.38703664797514e-10)*pp))),-1);
if(!x972.valid){
continue;
}
if( IKabs(((x971.value)*((((cj6*npy))+((npx*sj6)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((npz*(x972.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x971.value)*((((cj6*npy))+((npx*sj6))))))+IKsqr((npz*(x972.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x971.value)*((((cj6*npy))+((npx*sj6))))), (npz*(x972.value)));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x973=IKcos(j4);
IkReal x974=IKsin(j4);
IkReal x975=((0.325716875886029)*pp);
IkReal x976=((1.0)*npz);
IkReal x977=(cj6*npy);
IkReal x978=((1.0)*npx*sj6);
if((((0.817626591300911)+(((0.949474690430929)*pp))+(((-1.23579171190516)*(pp*pp))))) < -0.00001)
continue;
IkReal x979=IKsqrt(((0.817626591300911)+(((0.949474690430929)*pp))+(((-1.23579171190516)*(pp*pp)))));
IkReal x980=((0.0525)*x979);
evalcond[0]=((((9.38703664797514e-10)*pp*x973))+(((-7.48887905614683e-10)*x973))+(((-1.0)*x976)));
evalcond[1]=((((-1.0)*x974*x976))+(((-1.0)*x973*x977))+(((-1.0)*x973*x978)));
evalcond[2]=((((-1.0)*x977))+(((-1.0)*x974*x980))+(((-1.0)*x974*x975))+(((0.047626236)*x974))+(((-1.0)*x978)));
evalcond[3]=((-0.047626236)+((npx*sj6*x974))+((x974*x977))+x980+x975+(((-1.0)*x973*x976)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x981=IKPowWithIntegerCheck(IKsign(((-7.48887905614683e-10)+(((9.38703664797514e-10)*pp)))),-1);
if(!x981.valid){
continue;
}
CheckValue<IkReal> x982 = IKatan2WithCheck(IkReal(((((-1.0)*cj6*npy))+(((-1.0)*npx*sj6)))),IkReal(npz),IKFAST_ATAN2_MAGTHRESH);
if(!x982.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x981.value)))+(x982.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x983=IKcos(j4);
IkReal x984=IKsin(j4);
IkReal x985=((0.325716875886029)*pp);
IkReal x986=((1.0)*npz);
IkReal x987=(cj6*npy);
IkReal x988=((1.0)*npx*sj6);
if((((0.817626591300911)+(((0.949474690430929)*pp))+(((-1.23579171190516)*(pp*pp))))) < -0.00001)
continue;
IkReal x989=IKsqrt(((0.817626591300911)+(((0.949474690430929)*pp))+(((-1.23579171190516)*(pp*pp)))));
IkReal x990=((0.0525)*x989);
evalcond[0]=((((-1.0)*x986))+(((-7.48887905614683e-10)*x983))+(((9.38703664797514e-10)*pp*x983)));
evalcond[1]=((((-1.0)*x983*x987))+(((-1.0)*x984*x986))+(((-1.0)*x983*x988)));
evalcond[2]=((((-1.0)*x988))+(((-1.0)*x987))+(((-1.0)*x984*x990))+(((0.047626236)*x984))+(((-1.0)*x984*x985)));
evalcond[3]=((-0.047626236)+((npx*sj6*x984))+((x984*x987))+x990+x985+(((-1.0)*x983*x986)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst34=((-0.427051997652615)+(((1.11166168950142)*pp)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((0.427051997652615)+(((-1.11166168950142)*pp))+sj3)))+(IKabs(((1.0)+(IKsign(cj3)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[3];
IkReal x991=((1.11166169244379)*pp);
sj5=-1.0;
cj5=0;
j5=-1.5707963267949;
sj3=((-0.427052)+x991);
if((((0.817626591300911)+(((0.949474690430929)*pp))+(((-1.23579171190516)*(pp*pp))))) < -0.00001)
continue;
cj3=((-1.0)*(IKsqrt(((0.817626591300911)+(((0.949474690430929)*pp))+(((-1.23579171190516)*(pp*pp)))))));
if( (((0.427052)+(((-1.0)*x991)))) < -1-IKFAST_SINCOS_THRESH || (((0.427052)+(((-1.0)*x991)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=((3.14159265)+(IKasin(((0.427052)+(((-1.0)*x991))))));
IkReal gconst34=((-0.427051997652615)+(((1.11166168950142)*pp)));
j4eval[0]=((-1.0)+(((1.2534635127096)*pp)));
j4eval[1]=((IKabs(npz))+(IKabs(((((-1.0)*cj6*npy))+(((-1.0)*npx*sj6))))));
j4eval[2]=IKsign(((-7.48887905614683e-10)+(((9.38703664797514e-10)*pp))));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
IkReal x992=((1.11166169244379)*pp);
sj5=-1.0;
cj5=0;
j5=-1.5707963267949;
sj3=((-0.427052)+x992);
if((((0.817626591300911)+(((0.949474690430929)*pp))+(((-1.23579171190516)*(pp*pp))))) < -0.00001)
continue;
cj3=((-1.0)*(IKsqrt(((0.817626591300911)+(((0.949474690430929)*pp))+(((-1.23579171190516)*(pp*pp)))))));
if( (((-0.427052)+x992)) < -1-IKFAST_SINCOS_THRESH || (((-0.427052)+x992)) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=((3.14159265)+(((-1.0)*(IKasin(((-0.427052)+x992))))));
IkReal gconst34=((-0.427051997652615)+(((1.11166168950142)*pp)));
if((((0.817626591300911)+(((0.949474690430929)*pp))+(((-1.23579171190516)*(pp*pp))))) < -0.00001)
continue;
j4eval[0]=((1.0)+(((1.10233359612966)*(IKsqrt(((0.817626591300911)+(((0.949474690430929)*pp))+(((-1.23579171190516)*(pp*pp))))))))+(((-6.83902200220125)*pp)));
j4eval[1]=((-1.0)+(((1.2534635127096)*pp)));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
IkReal x993=((1.11166169244379)*pp);
sj5=-1.0;
cj5=0;
j5=-1.5707963267949;
sj3=((-0.427052)+x993);
if((((0.817626591300911)+(((0.949474690430929)*pp))+(((-1.23579171190516)*(pp*pp))))) < -0.00001)
continue;
cj3=((-1.0)*(IKsqrt(((0.817626591300911)+(((0.949474690430929)*pp))+(((-1.23579171190516)*(pp*pp)))))));
if( (((0.427052)+(((-1.0)*x993)))) < -1-IKFAST_SINCOS_THRESH || (((0.427052)+(((-1.0)*x993)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=((3.14159265)+(IKasin(((0.427052)+(((-1.0)*x993))))));
IkReal gconst34=((-0.427051997652615)+(((1.11166168950142)*pp)));
IkReal x994=((1.2534635127096)*pp);
IkReal x995=(cj6*npy);
IkReal x996=(npx*sj6);
j4eval[0]=((((-1.0)*x996))+(((-1.0)*x995))+((x994*x996))+((x994*x995)));
j4eval[1]=((-1.0)+x994);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j4]

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x997=pp*pp;
IkReal x998=(cj6*npy);
IkReal x999=(npx*sj6);
IkReal x1000=((9.38703664797514e-10)*pp);
if((((0.817626591300911)+(((0.949474690430929)*pp))+(((-1.23579171190516)*x997)))) < -0.00001)
continue;
IkReal x1001=IKsqrt(((0.817626591300911)+(((0.949474690430929)*pp))+(((-1.23579171190516)*x997))));
CheckValue<IkReal> x1002=IKPowWithIntegerCheck((((x1000*x999))+((x1000*x998))+(((-7.48887905614683e-10)*x999))+(((-7.48887905614683e-10)*x998))),-1);
if(!x1002.valid){
continue;
}
CheckValue<IkReal> x1003=IKPowWithIntegerCheck(((-7.48887905614683e-10)+x1000),-1);
if(!x1003.valid){
continue;
}
if( IKabs(((x1002.value)*(((-3.56667121303506e-11)+(((-3.93166150447709e-11)*x1001))+(((4.92819424018695e-11)*pp*x1001))+(((2.88632351279357e-10)*pp))+(npz*npz)+(((-3.05751625080612e-10)*x997)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((npz*(x1003.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1002.value)*(((-3.56667121303506e-11)+(((-3.93166150447709e-11)*x1001))+(((4.92819424018695e-11)*pp*x1001))+(((2.88632351279357e-10)*pp))+(npz*npz)+(((-3.05751625080612e-10)*x997))))))+IKsqr((npz*(x1003.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x1002.value)*(((-3.56667121303506e-11)+(((-3.93166150447709e-11)*x1001))+(((4.92819424018695e-11)*pp*x1001))+(((2.88632351279357e-10)*pp))+(npz*npz)+(((-3.05751625080612e-10)*x997))))), (npz*(x1003.value)));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x1004=IKcos(j4);
IkReal x1005=IKsin(j4);
IkReal x1006=((0.325716875886029)*pp);
IkReal x1007=((1.0)*npz);
IkReal x1008=(cj6*npy);
IkReal x1009=((1.0)*npx*sj6);
IkReal x1010=x1001;
IkReal x1011=((0.0525)*x1010);
evalcond[0]=((((-1.0)*x1007))+(((-7.48887905614683e-10)*x1004))+(((9.38703664797514e-10)*pp*x1004)));
evalcond[1]=((((-1.0)*x1004*x1008))+(((-1.0)*x1005*x1007))+(((-1.0)*x1004*x1009)));
evalcond[2]=((((-1.0)*x1008))+(((-1.0)*x1009))+(((-1.0)*x1005*x1006))+((x1005*x1011))+(((0.047626236)*x1005)));
evalcond[3]=((-0.047626236)+x1006+(((-1.0)*x1011))+((npx*sj6*x1005))+(((-1.0)*x1004*x1007))+((x1005*x1008)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if((((0.817626591300911)+(((0.949474690430929)*pp))+(((-1.23579171190516)*(pp*pp))))) < -0.00001)
continue;
CheckValue<IkReal> x1012=IKPowWithIntegerCheck(((0.047626236)+(((-0.325716875886029)*pp))+(((0.0525)*(IKsqrt(((0.817626591300911)+(((0.949474690430929)*pp))+(((-1.23579171190516)*(pp*pp))))))))),-1);
if(!x1012.valid){
continue;
}
CheckValue<IkReal> x1013=IKPowWithIntegerCheck(((-7.48887905614683e-10)+(((9.38703664797514e-10)*pp))),-1);
if(!x1013.valid){
continue;
}
if( IKabs(((x1012.value)*((((cj6*npy))+((npx*sj6)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((npz*(x1013.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1012.value)*((((cj6*npy))+((npx*sj6))))))+IKsqr((npz*(x1013.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x1012.value)*((((cj6*npy))+((npx*sj6))))), (npz*(x1013.value)));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x1014=IKcos(j4);
IkReal x1015=IKsin(j4);
IkReal x1016=((0.325716875886029)*pp);
IkReal x1017=((1.0)*npz);
IkReal x1018=(cj6*npy);
IkReal x1019=((1.0)*npx*sj6);
if((((0.817626591300911)+(((0.949474690430929)*pp))+(((-1.23579171190516)*(pp*pp))))) < -0.00001)
continue;
IkReal x1020=IKsqrt(((0.817626591300911)+(((0.949474690430929)*pp))+(((-1.23579171190516)*(pp*pp)))));
IkReal x1021=((0.0525)*x1020);
evalcond[0]=((((9.38703664797514e-10)*pp*x1014))+(((-1.0)*x1017))+(((-7.48887905614683e-10)*x1014)));
evalcond[1]=((((-1.0)*x1014*x1019))+(((-1.0)*x1014*x1018))+(((-1.0)*x1015*x1017)));
evalcond[2]=((((-1.0)*x1019))+((x1015*x1021))+(((-1.0)*x1015*x1016))+(((0.047626236)*x1015))+(((-1.0)*x1018)));
evalcond[3]=((-0.047626236)+x1016+(((-1.0)*x1014*x1017))+(((-1.0)*x1021))+((npx*sj6*x1015))+((x1015*x1018)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x1022=IKPowWithIntegerCheck(IKsign(((-7.48887905614683e-10)+(((9.38703664797514e-10)*pp)))),-1);
if(!x1022.valid){
continue;
}
CheckValue<IkReal> x1023 = IKatan2WithCheck(IkReal(((((-1.0)*cj6*npy))+(((-1.0)*npx*sj6)))),IkReal(npz),IKFAST_ATAN2_MAGTHRESH);
if(!x1023.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1022.value)))+(x1023.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x1024=IKcos(j4);
IkReal x1025=IKsin(j4);
IkReal x1026=((0.325716875886029)*pp);
IkReal x1027=((1.0)*npz);
IkReal x1028=(cj6*npy);
IkReal x1029=((1.0)*npx*sj6);
if((((0.817626591300911)+(((0.949474690430929)*pp))+(((-1.23579171190516)*(pp*pp))))) < -0.00001)
continue;
IkReal x1030=IKsqrt(((0.817626591300911)+(((0.949474690430929)*pp))+(((-1.23579171190516)*(pp*pp)))));
IkReal x1031=((0.0525)*x1030);
evalcond[0]=((((-7.48887905614683e-10)*x1024))+(((9.38703664797514e-10)*pp*x1024))+(((-1.0)*x1027)));
evalcond[1]=((((-1.0)*x1024*x1028))+(((-1.0)*x1025*x1027))+(((-1.0)*x1024*x1029)));
evalcond[2]=((((-1.0)*x1028))+(((-1.0)*x1029))+(((0.047626236)*x1025))+((x1025*x1031))+(((-1.0)*x1025*x1026)));
evalcond[3]=((-0.047626236)+(((-1.0)*x1031))+x1026+((npx*sj6*x1025))+((x1025*x1028))+(((-1.0)*x1024*x1027)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x1032=(cj6*npy);
IkReal x1033=((0.293)*sj3);
IkReal x1034=(npx*sj6);
IkReal x1035=((0.0525)*cj3);
CheckValue<IkReal> x1036=IKPowWithIntegerCheck(((-0.0775)+(((-1.0)*x1033))+(((-1.0)*x1035))),-1);
if(!x1036.valid){
continue;
}
CheckValue<IkReal> x1037=IKPowWithIntegerCheck((((x1034*x1035))+((x1033*x1034))+((x1032*x1035))+((x1032*x1033))+(((0.0775)*x1034))+(((0.0775)*x1032))),-1);
if(!x1037.valid){
continue;
}
if( IKabs(((x1036.value)*((x1032+x1034)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1037.value)*((((npz*x1032))+((npz*x1034)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1036.value)*((x1032+x1034))))+IKsqr(((x1037.value)*((((npz*x1032))+((npz*x1034))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x1036.value)*((x1032+x1034))), ((x1037.value)*((((npz*x1032))+((npz*x1034))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x1038=IKcos(j4);
IkReal x1039=IKsin(j4);
IkReal x1040=((1.0)*npz);
IkReal x1041=((0.293)*sj3);
IkReal x1042=((0.0525)*cj3);
IkReal x1043=((1.0)*npx*sj6);
IkReal x1044=((1.0)*cj6*npy);
evalcond[0]=((((0.31903073501248)*sj3*x1038))+(((-0.354654245886855)*pp*x1038))+(((0.136242712699662)*x1038))+(((-1.0)*x1040)));
evalcond[1]=((((-1.0)*x1038*x1044))+(((-1.0)*x1038*x1043))+(((-1.0)*x1039*x1040)));
evalcond[2]=((((-0.0775)*x1039))+(((-1.0)*x1039*x1042))+(((-1.0)*x1039*x1041))+(((-1.0)*x1044))+(((-1.0)*x1043)));
evalcond[3]=((0.0775)+x1042+x1041+(((-1.0)*x1038*x1040))+((npx*sj6*x1039))+((cj6*npy*x1039)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x1045=IKPowWithIntegerCheck(((-0.0775)+(((-0.0525)*cj3))+(((-0.293)*sj3))),-1);
if(!x1045.valid){
continue;
}
CheckValue<IkReal> x1046=IKPowWithIntegerCheck(((0.136242712699662)+(((-0.354654245886855)*pp))+(((0.31903073501248)*sj3))),-1);
if(!x1046.valid){
continue;
}
if( IKabs(((x1045.value)*((((cj6*npy))+((npx*sj6)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((npz*(x1046.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1045.value)*((((cj6*npy))+((npx*sj6))))))+IKsqr((npz*(x1046.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x1045.value)*((((cj6*npy))+((npx*sj6))))), (npz*(x1046.value)));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x1047=IKcos(j4);
IkReal x1048=IKsin(j4);
IkReal x1049=((1.0)*npz);
IkReal x1050=((0.293)*sj3);
IkReal x1051=((0.0525)*cj3);
IkReal x1052=((1.0)*npx*sj6);
IkReal x1053=((1.0)*cj6*npy);
evalcond[0]=((((0.31903073501248)*sj3*x1047))+(((0.136242712699662)*x1047))+(((-0.354654245886855)*pp*x1047))+(((-1.0)*x1049)));
evalcond[1]=((((-1.0)*x1048*x1049))+(((-1.0)*x1047*x1052))+(((-1.0)*x1047*x1053)));
evalcond[2]=((((-1.0)*x1053))+(((-1.0)*x1052))+(((-1.0)*x1048*x1050))+(((-1.0)*x1048*x1051))+(((-0.0775)*x1048)));
evalcond[3]=((0.0775)+((npx*sj6*x1048))+x1050+x1051+(((-1.0)*x1047*x1049))+((cj6*npy*x1048)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x1054=IKPowWithIntegerCheck(IKsign(((0.136242712699662)+(((-0.354654245886855)*pp))+(((0.31903073501248)*sj3)))),-1);
if(!x1054.valid){
continue;
}
CheckValue<IkReal> x1055 = IKatan2WithCheck(IkReal(((((-1.0)*cj6*npy))+(((-1.0)*npx*sj6)))),IkReal(npz),IKFAST_ATAN2_MAGTHRESH);
if(!x1055.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1054.value)))+(x1055.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x1056=IKcos(j4);
IkReal x1057=IKsin(j4);
IkReal x1058=((1.0)*npz);
IkReal x1059=((0.293)*sj3);
IkReal x1060=((0.0525)*cj3);
IkReal x1061=((1.0)*npx*sj6);
IkReal x1062=((1.0)*cj6*npy);
evalcond[0]=((((-1.0)*x1058))+(((0.31903073501248)*sj3*x1056))+(((0.136242712699662)*x1056))+(((-0.354654245886855)*pp*x1056)));
evalcond[1]=((((-1.0)*x1056*x1062))+(((-1.0)*x1056*x1061))+(((-1.0)*x1057*x1058)));
evalcond[2]=((((-1.0)*x1057*x1060))+(((-1.0)*x1057*x1059))+(((-1.0)*x1061))+(((-1.0)*x1062))+(((-0.0775)*x1057)));
evalcond[3]=((0.0775)+x1059+x1060+((npx*sj6*x1057))+(((-1.0)*x1056*x1058))+((cj6*npy*x1057)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[2];
sj5=0;
cj5=1.0;
j5=0;
j4eval[0]=((-1.47619047619048)+(((-5.58095238095238)*sj3))+(((-1.0)*cj3)));
j4eval[1]=((-1.0)+(((1.29028294061626)*npz))+(((-2.17763509569598)*sj3)));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
sj5=0;
cj5=1.0;
j5=0;
IkReal x1063=(npx*sj6);
IkReal x1064=((5.58095238095238)*sj3);
IkReal x1065=(cj6*npy);
j4eval[0]=((-1.47619047619048)+(((-1.0)*x1064))+(((-1.0)*cj3)));
j4eval[1]=((((1.47619047619048)*x1065))+(((1.47619047619048)*x1063))+((cj3*x1063))+((cj3*x1065))+((x1063*x1064))+((x1064*x1065)));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
sj5=0;
cj5=1.0;
j5=0;
IkReal x1066=((1.29028294061626)*npz);
IkReal x1067=((2.17763509569598)*sj3);
IkReal x1068=(cj6*npx);
IkReal x1069=((16.9774071133719)*npz);
IkReal x1070=(npy*sj6);
IkReal x1071=((28.6530933644209)*sj3);
IkReal x1072=((-1.0)+x1066);
j4eval[0]=(((x1068*x1071))+((x1069*x1070))+x1072+(((-1.0)*x1070*x1071))+(((-13.1578947368421)*x1070))+(((-1.0)*x1068*x1069))+(((-1.0)*x1067))+(((13.1578947368421)*x1068)));
j4eval[1]=(x1072+(((-1.0)*x1067)));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
IkReal gconst36=((-0.459213759907003)+(((0.592515680504259)*npz)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((0.459213759907003)+sj3+(((-0.592515680504259)*npz)))))+(IKabs(((-1.0)+(IKsign(cj3)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[2];
IkReal x1073=((0.59251568)*npz);
sj5=0;
cj5=1.0;
j5=0;
sj3=((-0.45921376)+x1073);
if((((0.789122722712073)+(((0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz))))) < -0.00001)
continue;
cj3=IKsqrt(((0.789122722712073)+(((0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz)))));
if( (((0.45921376)+(((-1.0)*x1073)))) < -1-IKFAST_SINCOS_THRESH || (((0.45921376)+(((-1.0)*x1073)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=((-1.0)*(IKasin(((0.45921376)+(((-1.0)*x1073))))));
IkReal gconst36=((-0.459213759907003)+(((0.592515680504259)*npz)));
if((((0.789122722712073)+(((0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz))))) < -0.00001)
continue;
j4eval[0]=((1.08665965104762)+(((-3.30680179504762)*npz))+(((-1.0)*(IKsqrt(((0.789122722712073)+(((0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz)))))))));
j4eval[1]=((1.0)+(((5.42233009708738)*npz)));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
IkReal x1074=((0.59251568)*npz);
sj5=0;
cj5=1.0;
j5=0;
sj3=((-0.45921376)+x1074);
if((((0.789122722712073)+(((0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz))))) < -0.00001)
continue;
cj3=IKsqrt(((0.789122722712073)+(((0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz)))));
if( (((0.45921376)+(((-1.0)*x1074)))) < -1-IKFAST_SINCOS_THRESH || (((0.45921376)+(((-1.0)*x1074)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=((-1.0)*(IKasin(((0.45921376)+(((-1.0)*x1074))))));
IkReal gconst36=((-0.459213759907003)+(((0.592515680504259)*npz)));
IkReal x1075=((5.42233009708738)*npz);
IkReal x1076=(cj6*npx);
IkReal x1077=((71.3464486458866)*npz);
IkReal x1078=(npy*sj6);
IkReal x1079=((1.0)+x1075);
j4eval[0]=((((13.1578947368421)*x1078))+((x1077*x1078))+x1079+(((-1.0)*x1076*x1077))+(((-13.1578947368421)*x1076)));
j4eval[1]=x1079;
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j4]

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x1080=(npz*sj6);
IkReal x1081=(npx*sj6);
IkReal x1082=((1.0)*pp);
IkReal x1083=((2.31787030716724e-11)*npz);
IkReal x1084=(cj6*npx);
IkReal x1085=((0.684999999976364)*npz);
IkReal x1086=(cj6*npy);
CheckValue<IkReal> x1087=IKPowWithIntegerCheck(((3.24875358361775e-13)+(((2.31787030716724e-11)*npy*x1080))+(((1.7615814334471e-12)*npz))+(((4.27467576791809e-12)*npy*sj6))+(((-1.0)*x1083*x1084))+(((-4.27467576791809e-12)*x1084))),-1);
if(!x1087.valid){
continue;
}
CheckValue<IkReal> x1088=IKPowWithIntegerCheck(((4.27467576791809e-12)+x1083),-1);
if(!x1088.valid){
continue;
}
if( IKabs(((x1087.value)*(((((-0.028931250004359)*x1081))+(((-0.028931250004359)*x1086))+(((0.684999999976364)*npx*x1080))+(((-1.0)*x1081*x1082))+(((-1.0)*x1082*x1086))+((x1085*x1086)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1088.value)*(((-0.028931250004359)+x1085+(((-1.0)*x1082)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1087.value)*(((((-0.028931250004359)*x1081))+(((-0.028931250004359)*x1086))+(((0.684999999976364)*npx*x1080))+(((-1.0)*x1081*x1082))+(((-1.0)*x1082*x1086))+((x1085*x1086))))))+IKsqr(((x1088.value)*(((-0.028931250004359)+x1085+(((-1.0)*x1082))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x1087.value)*(((((-0.028931250004359)*x1081))+(((-0.028931250004359)*x1086))+(((0.684999999976364)*npx*x1080))+(((-1.0)*x1081*x1082))+(((-1.0)*x1082*x1086))+((x1085*x1086))))), ((x1088.value)*(((-0.028931250004359)+x1085+(((-1.0)*x1082))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[5];
IkReal x1089=IKcos(j4);
IkReal x1090=IKsin(j4);
IkReal x1091=((0.17360709424)*npz);
IkReal x1092=((1.0)*cj6);
IkReal x1093=(npz*x1089);
IkReal x1094=((1.0)*npx*sj6);
IkReal x1095=(npy*x1090);
IkReal x1096=(npx*x1090);
IkReal x1097=(npy*x1089);
if((((0.789122722712073)+(((0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz))))) < -0.00001)
continue;
IkReal x1098=IKsqrt(((0.789122722712073)+(((0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz)))));
IkReal x1099=((0.0525)*x1098);
evalcond[0]=((0.028931250004359)+pp+(((2.31787030716724e-11)*x1093))+(((4.27467576791809e-12)*x1089))+(((-0.684999999976364)*npz)));
evalcond[1]=((-0.19033717108131)+(((-2.8122866894198e-11)*x1089))+(((-6.57894736842105)*pp))+(((4.50657894721292)*npz))+(((-1.52491467576792e-10)*x1093)));
evalcond[2]=((((0.076)*x1090))+(((-1.0)*x1089*x1094))+(((-1.0)*x1092*x1096))+(((-1.0)*x1092*x1097))+((sj6*x1095)));
evalcond[3]=((((-1.0)*x1090*x1091))+(((-1.0)*x1090*x1099))+(((0.05704963168)*x1090))+(((-1.0)*x1094))+(((-1.0)*npy*x1092)));
evalcond[4]=((-0.05704963168)+((cj6*x1095))+x1091+x1099+(((-1.0)*npx*x1089*x1092))+(((0.076)*x1089))+((sj6*x1096))+((sj6*x1097)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if((((0.789122722712073)+(((0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz))))) < -0.00001)
continue;
CheckValue<IkReal> x1100=IKPowWithIntegerCheck(((0.05704963168)+(((-0.0525)*(IKsqrt(((0.789122722712073)+(((0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz))))))))+(((-0.17360709424)*npz))),-1);
if(!x1100.valid){
continue;
}
CheckValue<IkReal> x1101=IKPowWithIntegerCheck(((4.27467576791809e-12)+(((2.31787030716724e-11)*npz))),-1);
if(!x1101.valid){
continue;
}
if( IKabs(((x1100.value)*((((cj6*npy))+((npx*sj6)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1101.value)*(((-0.028931250004359)+(((0.684999999976364)*npz))+(((-1.0)*pp)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1100.value)*((((cj6*npy))+((npx*sj6))))))+IKsqr(((x1101.value)*(((-0.028931250004359)+(((0.684999999976364)*npz))+(((-1.0)*pp))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x1100.value)*((((cj6*npy))+((npx*sj6))))), ((x1101.value)*(((-0.028931250004359)+(((0.684999999976364)*npz))+(((-1.0)*pp))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[5];
IkReal x1102=IKcos(j4);
IkReal x1103=IKsin(j4);
IkReal x1104=((0.17360709424)*npz);
IkReal x1105=((1.0)*cj6);
IkReal x1106=(npz*x1102);
IkReal x1107=((1.0)*npx*sj6);
IkReal x1108=(npy*x1103);
IkReal x1109=(npx*x1103);
IkReal x1110=(npy*x1102);
if((((0.789122722712073)+(((0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz))))) < -0.00001)
continue;
IkReal x1111=IKsqrt(((0.789122722712073)+(((0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz)))));
IkReal x1112=((0.0525)*x1111);
evalcond[0]=((0.028931250004359)+(((4.27467576791809e-12)*x1102))+pp+(((2.31787030716724e-11)*x1106))+(((-0.684999999976364)*npz)));
evalcond[1]=((-0.19033717108131)+(((-6.57894736842105)*pp))+(((-1.52491467576792e-10)*x1106))+(((4.50657894721292)*npz))+(((-2.8122866894198e-11)*x1102)));
evalcond[2]=(((sj6*x1108))+(((0.076)*x1103))+(((-1.0)*x1102*x1107))+(((-1.0)*x1105*x1110))+(((-1.0)*x1105*x1109)));
evalcond[3]=((((-1.0)*x1103*x1104))+(((-1.0)*x1103*x1112))+(((-1.0)*npy*x1105))+(((-1.0)*x1107))+(((0.05704963168)*x1103)));
evalcond[4]=((-0.05704963168)+x1104+x1112+((sj6*x1109))+((sj6*x1110))+(((0.076)*x1102))+((cj6*x1108))+(((-1.0)*npx*x1102*x1105)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst36=((-0.459213759907003)+(((0.592515680504259)*npz)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.0)+(IKsign(cj3)))))+(IKabs(((0.459213759907003)+sj3+(((-0.592515680504259)*npz)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[2];
IkReal x1113=((0.59251568)*npz);
sj5=0;
cj5=1.0;
j5=0;
sj3=((-0.45921376)+x1113);
if((((0.789122722712073)+(((0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz))))) < -0.00001)
continue;
cj3=((-1.0)*(IKsqrt(((0.789122722712073)+(((0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz)))))));
if( (((-0.45921376)+x1113)) < -1-IKFAST_SINCOS_THRESH || (((-0.45921376)+x1113)) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=((3.14159265)+(((-1.0)*(IKasin(((-0.45921376)+x1113))))));
IkReal gconst36=((-0.459213759907003)+(((0.592515680504259)*npz)));
if((((0.789122722712073)+(((0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz))))) < -0.00001)
continue;
j4eval[0]=((1.08665965104762)+(((-3.30680179504762)*npz))+(IKsqrt(((0.789122722712073)+(((0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz)))))));
j4eval[1]=((1.0)+(((5.42233009708738)*npz)));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
IkReal x1114=((0.59251568)*npz);
sj5=0;
cj5=1.0;
j5=0;
sj3=((-0.45921376)+x1114);
if((((0.789122722712073)+(((0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz))))) < -0.00001)
continue;
cj3=((-1.0)*(IKsqrt(((0.789122722712073)+(((0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz)))))));
if( (((0.45921376)+(((-1.0)*x1114)))) < -1-IKFAST_SINCOS_THRESH || (((0.45921376)+(((-1.0)*x1114)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=((3.14159265)+(((1.0)*(IKasin(((0.45921376)+(((-1.0)*x1114))))))));
IkReal gconst36=((-0.459213759907003)+(((0.592515680504259)*npz)));
IkReal x1115=((5.42233009708738)*npz);
IkReal x1116=(cj6*npx);
IkReal x1117=((71.3464486458866)*npz);
IkReal x1118=(npy*sj6);
IkReal x1119=((1.0)+x1115);
j4eval[0]=(x1119+(((-1.0)*x1116*x1117))+((x1117*x1118))+(((-13.1578947368421)*x1116))+(((13.1578947368421)*x1118)));
j4eval[1]=x1119;
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j4]

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x1120=(npz*sj6);
IkReal x1121=(npx*sj6);
IkReal x1122=((1.0)*pp);
IkReal x1123=((2.31787030716724e-11)*npz);
IkReal x1124=(cj6*npx);
IkReal x1125=((0.684999999976364)*npz);
IkReal x1126=(cj6*npy);
CheckValue<IkReal> x1127=IKPowWithIntegerCheck(((3.24875358361775e-13)+(((1.7615814334471e-12)*npz))+(((2.31787030716724e-11)*npy*x1120))+(((-4.27467576791809e-12)*x1124))+(((-1.0)*x1123*x1124))+(((4.27467576791809e-12)*npy*sj6))),-1);
if(!x1127.valid){
continue;
}
CheckValue<IkReal> x1128=IKPowWithIntegerCheck(((4.27467576791809e-12)+x1123),-1);
if(!x1128.valid){
continue;
}
if( IKabs(((x1127.value)*(((((-0.028931250004359)*x1126))+(((-0.028931250004359)*x1121))+(((-1.0)*x1121*x1122))+(((-1.0)*x1122*x1126))+((x1125*x1126))+(((0.684999999976364)*npx*x1120)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1128.value)*(((-0.028931250004359)+x1125+(((-1.0)*x1122)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1127.value)*(((((-0.028931250004359)*x1126))+(((-0.028931250004359)*x1121))+(((-1.0)*x1121*x1122))+(((-1.0)*x1122*x1126))+((x1125*x1126))+(((0.684999999976364)*npx*x1120))))))+IKsqr(((x1128.value)*(((-0.028931250004359)+x1125+(((-1.0)*x1122))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x1127.value)*(((((-0.028931250004359)*x1126))+(((-0.028931250004359)*x1121))+(((-1.0)*x1121*x1122))+(((-1.0)*x1122*x1126))+((x1125*x1126))+(((0.684999999976364)*npx*x1120))))), ((x1128.value)*(((-0.028931250004359)+x1125+(((-1.0)*x1122))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[5];
IkReal x1129=IKcos(j4);
IkReal x1130=IKsin(j4);
IkReal x1131=((0.17360709424)*npz);
IkReal x1132=((1.0)*cj6);
IkReal x1133=(npz*x1129);
IkReal x1134=((1.0)*npx*sj6);
IkReal x1135=(npy*x1130);
IkReal x1136=(npx*x1130);
IkReal x1137=(npy*x1129);
if((((0.789122722712073)+(((0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz))))) < -0.00001)
continue;
IkReal x1138=IKsqrt(((0.789122722712073)+(((0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz)))));
IkReal x1139=((0.0525)*x1138);
evalcond[0]=((0.028931250004359)+(((4.27467576791809e-12)*x1129))+pp+(((2.31787030716724e-11)*x1133))+(((-0.684999999976364)*npz)));
evalcond[1]=((-0.19033717108131)+(((-2.8122866894198e-11)*x1129))+(((-6.57894736842105)*pp))+(((4.50657894721292)*npz))+(((-1.52491467576792e-10)*x1133)));
evalcond[2]=((((0.076)*x1130))+(((-1.0)*x1132*x1136))+(((-1.0)*x1132*x1137))+((sj6*x1135))+(((-1.0)*x1129*x1134)));
evalcond[3]=((((-1.0)*npy*x1132))+((x1130*x1139))+(((0.05704963168)*x1130))+(((-1.0)*x1130*x1131))+(((-1.0)*x1134)));
evalcond[4]=((-0.05704963168)+x1131+(((0.076)*x1129))+(((-1.0)*x1139))+(((-1.0)*npx*x1129*x1132))+((sj6*x1137))+((sj6*x1136))+((cj6*x1135)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if((((0.789122722712073)+(((0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz))))) < -0.00001)
continue;
CheckValue<IkReal> x1140=IKPowWithIntegerCheck(((0.05704963168)+(((-0.17360709424)*npz))+(((0.0525)*(IKsqrt(((0.789122722712073)+(((0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz))))))))),-1);
if(!x1140.valid){
continue;
}
CheckValue<IkReal> x1141=IKPowWithIntegerCheck(((4.27467576791809e-12)+(((2.31787030716724e-11)*npz))),-1);
if(!x1141.valid){
continue;
}
if( IKabs(((x1140.value)*((((cj6*npy))+((npx*sj6)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1141.value)*(((-0.028931250004359)+(((0.684999999976364)*npz))+(((-1.0)*pp)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1140.value)*((((cj6*npy))+((npx*sj6))))))+IKsqr(((x1141.value)*(((-0.028931250004359)+(((0.684999999976364)*npz))+(((-1.0)*pp))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x1140.value)*((((cj6*npy))+((npx*sj6))))), ((x1141.value)*(((-0.028931250004359)+(((0.684999999976364)*npz))+(((-1.0)*pp))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[5];
IkReal x1142=IKcos(j4);
IkReal x1143=IKsin(j4);
IkReal x1144=((0.17360709424)*npz);
IkReal x1145=((1.0)*cj6);
IkReal x1146=(npz*x1142);
IkReal x1147=((1.0)*npx*sj6);
IkReal x1148=(npy*x1143);
IkReal x1149=(npx*x1143);
IkReal x1150=(npy*x1142);
if((((0.789122722712073)+(((0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz))))) < -0.00001)
continue;
IkReal x1151=IKsqrt(((0.789122722712073)+(((0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz)))));
IkReal x1152=((0.0525)*x1151);
evalcond[0]=((0.028931250004359)+(((2.31787030716724e-11)*x1146))+(((4.27467576791809e-12)*x1142))+pp+(((-0.684999999976364)*npz)));
evalcond[1]=((-0.19033717108131)+(((-6.57894736842105)*pp))+(((4.50657894721292)*npz))+(((-1.52491467576792e-10)*x1146))+(((-2.8122866894198e-11)*x1142)));
evalcond[2]=((((-1.0)*x1145*x1149))+((sj6*x1148))+(((0.076)*x1143))+(((-1.0)*x1145*x1150))+(((-1.0)*x1142*x1147)));
evalcond[3]=((((-1.0)*x1143*x1144))+((x1143*x1152))+(((-1.0)*npy*x1145))+(((-1.0)*x1147))+(((0.05704963168)*x1143)));
evalcond[4]=((-0.05704963168)+((sj6*x1149))+(((0.076)*x1142))+x1144+((cj6*x1148))+(((-1.0)*x1152))+(((-1.0)*npx*x1142*x1145))+((sj6*x1150)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x1153=(npx*sj6);
IkReal x1154=((0.0468730844709898)*sj3);
IkReal x1155=((0.657226962457338)*npz);
IkReal x1156=(cj6*npy);
IkReal x1157=((1.0)*pp);
IkReal x1158=(cj6*npx);
IkReal x1159=((0.0272354948805461)*npz);
IkReal x1160=(npy*sj6);
IkReal x1161=((0.0459658634812287)*sj3);
CheckValue<IkReal> x1162=IKPowWithIntegerCheck(((-0.00160421993174061)+(((0.0020698976109215)*npz))+((x1159*x1160))+(((-0.00349340562457338)*sj3))+(((-1.0)*x1158*x1159))+(((-0.021108156996587)*x1160))+((x1158*x1161))+(((-1.0)*x1160*x1161))+(((0.021108156996587)*x1158))),-1);
if(!x1162.valid){
continue;
}
CheckValue<IkReal> x1163=IKPowWithIntegerCheck(((-0.021108156996587)+x1159+(((-1.0)*x1161))),-1);
if(!x1163.valid){
continue;
}
if( IKabs(((x1162.value)*(((((-0.00740648464163822)*x1156))+(((-0.00740648464163822)*x1153))+((x1153*x1155))+((x1153*x1154))+(((-1.0)*x1156*x1157))+(((-1.0)*x1153*x1157))+((x1154*x1156))+((x1155*x1156)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1163.value)*(((-0.00740648464163822)+x1155+x1154+(((-1.0)*x1157)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1162.value)*(((((-0.00740648464163822)*x1156))+(((-0.00740648464163822)*x1153))+((x1153*x1155))+((x1153*x1154))+(((-1.0)*x1156*x1157))+(((-1.0)*x1153*x1157))+((x1154*x1156))+((x1155*x1156))))))+IKsqr(((x1163.value)*(((-0.00740648464163822)+x1155+x1154+(((-1.0)*x1157))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x1162.value)*(((((-0.00740648464163822)*x1156))+(((-0.00740648464163822)*x1153))+((x1153*x1155))+((x1153*x1154))+(((-1.0)*x1156*x1157))+(((-1.0)*x1153*x1157))+((x1154*x1156))+((x1155*x1156))))), ((x1163.value)*(((-0.00740648464163822)+x1155+x1154+(((-1.0)*x1157))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[5];
IkReal x1164=IKsin(j4);
IkReal x1165=IKcos(j4);
IkReal x1166=((0.293)*sj3);
IkReal x1167=((1.0)*cj6);
IkReal x1168=((0.0525)*cj3);
IkReal x1169=((1.0)*npx*sj6);
IkReal x1170=(npy*x1164);
IkReal x1171=(npz*x1165);
IkReal x1172=(npx*x1164);
IkReal x1173=(sj3*x1165);
IkReal x1174=(npy*x1165);
evalcond[0]=((((-1.0)*x1164*x1168))+(((-1.0)*x1164*x1166))+(((-1.0)*x1169))+(((-0.0775)*x1164))+(((-1.0)*npy*x1167)));
evalcond[1]=((0.00740648464163822)+(((-0.657226962457338)*npz))+(((-0.0468730844709898)*sj3))+(((-0.021108156996587)*x1165))+pp+(((0.0272354948805461)*x1171))+(((-0.0459658634812287)*x1173)));
evalcond[2]=((-0.0487268726423567)+(((0.302406996587031)*x1173))+(((-6.57894736842105)*pp))+(((4.32386159511406)*npz))+(((-0.179180887372014)*x1171))+(((0.138869453924915)*x1165))+(((0.308375555730196)*sj3)));
evalcond[3]=(((sj6*x1170))+(((0.076)*x1164))+(((-1.0)*x1167*x1172))+(((-1.0)*x1167*x1174))+(((-1.0)*x1165*x1169)));
evalcond[4]=((0.0775)+x1166+x1168+(((-1.0)*npx*x1165*x1167))+((sj6*x1172))+((sj6*x1174))+(((0.076)*x1165))+((cj6*x1170)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x1175=(cj6*sj6);
IkReal x1176=((0.293)*sj3);
IkReal x1177=(npx*sj6);
IkReal x1178=(cj6*npy);
IkReal x1179=((0.0525)*cj3);
IkReal x1180=(npx*npy);
CheckValue<IkReal> x1181=IKPowWithIntegerCheck(((-0.0775)+(((-1.0)*x1176))+(((-1.0)*x1179))),-1);
if(!x1181.valid){
continue;
}
CheckValue<IkReal> x1182=IKPowWithIntegerCheck(((((0.0775)*x1177))+(((0.0775)*x1178))+((x1176*x1178))+((x1176*x1177))+((x1177*x1179))+((x1178*x1179))),-1);
if(!x1182.valid){
continue;
}
if( IKabs(((x1181.value)*((x1177+x1178)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1182.value)*(((((-0.076)*x1178))+(((-0.076)*x1177))+(((2.0)*cj6*npx*x1178))+(((-1.0)*x1180))+((x1175*(npx*npx)))+(((-1.0)*x1175*(npy*npy))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1181.value)*((x1177+x1178))))+IKsqr(((x1182.value)*(((((-0.076)*x1178))+(((-0.076)*x1177))+(((2.0)*cj6*npx*x1178))+(((-1.0)*x1180))+((x1175*(npx*npx)))+(((-1.0)*x1175*(npy*npy)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x1181.value)*((x1177+x1178))), ((x1182.value)*(((((-0.076)*x1178))+(((-0.076)*x1177))+(((2.0)*cj6*npx*x1178))+(((-1.0)*x1180))+((x1175*(npx*npx)))+(((-1.0)*x1175*(npy*npy)))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[5];
IkReal x1183=IKsin(j4);
IkReal x1184=IKcos(j4);
IkReal x1185=((0.293)*sj3);
IkReal x1186=((1.0)*cj6);
IkReal x1187=((0.0525)*cj3);
IkReal x1188=((1.0)*npx*sj6);
IkReal x1189=(npy*x1183);
IkReal x1190=(npz*x1184);
IkReal x1191=(npx*x1183);
IkReal x1192=(sj3*x1184);
IkReal x1193=(npy*x1184);
evalcond[0]=((((-1.0)*npy*x1186))+(((-1.0)*x1188))+(((-1.0)*x1183*x1187))+(((-1.0)*x1183*x1185))+(((-0.0775)*x1183)));
evalcond[1]=((0.00740648464163822)+(((0.0272354948805461)*x1190))+(((-0.0459658634812287)*x1192))+(((-0.657226962457338)*npz))+(((-0.021108156996587)*x1184))+(((-0.0468730844709898)*sj3))+pp);
evalcond[2]=((-0.0487268726423567)+(((-6.57894736842105)*pp))+(((4.32386159511406)*npz))+(((0.138869453924915)*x1184))+(((-0.179180887372014)*x1190))+(((0.302406996587031)*x1192))+(((0.308375555730196)*sj3)));
evalcond[3]=((((0.076)*x1183))+(((-1.0)*x1186*x1193))+(((-1.0)*x1186*x1191))+(((-1.0)*x1184*x1188))+((sj6*x1189)));
evalcond[4]=((0.0775)+((cj6*x1189))+x1187+x1185+(((-1.0)*npx*x1184*x1186))+(((0.076)*x1184))+((sj6*x1193))+((sj6*x1191)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x1194=IKPowWithIntegerCheck(((-0.0775)+(((-0.0525)*cj3))+(((-0.293)*sj3))),-1);
if(!x1194.valid){
continue;
}
CheckValue<IkReal> x1195=IKPowWithIntegerCheck(((-0.021108156996587)+(((-0.0459658634812287)*sj3))+(((0.0272354948805461)*npz))),-1);
if(!x1195.valid){
continue;
}
if( IKabs(((x1194.value)*((((cj6*npy))+((npx*sj6)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1195.value)*(((-0.00740648464163822)+(((0.657226962457338)*npz))+(((0.0468730844709898)*sj3))+(((-1.0)*pp)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1194.value)*((((cj6*npy))+((npx*sj6))))))+IKsqr(((x1195.value)*(((-0.00740648464163822)+(((0.657226962457338)*npz))+(((0.0468730844709898)*sj3))+(((-1.0)*pp))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x1194.value)*((((cj6*npy))+((npx*sj6))))), ((x1195.value)*(((-0.00740648464163822)+(((0.657226962457338)*npz))+(((0.0468730844709898)*sj3))+(((-1.0)*pp))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[5];
IkReal x1196=IKsin(j4);
IkReal x1197=IKcos(j4);
IkReal x1198=((0.293)*sj3);
IkReal x1199=((1.0)*cj6);
IkReal x1200=((0.0525)*cj3);
IkReal x1201=((1.0)*npx*sj6);
IkReal x1202=(npy*x1196);
IkReal x1203=(npz*x1197);
IkReal x1204=(npx*x1196);
IkReal x1205=(sj3*x1197);
IkReal x1206=(npy*x1197);
evalcond[0]=((((-1.0)*npy*x1199))+(((-1.0)*x1196*x1200))+(((-1.0)*x1196*x1198))+(((-1.0)*x1201))+(((-0.0775)*x1196)));
evalcond[1]=((0.00740648464163822)+(((-0.657226962457338)*npz))+(((-0.021108156996587)*x1197))+(((0.0272354948805461)*x1203))+(((-0.0468730844709898)*sj3))+pp+(((-0.0459658634812287)*x1205)));
evalcond[2]=((-0.0487268726423567)+(((-0.179180887372014)*x1203))+(((-6.57894736842105)*pp))+(((4.32386159511406)*npz))+(((0.302406996587031)*x1205))+(((0.138869453924915)*x1197))+(((0.308375555730196)*sj3)));
evalcond[3]=((((-1.0)*x1199*x1204))+(((-1.0)*x1199*x1206))+(((0.076)*x1196))+((sj6*x1202))+(((-1.0)*x1197*x1201)));
evalcond[4]=((0.0775)+x1198+x1200+(((0.076)*x1197))+(((-1.0)*npx*x1197*x1199))+((sj6*x1206))+((sj6*x1204))+((cj6*x1202)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[2];
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
j4eval[0]=((-1.47619047619048)+(((-5.58095238095238)*sj3))+(((-1.0)*cj3)));
j4eval[1]=((1.0)+(((1.29028294061626)*npz))+(((2.17763509569598)*sj3)));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
IkReal x1207=(npx*sj6);
IkReal x1208=((5.58095238095238)*sj3);
IkReal x1209=(cj6*npy);
j4eval[0]=((-1.47619047619048)+(((-1.0)*x1208))+(((-1.0)*cj3)));
j4eval[1]=(((x1208*x1209))+(((1.47619047619048)*x1209))+(((1.47619047619048)*x1207))+((cj3*x1209))+((cj3*x1207))+((x1207*x1208)));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
IkReal x1210=((1.29028294061626)*npz);
IkReal x1211=((2.17763509569598)*sj3);
IkReal x1212=(cj6*npx);
IkReal x1213=((16.9774071133719)*npz);
IkReal x1214=(npy*sj6);
IkReal x1215=((28.6530933644209)*sj3);
IkReal x1216=(x1210+x1211);
j4eval[0]=((-1.0)+((x1212*x1213))+((x1212*x1215))+(((-1.0)*x1214*x1215))+(((-13.1578947368421)*x1214))+(((-1.0)*x1213*x1214))+(((13.1578947368421)*x1212))+(((-1.0)*x1216)));
j4eval[1]=((1.0)+x1216);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
IkReal gconst38=((-0.459213759907003)+(((-0.592515680504259)*npz)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((0.459213759907003)+sj3+(((0.592515680504259)*npz)))))+(IKabs(((-1.0)+(IKsign(cj3)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[2];
IkReal x1217=((0.59251568)*npz);
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj3=((-0.45921376)+(((-1.0)*x1217)));
if((((0.789122722712073)+(((-0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz))))) < -0.00001)
continue;
cj3=IKsqrt(((0.789122722712073)+(((-0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz)))));
if( (((0.45921376)+x1217)) < -1-IKFAST_SINCOS_THRESH || (((0.45921376)+x1217)) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=((-1.0)*(IKasin(((0.45921376)+x1217))));
IkReal gconst38=((-0.459213759907003)+(((-0.592515680504259)*npz)));
if((((0.789122722712073)+(((-0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz))))) < -0.00001)
continue;
j4eval[0]=((1.08665965104762)+(((3.30680179504762)*npz))+(((-1.0)*(IKsqrt(((0.789122722712073)+(((-0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz)))))))));
j4eval[1]=((-1.0)+(((5.42233009708738)*npz)));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
IkReal x1218=((0.59251568)*npz);
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj3=((-0.45921376)+(((-1.0)*x1218)));
if((((0.789122722712073)+(((-0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz))))) < -0.00001)
continue;
cj3=IKsqrt(((0.789122722712073)+(((-0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz)))));
if( (((0.45921376)+x1218)) < -1-IKFAST_SINCOS_THRESH || (((0.45921376)+x1218)) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=((-1.0)*(IKasin(((0.45921376)+x1218))));
IkReal gconst38=((-0.459213759907003)+(((-0.592515680504259)*npz)));
IkReal x1219=((5.42233009708738)*npz);
IkReal x1220=(cj6*npx);
IkReal x1221=((71.3464486458866)*npz);
IkReal x1222=(npy*sj6);
j4eval[0]=((1.0)+(((-13.1578947368421)*x1220))+(((-1.0)*x1221*x1222))+(((13.1578947368421)*x1222))+((x1220*x1221))+(((-1.0)*x1219)));
j4eval[1]=((-1.0)+x1219);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j4]

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x1223=(npz*sj6);
IkReal x1224=(npx*sj6);
IkReal x1225=((1.0)*pp);
IkReal x1226=((2.31787030716724e-11)*npz);
IkReal x1227=(cj6*npx);
IkReal x1228=((0.684999999976364)*npz);
IkReal x1229=(cj6*npy);
CheckValue<IkReal> x1230=IKPowWithIntegerCheck(((3.24875358361775e-13)+(((4.27467576791809e-12)*npy*sj6))+(((-1.7615814334471e-12)*npz))+((x1226*x1227))+(((-2.31787030716724e-11)*npy*x1223))+(((-4.27467576791809e-12)*x1227))),-1);
if(!x1230.valid){
continue;
}
CheckValue<IkReal> x1231=IKPowWithIntegerCheck(((-4.27467576791809e-12)+x1226),-1);
if(!x1231.valid){
continue;
}
if( IKabs(((x1230.value)*(((((-1.0)*x1224*x1225))+(((-1.0)*x1225*x1229))+(((-0.684999999976364)*npx*x1223))+(((-1.0)*x1228*x1229))+(((-0.028931250004359)*x1229))+(((-0.028931250004359)*x1224)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1231.value)*(((-0.028931250004359)+(((-1.0)*x1225))+(((-1.0)*x1228)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1230.value)*(((((-1.0)*x1224*x1225))+(((-1.0)*x1225*x1229))+(((-0.684999999976364)*npx*x1223))+(((-1.0)*x1228*x1229))+(((-0.028931250004359)*x1229))+(((-0.028931250004359)*x1224))))))+IKsqr(((x1231.value)*(((-0.028931250004359)+(((-1.0)*x1225))+(((-1.0)*x1228))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x1230.value)*(((((-1.0)*x1224*x1225))+(((-1.0)*x1225*x1229))+(((-0.684999999976364)*npx*x1223))+(((-1.0)*x1228*x1229))+(((-0.028931250004359)*x1229))+(((-0.028931250004359)*x1224))))), ((x1231.value)*(((-0.028931250004359)+(((-1.0)*x1225))+(((-1.0)*x1228))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[5];
IkReal x1232=IKcos(j4);
IkReal x1233=IKsin(j4);
IkReal x1234=(cj6*npx);
IkReal x1235=((0.17360709424)*npz);
IkReal x1236=(cj6*npy);
IkReal x1237=(npz*x1232);
IkReal x1238=((1.0)*npx*sj6);
IkReal x1239=((1.0)*x1232);
IkReal x1240=(sj6*x1233);
if((((0.789122722712073)+(((-0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz))))) < -0.00001)
continue;
IkReal x1241=IKsqrt(((0.789122722712073)+(((-0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz)))));
IkReal x1242=((0.0525)*x1241);
evalcond[0]=((0.028931250004359)+(((2.31787030716724e-11)*x1237))+(((0.684999999976364)*npz))+pp+(((-4.27467576791809e-12)*x1232)));
evalcond[1]=((-0.19033717108131)+(((-1.52491467576792e-10)*x1237))+(((2.8122866894198e-11)*x1232))+(((-6.57894736842105)*pp))+(((-4.50657894721292)*npz)));
evalcond[2]=((((-1.0)*npy*x1240))+(((-1.0)*x1236*x1239))+((x1233*x1234))+(((-0.076)*x1233))+(((-1.0)*x1232*x1238)));
evalcond[3]=((((-1.0)*x1236))+(((0.05704963168)*x1233))+(((-1.0)*x1238))+(((-1.0)*x1233*x1242))+((x1233*x1235)));
evalcond[4]=((-0.05704963168)+x1242+(((-1.0)*x1235))+(((-1.0)*npy*sj6*x1239))+((npx*x1240))+((x1233*x1236))+((x1232*x1234))+(((-0.076)*x1232)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if((((0.789122722712073)+(((-0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz))))) < -0.00001)
continue;
CheckValue<IkReal> x1243=IKPowWithIntegerCheck(((0.05704963168)+(((0.17360709424)*npz))+(((-0.0525)*(IKsqrt(((0.789122722712073)+(((-0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz))))))))),-1);
if(!x1243.valid){
continue;
}
CheckValue<IkReal> x1244=IKPowWithIntegerCheck(((-4.27467576791809e-12)+(((2.31787030716724e-11)*npz))),-1);
if(!x1244.valid){
continue;
}
if( IKabs(((x1243.value)*((((cj6*npy))+((npx*sj6)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1244.value)*(((-0.028931250004359)+(((-1.0)*pp))+(((-0.684999999976364)*npz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1243.value)*((((cj6*npy))+((npx*sj6))))))+IKsqr(((x1244.value)*(((-0.028931250004359)+(((-1.0)*pp))+(((-0.684999999976364)*npz))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x1243.value)*((((cj6*npy))+((npx*sj6))))), ((x1244.value)*(((-0.028931250004359)+(((-1.0)*pp))+(((-0.684999999976364)*npz))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[5];
IkReal x1245=IKcos(j4);
IkReal x1246=IKsin(j4);
IkReal x1247=(cj6*npx);
IkReal x1248=((0.17360709424)*npz);
IkReal x1249=(cj6*npy);
IkReal x1250=(npz*x1245);
IkReal x1251=((1.0)*npx*sj6);
IkReal x1252=((1.0)*x1245);
IkReal x1253=(sj6*x1246);
if((((0.789122722712073)+(((-0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz))))) < -0.00001)
continue;
IkReal x1254=IKsqrt(((0.789122722712073)+(((-0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz)))));
IkReal x1255=((0.0525)*x1254);
evalcond[0]=((0.028931250004359)+(((0.684999999976364)*npz))+pp+(((2.31787030716724e-11)*x1250))+(((-4.27467576791809e-12)*x1245)));
evalcond[1]=((-0.19033717108131)+(((-6.57894736842105)*pp))+(((2.8122866894198e-11)*x1245))+(((-4.50657894721292)*npz))+(((-1.52491467576792e-10)*x1250)));
evalcond[2]=((((-1.0)*x1249*x1252))+(((-1.0)*npy*x1253))+(((-1.0)*x1245*x1251))+((x1246*x1247))+(((-0.076)*x1246)));
evalcond[3]=((((-1.0)*x1251))+(((-1.0)*x1249))+(((-1.0)*x1246*x1255))+((x1246*x1248))+(((0.05704963168)*x1246)));
evalcond[4]=((-0.05704963168)+((npx*x1253))+x1255+(((-1.0)*x1248))+((x1246*x1249))+((x1245*x1247))+(((-1.0)*npy*sj6*x1252))+(((-0.076)*x1245)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst38=((-0.459213759907003)+(((-0.592515680504259)*npz)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((0.459213759907003)+sj3+(((0.592515680504259)*npz)))))+(IKabs(((1.0)+(IKsign(cj3)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[2];
IkReal x1256=((0.59251568)*npz);
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj3=((-0.45921376)+(((-1.0)*x1256)));
if((((0.789122722712073)+(((-0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz))))) < -0.00001)
continue;
cj3=((-1.0)*(IKsqrt(((0.789122722712073)+(((-0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz)))))));
if( (((0.45921376)+x1256)) < -1-IKFAST_SINCOS_THRESH || (((0.45921376)+x1256)) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=((3.14159265)+(IKasin(((0.45921376)+x1256))));
IkReal gconst38=((-0.459213759907003)+(((-0.592515680504259)*npz)));
if((((0.789122722712073)+(((-0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz))))) < -0.00001)
continue;
j4eval[0]=((1.08665965104762)+(IKsqrt(((0.789122722712073)+(((-0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz))))))+(((3.30680179504762)*npz)));
j4eval[1]=((-1.0)+(((5.42233009708738)*npz)));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
IkReal x1257=((0.59251568)*npz);
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj3=((-0.45921376)+(((-1.0)*x1257)));
if((((0.789122722712073)+(((-0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz))))) < -0.00001)
continue;
cj3=((-1.0)*(IKsqrt(((0.789122722712073)+(((-0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz)))))));
if( (((0.45921376)+x1257)) < -1-IKFAST_SINCOS_THRESH || (((0.45921376)+x1257)) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=((3.14159265)+(IKasin(((0.45921376)+x1257))));
IkReal gconst38=((-0.459213759907003)+(((-0.592515680504259)*npz)));
IkReal x1258=((5.42233009708738)*npz);
IkReal x1259=(cj6*npx);
IkReal x1260=((71.3464486458866)*npz);
IkReal x1261=(npy*sj6);
j4eval[0]=((1.0)+(((-1.0)*x1258))+(((-1.0)*x1260*x1261))+(((13.1578947368421)*x1261))+((x1259*x1260))+(((-13.1578947368421)*x1259)));
j4eval[1]=((-1.0)+x1258);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j4]

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x1262=(npz*sj6);
IkReal x1263=(npx*sj6);
IkReal x1264=((1.0)*pp);
IkReal x1265=((2.31787030716724e-11)*npz);
IkReal x1266=(cj6*npx);
IkReal x1267=((0.684999999976364)*npz);
IkReal x1268=(cj6*npy);
CheckValue<IkReal> x1269=IKPowWithIntegerCheck(((3.24875358361775e-13)+(((-2.31787030716724e-11)*npy*x1262))+(((4.27467576791809e-12)*npy*sj6))+(((-4.27467576791809e-12)*x1266))+(((-1.7615814334471e-12)*npz))+((x1265*x1266))),-1);
if(!x1269.valid){
continue;
}
CheckValue<IkReal> x1270=IKPowWithIntegerCheck(((-4.27467576791809e-12)+x1265),-1);
if(!x1270.valid){
continue;
}
if( IKabs(((x1269.value)*(((((-1.0)*x1264*x1268))+(((-1.0)*x1263*x1264))+(((-1.0)*x1267*x1268))+(((-0.028931250004359)*x1268))+(((-0.028931250004359)*x1263))+(((-0.684999999976364)*npx*x1262)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1270.value)*(((-0.028931250004359)+(((-1.0)*x1267))+(((-1.0)*x1264)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1269.value)*(((((-1.0)*x1264*x1268))+(((-1.0)*x1263*x1264))+(((-1.0)*x1267*x1268))+(((-0.028931250004359)*x1268))+(((-0.028931250004359)*x1263))+(((-0.684999999976364)*npx*x1262))))))+IKsqr(((x1270.value)*(((-0.028931250004359)+(((-1.0)*x1267))+(((-1.0)*x1264))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x1269.value)*(((((-1.0)*x1264*x1268))+(((-1.0)*x1263*x1264))+(((-1.0)*x1267*x1268))+(((-0.028931250004359)*x1268))+(((-0.028931250004359)*x1263))+(((-0.684999999976364)*npx*x1262))))), ((x1270.value)*(((-0.028931250004359)+(((-1.0)*x1267))+(((-1.0)*x1264))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[5];
IkReal x1271=IKcos(j4);
IkReal x1272=IKsin(j4);
IkReal x1273=((0.17360709424)*npz);
IkReal x1274=((1.0)*npy);
IkReal x1275=(cj6*x1272);
IkReal x1276=(npz*x1271);
IkReal x1277=((1.0)*npx*sj6);
IkReal x1278=(cj6*x1274);
IkReal x1279=(sj6*x1272);
if((((0.789122722712073)+(((-0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz))))) < -0.00001)
continue;
IkReal x1280=IKsqrt(((0.789122722712073)+(((-0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz)))));
IkReal x1281=((0.0525)*x1280);
evalcond[0]=((0.028931250004359)+(((0.684999999976364)*npz))+(((-4.27467576791809e-12)*x1271))+pp+(((2.31787030716724e-11)*x1276)));
evalcond[1]=((-0.19033717108131)+(((2.8122866894198e-11)*x1271))+(((-6.57894736842105)*pp))+(((-4.50657894721292)*npz))+(((-1.52491467576792e-10)*x1276)));
evalcond[2]=(((npx*x1275))+(((-1.0)*x1271*x1278))+(((-1.0)*x1271*x1277))+(((-1.0)*x1274*x1279))+(((-0.076)*x1272)));
evalcond[3]=((((-1.0)*x1278))+(((-1.0)*x1277))+((x1272*x1273))+(((0.05704963168)*x1272))+((x1272*x1281)));
evalcond[4]=((-0.05704963168)+(((-1.0)*sj6*x1271*x1274))+((cj6*npx*x1271))+((npx*x1279))+(((-1.0)*x1273))+((npy*x1275))+(((-1.0)*x1281))+(((-0.076)*x1271)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if((((0.789122722712073)+(((-0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz))))) < -0.00001)
continue;
CheckValue<IkReal> x1282=IKPowWithIntegerCheck(((0.05704963168)+(((0.0525)*(IKsqrt(((0.789122722712073)+(((-0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz))))))))+(((0.17360709424)*npz))),-1);
if(!x1282.valid){
continue;
}
CheckValue<IkReal> x1283=IKPowWithIntegerCheck(((-4.27467576791809e-12)+(((2.31787030716724e-11)*npz))),-1);
if(!x1283.valid){
continue;
}
if( IKabs(((x1282.value)*((((cj6*npy))+((npx*sj6)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1283.value)*(((-0.028931250004359)+(((-1.0)*pp))+(((-0.684999999976364)*npz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1282.value)*((((cj6*npy))+((npx*sj6))))))+IKsqr(((x1283.value)*(((-0.028931250004359)+(((-1.0)*pp))+(((-0.684999999976364)*npz))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x1282.value)*((((cj6*npy))+((npx*sj6))))), ((x1283.value)*(((-0.028931250004359)+(((-1.0)*pp))+(((-0.684999999976364)*npz))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[5];
IkReal x1284=IKcos(j4);
IkReal x1285=IKsin(j4);
IkReal x1286=((0.17360709424)*npz);
IkReal x1287=((1.0)*npy);
IkReal x1288=(cj6*x1285);
IkReal x1289=(npz*x1284);
IkReal x1290=((1.0)*npx*sj6);
IkReal x1291=(cj6*x1287);
IkReal x1292=(sj6*x1285);
if((((0.789122722712073)+(((-0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz))))) < -0.00001)
continue;
IkReal x1293=IKsqrt(((0.789122722712073)+(((-0.544182706896435)*npz))+(((-0.351074831643425)*(npz*npz)))));
IkReal x1294=((0.0525)*x1293);
evalcond[0]=((0.028931250004359)+(((0.684999999976364)*npz))+(((2.31787030716724e-11)*x1289))+pp+(((-4.27467576791809e-12)*x1284)));
evalcond[1]=((-0.19033717108131)+(((-6.57894736842105)*pp))+(((-4.50657894721292)*npz))+(((-1.52491467576792e-10)*x1289))+(((2.8122866894198e-11)*x1284)));
evalcond[2]=((((-1.0)*x1284*x1290))+(((-1.0)*x1284*x1291))+(((-1.0)*x1287*x1292))+(((-0.076)*x1285))+((npx*x1288)));
evalcond[3]=(((x1285*x1286))+(((-1.0)*x1291))+(((-1.0)*x1290))+((x1285*x1294))+(((0.05704963168)*x1285)));
evalcond[4]=((-0.05704963168)+(((-1.0)*x1294))+((cj6*npx*x1284))+(((-1.0)*sj6*x1284*x1287))+((npx*x1292))+(((-1.0)*x1286))+(((-0.076)*x1284))+((npy*x1288)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x1295=(npx*sj6);
IkReal x1296=((0.0468730844709898)*sj3);
IkReal x1297=((0.657226962457338)*npz);
IkReal x1298=(cj6*npy);
IkReal x1299=((1.0)*pp);
IkReal x1300=(cj6*npx);
IkReal x1301=((0.0272354948805461)*npz);
IkReal x1302=(npy*sj6);
IkReal x1303=((0.0459658634812287)*sj3);
CheckValue<IkReal> x1304=IKPowWithIntegerCheck(((-0.00160421993174061)+(((-0.021108156996587)*x1302))+(((-0.00349340562457338)*sj3))+((x1300*x1303))+((x1300*x1301))+(((-1.0)*x1301*x1302))+(((-1.0)*x1302*x1303))+(((0.021108156996587)*x1300))+(((-0.0020698976109215)*npz))),-1);
if(!x1304.valid){
continue;
}
CheckValue<IkReal> x1305=IKPowWithIntegerCheck(((0.021108156996587)+x1301+x1303),-1);
if(!x1305.valid){
continue;
}
if( IKabs(((x1304.value)*((((x1296*x1298))+((x1295*x1296))+(((-1.0)*x1295*x1299))+(((-1.0)*x1295*x1297))+(((-0.00740648464163822)*x1295))+(((-0.00740648464163822)*x1298))+(((-1.0)*x1298*x1299))+(((-1.0)*x1297*x1298)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1305.value)*(((-0.00740648464163822)+x1296+(((-1.0)*x1299))+(((-1.0)*x1297)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1304.value)*((((x1296*x1298))+((x1295*x1296))+(((-1.0)*x1295*x1299))+(((-1.0)*x1295*x1297))+(((-0.00740648464163822)*x1295))+(((-0.00740648464163822)*x1298))+(((-1.0)*x1298*x1299))+(((-1.0)*x1297*x1298))))))+IKsqr(((x1305.value)*(((-0.00740648464163822)+x1296+(((-1.0)*x1299))+(((-1.0)*x1297))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x1304.value)*((((x1296*x1298))+((x1295*x1296))+(((-1.0)*x1295*x1299))+(((-1.0)*x1295*x1297))+(((-0.00740648464163822)*x1295))+(((-0.00740648464163822)*x1298))+(((-1.0)*x1298*x1299))+(((-1.0)*x1297*x1298))))), ((x1305.value)*(((-0.00740648464163822)+x1296+(((-1.0)*x1299))+(((-1.0)*x1297))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[5];
IkReal x1306=IKsin(j4);
IkReal x1307=IKcos(j4);
IkReal x1308=((0.293)*sj3);
IkReal x1309=((0.0525)*cj3);
IkReal x1310=((1.0)*npy);
IkReal x1311=((1.0)*npx*sj6);
IkReal x1312=(cj6*x1306);
IkReal x1313=(npz*x1307);
IkReal x1314=(cj6*x1310);
IkReal x1315=(sj3*x1307);
IkReal x1316=(sj6*x1306);
evalcond[0]=((((-0.0775)*x1306))+(((-1.0)*x1306*x1308))+(((-1.0)*x1306*x1309))+(((-1.0)*x1311))+(((-1.0)*x1314)));
evalcond[1]=((0.00740648464163822)+(((0.657226962457338)*npz))+(((0.0459658634812287)*x1315))+(((0.0272354948805461)*x1313))+(((-0.0468730844709898)*sj3))+pp+(((0.021108156996587)*x1307)));
evalcond[2]=((-0.0487268726423567)+(((-4.32386159511406)*npz))+(((-6.57894736842105)*pp))+(((-0.302406996587031)*x1315))+(((-0.179180887372014)*x1313))+(((0.308375555730196)*sj3))+(((-0.138869453924915)*x1307)));
evalcond[3]=(((npx*x1312))+(((-0.076)*x1306))+(((-1.0)*x1307*x1311))+(((-1.0)*x1307*x1314))+(((-1.0)*x1310*x1316)));
evalcond[4]=((0.0775)+x1308+x1309+((npx*x1316))+(((-0.076)*x1307))+((cj6*npx*x1307))+(((-1.0)*sj6*x1307*x1310))+((npy*x1312)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x1317=(npx*npy);
IkReal x1318=((0.293)*sj3);
IkReal x1319=(npx*sj6);
IkReal x1320=(cj6*npy);
IkReal x1321=((0.0525)*cj3);
IkReal x1322=(cj6*sj6);
CheckValue<IkReal> x1323=IKPowWithIntegerCheck(((-0.0775)+(((-1.0)*x1321))+(((-1.0)*x1318))),-1);
if(!x1323.valid){
continue;
}
CheckValue<IkReal> x1324=IKPowWithIntegerCheck((((x1318*x1319))+((x1320*x1321))+((x1319*x1321))+(((0.0775)*x1320))+(((0.0775)*x1319))+((x1318*x1320))),-1);
if(!x1324.valid){
continue;
}
if( IKabs(((x1323.value)*((x1319+x1320)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1324.value)*((x1317+(((-2.0)*x1317*(cj6*cj6)))+(((0.076)*x1319))+(((0.076)*x1320))+(((-1.0)*cj6*npx*x1319))+((npy*sj6*x1320)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1323.value)*((x1319+x1320))))+IKsqr(((x1324.value)*((x1317+(((-2.0)*x1317*(cj6*cj6)))+(((0.076)*x1319))+(((0.076)*x1320))+(((-1.0)*cj6*npx*x1319))+((npy*sj6*x1320))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x1323.value)*((x1319+x1320))), ((x1324.value)*((x1317+(((-2.0)*x1317*(cj6*cj6)))+(((0.076)*x1319))+(((0.076)*x1320))+(((-1.0)*cj6*npx*x1319))+((npy*sj6*x1320))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[5];
IkReal x1325=IKsin(j4);
IkReal x1326=IKcos(j4);
IkReal x1327=((0.293)*sj3);
IkReal x1328=((0.0525)*cj3);
IkReal x1329=((1.0)*npy);
IkReal x1330=((1.0)*npx*sj6);
IkReal x1331=(cj6*x1325);
IkReal x1332=(npz*x1326);
IkReal x1333=(cj6*x1329);
IkReal x1334=(sj3*x1326);
IkReal x1335=(sj6*x1325);
evalcond[0]=((((-0.0775)*x1325))+(((-1.0)*x1325*x1327))+(((-1.0)*x1325*x1328))+(((-1.0)*x1333))+(((-1.0)*x1330)));
evalcond[1]=((0.00740648464163822)+(((0.657226962457338)*npz))+(((0.021108156996587)*x1326))+(((-0.0468730844709898)*sj3))+pp+(((0.0272354948805461)*x1332))+(((0.0459658634812287)*x1334)));
evalcond[2]=((-0.0487268726423567)+(((-0.138869453924915)*x1326))+(((-0.302406996587031)*x1334))+(((-0.179180887372014)*x1332))+(((-4.32386159511406)*npz))+(((-6.57894736842105)*pp))+(((0.308375555730196)*sj3)));
evalcond[3]=((((-1.0)*x1326*x1330))+(((-1.0)*x1326*x1333))+(((-0.076)*x1325))+((npx*x1331))+(((-1.0)*x1329*x1335)));
evalcond[4]=((0.0775)+x1327+x1328+(((-0.076)*x1326))+((npx*x1335))+((npy*x1331))+((cj6*npx*x1326))+(((-1.0)*sj6*x1326*x1329)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x1336=IKPowWithIntegerCheck(((-0.0775)+(((-0.0525)*cj3))+(((-0.293)*sj3))),-1);
if(!x1336.valid){
continue;
}
CheckValue<IkReal> x1337=IKPowWithIntegerCheck(((0.021108156996587)+(((0.0459658634812287)*sj3))+(((0.0272354948805461)*npz))),-1);
if(!x1337.valid){
continue;
}
if( IKabs(((x1336.value)*((((cj6*npy))+((npx*sj6)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1337.value)*(((-0.00740648464163822)+(((0.0468730844709898)*sj3))+(((-0.657226962457338)*npz))+(((-1.0)*pp)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1336.value)*((((cj6*npy))+((npx*sj6))))))+IKsqr(((x1337.value)*(((-0.00740648464163822)+(((0.0468730844709898)*sj3))+(((-0.657226962457338)*npz))+(((-1.0)*pp))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x1336.value)*((((cj6*npy))+((npx*sj6))))), ((x1337.value)*(((-0.00740648464163822)+(((0.0468730844709898)*sj3))+(((-0.657226962457338)*npz))+(((-1.0)*pp))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[5];
IkReal x1338=IKsin(j4);
IkReal x1339=IKcos(j4);
IkReal x1340=((0.293)*sj3);
IkReal x1341=((0.0525)*cj3);
IkReal x1342=((1.0)*npy);
IkReal x1343=((1.0)*npx*sj6);
IkReal x1344=(cj6*x1338);
IkReal x1345=(npz*x1339);
IkReal x1346=(cj6*x1342);
IkReal x1347=(sj3*x1339);
IkReal x1348=(sj6*x1338);
evalcond[0]=((((-1.0)*x1338*x1341))+(((-1.0)*x1338*x1340))+(((-1.0)*x1343))+(((-1.0)*x1346))+(((-0.0775)*x1338)));
evalcond[1]=((0.00740648464163822)+(((0.657226962457338)*npz))+(((0.0459658634812287)*x1347))+(((-0.0468730844709898)*sj3))+(((0.0272354948805461)*x1345))+pp+(((0.021108156996587)*x1339)));
evalcond[2]=((-0.0487268726423567)+(((-0.138869453924915)*x1339))+(((-4.32386159511406)*npz))+(((-6.57894736842105)*pp))+(((-0.302406996587031)*x1347))+(((-0.179180887372014)*x1345))+(((0.308375555730196)*sj3)));
evalcond[3]=((((-1.0)*x1339*x1343))+(((-1.0)*x1339*x1346))+(((-0.076)*x1338))+(((-1.0)*x1342*x1348))+((npx*x1344)));
evalcond[4]=((0.0775)+x1340+x1341+((npy*x1344))+(((-1.0)*sj6*x1339*x1342))+((cj6*npx*x1339))+(((-0.076)*x1339))+((npx*x1348)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x1349=(cj5*npy);
IkReal x1350=(cj6*npy);
IkReal x1351=(npx*sj6);
IkReal x1352=((0.293)*sj3);
IkReal x1353=((0.0525)*cj3);
IkReal x1354=((1.0)*npz*sj5);
IkReal x1355=(cj5*cj6*sj6);
CheckValue<IkReal> x1356=IKPowWithIntegerCheck(((-0.0775)+(((-1.0)*x1352))+(((-1.0)*x1353))),-1);
if(!x1356.valid){
continue;
}
CheckValue<IkReal> x1357=IKPowWithIntegerCheck(((((0.0775)*x1351))+(((0.0775)*x1350))+((x1350*x1352))+((x1350*x1353))+((x1351*x1352))+((x1351*x1353))),-1);
if(!x1357.valid){
continue;
}
if( IKabs(((x1356.value)*((x1351+x1350)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1357.value)*(((((-0.076)*cj6*x1349))+(((-1.0)*x1350*x1354))+(((2.0)*npx*x1349*(cj6*cj6)))+(((-0.076)*cj5*x1351))+((cj5*cj6*npx*x1351))+(((-1.0)*sj6*x1349*x1350))+(((-1.0)*x1351*x1354))+(((-1.0)*npx*x1349)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1356.value)*((x1351+x1350))))+IKsqr(((x1357.value)*(((((-0.076)*cj6*x1349))+(((-1.0)*x1350*x1354))+(((2.0)*npx*x1349*(cj6*cj6)))+(((-0.076)*cj5*x1351))+((cj5*cj6*npx*x1351))+(((-1.0)*sj6*x1349*x1350))+(((-1.0)*x1351*x1354))+(((-1.0)*npx*x1349))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x1356.value)*((x1351+x1350))), ((x1357.value)*(((((-0.076)*cj6*x1349))+(((-1.0)*x1350*x1354))+(((2.0)*npx*x1349*(cj6*cj6)))+(((-0.076)*cj5*x1351))+((cj5*cj6*npx*x1351))+(((-1.0)*sj6*x1349*x1350))+(((-1.0)*x1351*x1354))+(((-1.0)*npx*x1349))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x1358=IKsin(j4);
IkReal x1359=IKcos(j4);
IkReal x1360=((0.293)*sj3);
IkReal x1361=(npy*sj6);
IkReal x1362=(cj6*npy);
IkReal x1363=((0.293)*cj3);
IkReal x1364=((0.0525)*sj3);
IkReal x1365=((0.0525)*cj3);
IkReal x1366=(cj5*x1359);
IkReal x1367=((1.0)*npx*sj6);
IkReal x1368=((1.0)*cj6*npx);
IkReal x1369=(sj5*x1359);
IkReal x1370=(cj5*x1358);
evalcond[0]=((((-1.0)*x1362))+(((-0.0775)*x1358))+(((-1.0)*x1367))+(((-1.0)*x1358*x1365))+(((-1.0)*x1358*x1360)));
evalcond[1]=((((-0.0775)*x1369))+(((0.3425)*cj5))+(((-1.0)*npz))+((cj5*x1364))+(((-1.0)*x1365*x1369))+(((-1.0)*cj5*x1363))+(((-1.0)*x1360*x1369)));
evalcond[2]=((0.076)+x1361+((x1360*x1366))+(((-1.0)*sj5*x1363))+((x1365*x1366))+(((0.0775)*x1366))+(((0.3425)*sj5))+((sj5*x1364))+(((-1.0)*x1368)));
evalcond[3]=((-0.21769375)+(((-0.05206)*sj5))+(((0.1925675)*cj3))+(((-0.00798)*sj3*sj5))+(((-0.044536)*sj3*x1366))+pp+(((-0.00798)*cj3*x1366))+(((-0.0813775)*sj3))+(((0.044536)*cj3*sj5))+(((-0.01178)*x1366)));
evalcond[4]=((((0.076)*x1370))+(((-1.0)*x1359*x1367))+(((-1.0)*x1359*x1362))+((npz*sj5*x1358))+(((-1.0)*x1368*x1370))+((x1361*x1370)));
evalcond[5]=((0.0775)+((npz*x1369))+(((-1.0)*x1366*x1368))+x1365+x1360+(((0.076)*x1366))+((x1361*x1366))+((x1358*x1362))+((npx*sj6*x1358)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x1371=((0.0525)*cj3);
IkReal x1372=((0.293)*sj3);
CheckValue<IkReal> x1373=IKPowWithIntegerCheck(((-0.0775)+(((-1.0)*x1372))+(((-1.0)*x1371))),-1);
if(!x1373.valid){
continue;
}
CheckValue<IkReal> x1374=IKPowWithIntegerCheck((((cj5*x1371))+((cj5*x1372))+(((0.0775)*cj5))),-1);
if(!x1374.valid){
continue;
}
if( IKabs(((x1373.value)*((((cj6*npy))+((npx*sj6)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1374.value)*(((-0.076)+((cj6*npx))+(((-0.3425)*sj5))+(((-0.0525)*sj3*sj5))+(((0.293)*cj3*sj5))+(((-1.0)*npy*sj6)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1373.value)*((((cj6*npy))+((npx*sj6))))))+IKsqr(((x1374.value)*(((-0.076)+((cj6*npx))+(((-0.3425)*sj5))+(((-0.0525)*sj3*sj5))+(((0.293)*cj3*sj5))+(((-1.0)*npy*sj6))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x1373.value)*((((cj6*npy))+((npx*sj6))))), ((x1374.value)*(((-0.076)+((cj6*npx))+(((-0.3425)*sj5))+(((-0.0525)*sj3*sj5))+(((0.293)*cj3*sj5))+(((-1.0)*npy*sj6))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x1375=IKsin(j4);
IkReal x1376=IKcos(j4);
IkReal x1377=((0.293)*sj3);
IkReal x1378=(npy*sj6);
IkReal x1379=(cj6*npy);
IkReal x1380=((0.293)*cj3);
IkReal x1381=((0.0525)*sj3);
IkReal x1382=((0.0525)*cj3);
IkReal x1383=(cj5*x1376);
IkReal x1384=((1.0)*npx*sj6);
IkReal x1385=((1.0)*cj6*npx);
IkReal x1386=(sj5*x1376);
IkReal x1387=(cj5*x1375);
evalcond[0]=((((-1.0)*x1384))+(((-0.0775)*x1375))+(((-1.0)*x1375*x1382))+(((-1.0)*x1379))+(((-1.0)*x1375*x1377)));
evalcond[1]=((((0.3425)*cj5))+(((-1.0)*cj5*x1380))+(((-1.0)*x1377*x1386))+(((-1.0)*x1382*x1386))+(((-1.0)*npz))+((cj5*x1381))+(((-0.0775)*x1386)));
evalcond[2]=((0.076)+(((-1.0)*x1385))+x1378+(((-1.0)*sj5*x1380))+(((0.0775)*x1383))+(((0.3425)*sj5))+((x1377*x1383))+((sj5*x1381))+((x1382*x1383)));
evalcond[3]=((-0.21769375)+(((-0.05206)*sj5))+(((-0.00798)*cj3*x1383))+(((0.1925675)*cj3))+(((-0.00798)*sj3*sj5))+(((-0.01178)*x1383))+(((-0.044536)*sj3*x1383))+pp+(((-0.0813775)*sj3))+(((0.044536)*cj3*sj5)));
evalcond[4]=(((npz*sj5*x1375))+(((-1.0)*x1376*x1379))+(((-1.0)*x1376*x1384))+(((0.076)*x1387))+((x1378*x1387))+(((-1.0)*x1385*x1387)));
evalcond[5]=((0.0775)+((npz*x1386))+x1377+x1382+(((-1.0)*x1383*x1385))+((x1375*x1379))+((npx*sj6*x1375))+(((0.076)*x1383))+((x1378*x1383)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x1388=((0.293)*sj3);
IkReal x1389=((0.0525)*cj3);
CheckValue<IkReal> x1390=IKPowWithIntegerCheck(((-0.0775)+(((-1.0)*x1389))+(((-1.0)*x1388))),-1);
if(!x1390.valid){
continue;
}
CheckValue<IkReal> x1391=IKPowWithIntegerCheck(((((-1.0)*sj5*x1388))+(((-1.0)*sj5*x1389))+(((-0.0775)*sj5))),-1);
if(!x1391.valid){
continue;
}
if( IKabs(((x1390.value)*((((cj6*npy))+((npx*sj6)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1391.value)*((npz+(((-0.3425)*cj5))+(((0.293)*cj3*cj5))+(((-0.0525)*cj5*sj3)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1390.value)*((((cj6*npy))+((npx*sj6))))))+IKsqr(((x1391.value)*((npz+(((-0.3425)*cj5))+(((0.293)*cj3*cj5))+(((-0.0525)*cj5*sj3))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x1390.value)*((((cj6*npy))+((npx*sj6))))), ((x1391.value)*((npz+(((-0.3425)*cj5))+(((0.293)*cj3*cj5))+(((-0.0525)*cj5*sj3))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x1392=IKsin(j4);
IkReal x1393=IKcos(j4);
IkReal x1394=((0.293)*sj3);
IkReal x1395=(npy*sj6);
IkReal x1396=(cj6*npy);
IkReal x1397=((0.293)*cj3);
IkReal x1398=((0.0525)*sj3);
IkReal x1399=((0.0525)*cj3);
IkReal x1400=(cj5*x1393);
IkReal x1401=((1.0)*npx*sj6);
IkReal x1402=((1.0)*cj6*npx);
IkReal x1403=(sj5*x1393);
IkReal x1404=(cj5*x1392);
evalcond[0]=((((-1.0)*x1392*x1399))+(((-1.0)*x1392*x1394))+(((-1.0)*x1401))+(((-1.0)*x1396))+(((-0.0775)*x1392)));
evalcond[1]=((((0.3425)*cj5))+(((-0.0775)*x1403))+(((-1.0)*x1399*x1403))+(((-1.0)*cj5*x1397))+(((-1.0)*npz))+((cj5*x1398))+(((-1.0)*x1394*x1403)));
evalcond[2]=((0.076)+x1395+(((-1.0)*sj5*x1397))+(((-1.0)*x1402))+((x1394*x1400))+((x1399*x1400))+(((0.3425)*sj5))+((sj5*x1398))+(((0.0775)*x1400)));
evalcond[3]=((-0.21769375)+(((-0.05206)*sj5))+(((-0.01178)*x1400))+(((0.1925675)*cj3))+(((-0.00798)*sj3*sj5))+pp+(((-0.00798)*cj3*x1400))+(((-0.044536)*sj3*x1400))+(((-0.0813775)*sj3))+(((0.044536)*cj3*sj5)));
evalcond[4]=((((0.076)*x1404))+((npz*sj5*x1392))+((x1395*x1404))+(((-1.0)*x1393*x1401))+(((-1.0)*x1402*x1404))+(((-1.0)*x1393*x1396)));
evalcond[5]=((0.0775)+(((0.076)*x1400))+x1399+x1394+((npx*sj6*x1392))+((x1395*x1400))+((npz*x1403))+(((-1.0)*x1400*x1402))+((x1392*x1396)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}
    }
}
return solutions.GetNumSolutions()>0;
}
inline void rotationfunction0(IkSolutionListBase<IkReal>& solutions) {
for(int rotationiter = 0; rotationiter < 1; ++rotationiter) {
IkReal x179=((1.0)*sj4);
IkReal x180=((1.0)*sj5);
IkReal x181=((1.0)*sj3);
IkReal x182=((1.0)*cj5);
IkReal x183=((1.0)*cj4);
IkReal x184=((1.0)*sj6);
IkReal x185=((-1.0)*sj4);
IkReal x186=((-1.0)*sj5);
IkReal x187=((-1.0)*cj5);
IkReal x188=((((-1.0)*r01*x184))+((cj6*r00)));
IkReal x189=(((r00*sj6))+((cj6*r01)));
IkReal x190=((((-1.0)*r11*x184))+((cj6*r10)));
IkReal x191=(((r10*sj6))+((cj6*r11)));
IkReal x192=(((cj6*r20))+(((-1.0)*r21*x184)));
IkReal x193=(((cj6*r21))+((r20*sj6)));
IkReal x194=(cj5*x188);
IkReal x195=(cj5*x190);
IkReal x196=(cj5*x192);
IkReal x197=((((-1.0)*r02*x180))+x194);
IkReal x198=((((-1.0)*r12*x180))+x195);
IkReal x199=((((-1.0)*r22*x180))+x196);
new_r00=(((cj3*((((cj4*x197))+(((-1.0)*x179*x189))))))+(((-1.0)*x181*((((x186*x188))+((r02*x187)))))));
new_r01=((((-1.0)*x183*x189))+(((-1.0)*x179*x197)));
new_r02=(((cj3*(((((-1.0)*r02*x182))+(((-1.0)*x180*x188))))))+((sj3*((((x185*x189))+((cj4*((x194+((r02*x186)))))))))));
new_r10=((((-1.0)*x181*((((x186*x190))+((r12*x187))))))+((cj3*((((cj4*x198))+(((-1.0)*x179*x191)))))));
new_r11=((((-1.0)*x179*x198))+(((-1.0)*x183*x191)));
new_r12=(((sj3*((((cj4*((x195+((r12*x186))))))+((x185*x191))))))+((cj3*(((((-1.0)*r12*x182))+(((-1.0)*x180*x190)))))));
new_r20=((((-1.0)*x181*(((((-1.0)*r22*x182))+(((-1.0)*x180*x192))))))+((cj3*((((x185*x193))+((cj4*((x196+((r22*x186)))))))))));
new_r21=((((-1.0)*x179*x199))+(((-1.0)*x183*x193)));
new_r22=(((cj3*((((x186*x192))+((r22*x187))))))+((sj3*((((cj4*x199))+(((-1.0)*x179*x193)))))));
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
cj1array[0]=new_r22;
if( cj1array[0] >= -1-IKFAST_SINCOS_THRESH && cj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKacos(cj1array[0]);
    sj1array[0] = IKsin(j1array[0]);
    cj1array[1] = cj1array[0];
    j1array[1] = -j1array[0];
    sj1array[1] = -sj1array[0];
}
else if( isnan(cj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

{
IkReal j0eval[3];
j0eval[0]=sj1;
j0eval[1]=((IKabs(new_r12))+(IKabs(new_r02)));
j0eval[2]=IKsign(sj1);
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[3];
j2eval[0]=sj1;
j2eval[1]=IKsign(sj1);
j2eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[2];
j0eval[0]=new_r12;
j0eval[1]=sj1;
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j1))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
IkReal j2mul = 1;
j2=0;
j0mul=-1.0;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0=IKatan2(((-1.0)*new_r01), new_r00);
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].fmul = j0mul;
vinfos[0].freeind = 0;
vinfos[0].maxsolutions = 0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].fmul = j2mul;
vinfos[2].freeind = 0;
vinfos[2].maxsolutions = 0;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(1);
vfree[0] = 2;
solutions.AddSolution(vinfos,vfree);
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j1)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
IkReal j2mul = 1;
j2=0;
j0mul=1.0;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(((-1.0)*new_r00))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0=IKatan2(((-1.0)*new_r01), ((-1.0)*new_r00));
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].fmul = j0mul;
vinfos[0].freeind = 0;
vinfos[0].maxsolutions = 0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].fmul = j2mul;
vinfos[2].freeind = 0;
vinfos[2].maxsolutions = 0;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(1);
vfree[0] = 2;
solutions.AddSolution(vinfos,vfree);
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r12))+(IKabs(new_r02)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
IkReal x200=new_r22*new_r22;
IkReal x201=((16.0)*new_r10);
IkReal x202=((16.0)*new_r01);
IkReal x203=((16.0)*new_r22);
IkReal x204=((8.0)*new_r11);
IkReal x205=((8.0)*new_r00);
IkReal x206=(x200*x201);
IkReal x207=(x200*x202);
j0eval[0]=((IKabs(((((-1.0)*x205))+((new_r22*x204)))))+(IKabs((((new_r11*x203))+(((-32.0)*new_r00*x200))+(((16.0)*new_r00)))))+(IKabs(((((-1.0)*x206))+x201)))+(IKabs(((((-1.0)*new_r22*x205))+((x200*x204)))))+(IKabs(((((-1.0)*new_r00*x203))+(((32.0)*new_r11))+(((-16.0)*new_r11*x200)))))+(IKabs(((((-1.0)*x207))+x202)))+(IKabs(((((-1.0)*x201))+x206)))+(IKabs(((((-1.0)*x202))+x207))));
if( IKabs(j0eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j0, j2]

} else
{
IkReal op[4+1], zeror[4];
int numroots;
IkReal j0evalpoly[1];
IkReal x208=new_r22*new_r22;
IkReal x209=((16.0)*new_r10);
IkReal x210=(new_r11*new_r22);
IkReal x211=(x208*x209);
IkReal x212=((((8.0)*x210))+(((-8.0)*new_r00)));
op[0]=x212;
op[1]=(x209+(((-1.0)*x211)));
op[2]=((((16.0)*x210))+(((-32.0)*new_r00*x208))+(((16.0)*new_r00)));
op[3]=((((-1.0)*x209))+x211);
op[4]=x212;
polyroots4(op,zeror,numroots);
IkReal j0array[4], cj0array[4], sj0array[4], tempj0array[1];
int numsolutions = 0;
for(int ij0 = 0; ij0 < numroots; ++ij0)
{
IkReal htj0 = zeror[ij0];
tempj0array[0]=((2.0)*(atan(htj0)));
for(int kj0 = 0; kj0 < 1; ++kj0)
{
j0array[numsolutions] = tempj0array[kj0];
if( j0array[numsolutions] > IKPI )
{
    j0array[numsolutions]-=IK2PI;
}
else if( j0array[numsolutions] < -IKPI )
{
    j0array[numsolutions]+=IK2PI;
}
sj0array[numsolutions] = IKsin(j0array[numsolutions]);
cj0array[numsolutions] = IKcos(j0array[numsolutions]);
numsolutions++;
}
}
bool j0valid[4]={true,true,true,true};
_nj0 = 4;
for(int ij0 = 0; ij0 < numsolutions; ++ij0)
    {
if( !j0valid[ij0] )
{
    continue;
}
    j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
htj0 = IKtan(j0/2);

IkReal x213=((16.0)*new_r01);
IkReal x214=new_r22*new_r22;
IkReal x215=(new_r00*new_r22);
IkReal x216=((8.0)*x215);
IkReal x217=(new_r11*x214);
IkReal x218=(x213*x214);
IkReal x219=((8.0)*x217);
j0evalpoly[0]=(((htj0*((x213+(((-1.0)*x218))))))+(((htj0*htj0*htj0)*((x218+(((-1.0)*x213))))))+(((htj0*htj0*htj0*htj0)*((x219+(((-1.0)*x216))))))+x219+(((-1.0)*x216))+(((htj0*htj0)*(((((32.0)*new_r11))+(((-16.0)*x217))+(((-16.0)*x215)))))));
if( IKabs(j0evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < numsolutions; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
{
IkReal j2eval[3];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
IkReal x220=cj0*cj0;
IkReal x221=(cj0*new_r22);
IkReal x222=((-1.0)+(((-1.0)*x220*(new_r22*new_r22)))+x220);
j2eval[0]=x222;
j2eval[1]=IKsign(x222);
j2eval[2]=((IKabs((((new_r01*sj0))+(((-1.0)*new_r00*x221)))))+(IKabs((((new_r01*x221))+((new_r00*sj0))))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j2eval[0]=new_r22;
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
IkReal x223=new_r22*new_r22;
j2eval[0]=(((cj0*x223))+(((-1.0)*cj0)));
j2eval[1]=((((-1.0)*sj0))+((sj0*x223)));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j0)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x224=IKsin(j2);
IkReal x225=IKcos(j2);
evalcond[0]=x224;
evalcond[1]=((-1.0)*x225);
evalcond[2]=((((-1.0)*new_r00))+(((-1.0)*x224)));
evalcond[3]=((((-1.0)*new_r01))+(((-1.0)*x225)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j0)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(new_r00, new_r01);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x226=IKsin(j2);
IkReal x227=IKcos(j2);
evalcond[0]=x226;
evalcond[1]=((-1.0)*x227);
evalcond[2]=(new_r00+(((-1.0)*x226)));
evalcond[3]=(new_r01+(((-1.0)*x227)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j0))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(new_r10, new_r11);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x228=IKsin(j2);
IkReal x229=IKcos(j2);
evalcond[0]=x228;
evalcond[1]=((-1.0)*x229);
evalcond[2]=(new_r10+(((-1.0)*x228)));
evalcond[3]=(new_r11+(((-1.0)*x229)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j0)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r11));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x230=IKsin(j2);
IkReal x231=IKcos(j2);
evalcond[0]=x230;
evalcond[1]=((-1.0)*x231);
evalcond[2]=((((-1.0)*new_r10))+(((-1.0)*x230)));
evalcond[3]=((((-1.0)*new_r11))+(((-1.0)*x231)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
CheckValue<IkReal> x232=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x232.valid){
continue;
}
if((x232.value) < -0.00001)
continue;
IkReal gconst40=((-1.0)*(IKsqrt(x232.value)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst40))+cj0)))+(IKabs(((-1.0)+(IKsign(sj0)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
if((((1.0)+(((-1.0)*(gconst40*gconst40))))) < -0.00001)
continue;
sj0=IKsqrt(((1.0)+(((-1.0)*(gconst40*gconst40)))));
cj0=gconst40;
if( (gconst40) < -1-IKFAST_SINCOS_THRESH || (gconst40) > 1+IKFAST_SINCOS_THRESH )
    continue;
j0=IKacos(gconst40);
CheckValue<IkReal> x233=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x233.valid){
continue;
}
if((x233.value) < -0.00001)
continue;
IkReal gconst40=((-1.0)*(IKsqrt(x233.value)));
j2eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if((((1.0)+(((-1.0)*(gconst40*gconst40))))) < -0.00001)
continue;
CheckValue<IkReal> x234=IKPowWithIntegerCheck(gconst40,-1);
if(!x234.valid){
continue;
}
if( IKabs(((((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst40*gconst40))))))))+((gconst40*new_r10)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r11*(x234.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst40*gconst40))))))))+((gconst40*new_r10))))+IKsqr((new_r11*(x234.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst40*gconst40))))))))+((gconst40*new_r10))), (new_r11*(x234.value)));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x235=IKcos(j2);
IkReal x236=IKsin(j2);
IkReal x237=((1.0)*gconst40);
if((((1.0)+(((-1.0)*gconst40*x237)))) < -0.00001)
continue;
IkReal x238=IKsqrt(((1.0)+(((-1.0)*gconst40*x237))));
IkReal x239=((1.0)*x238);
evalcond[0]=x236;
evalcond[1]=((-1.0)*x235);
evalcond[2]=((((-1.0)*x235*x237))+new_r11);
evalcond[3]=((((-1.0)*x236*x237))+new_r10);
evalcond[4]=(((x235*x238))+new_r01);
evalcond[5]=(new_r00+((x236*x238)));
evalcond[6]=(((gconst40*new_r10))+(((-1.0)*x236))+(((-1.0)*new_r00*x239)));
evalcond[7]=(((gconst40*new_r11))+(((-1.0)*new_r01*x239))+(((-1.0)*x235)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x240=IKPowWithIntegerCheck(IKsign(gconst40),-1);
if(!x240.valid){
continue;
}
CheckValue<IkReal> x241 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x241.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x240.value)))+(x241.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x242=IKcos(j2);
IkReal x243=IKsin(j2);
IkReal x244=((1.0)*gconst40);
if((((1.0)+(((-1.0)*gconst40*x244)))) < -0.00001)
continue;
IkReal x245=IKsqrt(((1.0)+(((-1.0)*gconst40*x244))));
IkReal x246=((1.0)*x245);
evalcond[0]=x243;
evalcond[1]=((-1.0)*x242);
evalcond[2]=((((-1.0)*x242*x244))+new_r11);
evalcond[3]=((((-1.0)*x243*x244))+new_r10);
evalcond[4]=(((x242*x245))+new_r01);
evalcond[5]=(new_r00+((x243*x245)));
evalcond[6]=((((-1.0)*x243))+((gconst40*new_r10))+(((-1.0)*new_r00*x246)));
evalcond[7]=((((-1.0)*new_r01*x246))+(((-1.0)*x242))+((gconst40*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
CheckValue<IkReal> x247=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x247.valid){
continue;
}
if((x247.value) < -0.00001)
continue;
IkReal gconst40=((-1.0)*(IKsqrt(x247.value)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.0)+(IKsign(sj0)))))+(IKabs(((((-1.0)*gconst40))+cj0)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
if((((1.0)+(((-1.0)*(gconst40*gconst40))))) < -0.00001)
continue;
sj0=((-1.0)*(IKsqrt(((1.0)+(((-1.0)*(gconst40*gconst40)))))));
cj0=gconst40;
if( (gconst40) < -1-IKFAST_SINCOS_THRESH || (gconst40) > 1+IKFAST_SINCOS_THRESH )
    continue;
j0=((-1.0)*(IKacos(gconst40)));
CheckValue<IkReal> x248=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x248.valid){
continue;
}
if((x248.value) < -0.00001)
continue;
IkReal gconst40=((-1.0)*(IKsqrt(x248.value)));
j2eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if((((1.0)+(((-1.0)*(gconst40*gconst40))))) < -0.00001)
continue;
CheckValue<IkReal> x249=IKPowWithIntegerCheck(gconst40,-1);
if(!x249.valid){
continue;
}
if( IKabs((((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst40*gconst40))))))))+((gconst40*new_r10)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r11*(x249.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst40*gconst40))))))))+((gconst40*new_r10))))+IKsqr((new_r11*(x249.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst40*gconst40))))))))+((gconst40*new_r10))), (new_r11*(x249.value)));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x250=IKcos(j2);
IkReal x251=IKsin(j2);
IkReal x252=((1.0)*x250);
IkReal x253=((1.0)*x251);
if((((1.0)+(((-1.0)*(gconst40*gconst40))))) < -0.00001)
continue;
IkReal x254=IKsqrt(((1.0)+(((-1.0)*(gconst40*gconst40)))));
IkReal x255=((1.0)*x254);
evalcond[0]=x251;
evalcond[1]=((-1.0)*x250);
evalcond[2]=((((-1.0)*gconst40*x252))+new_r11);
evalcond[3]=((((-1.0)*gconst40*x253))+new_r10);
evalcond[4]=((((-1.0)*x252*x254))+new_r01);
evalcond[5]=(new_r00+(((-1.0)*x253*x254)));
evalcond[6]=(((new_r00*x254))+((gconst40*new_r10))+(((-1.0)*x253)));
evalcond[7]=(((new_r01*x254))+((gconst40*new_r11))+(((-1.0)*x252)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x256=IKPowWithIntegerCheck(IKsign(gconst40),-1);
if(!x256.valid){
continue;
}
CheckValue<IkReal> x257 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x257.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x256.value)))+(x257.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x258=IKcos(j2);
IkReal x259=IKsin(j2);
IkReal x260=((1.0)*x258);
IkReal x261=((1.0)*x259);
if((((1.0)+(((-1.0)*(gconst40*gconst40))))) < -0.00001)
continue;
IkReal x262=IKsqrt(((1.0)+(((-1.0)*(gconst40*gconst40)))));
IkReal x263=((1.0)*x262);
evalcond[0]=x259;
evalcond[1]=((-1.0)*x258);
evalcond[2]=((((-1.0)*gconst40*x260))+new_r11);
evalcond[3]=((((-1.0)*gconst40*x261))+new_r10);
evalcond[4]=(new_r01+(((-1.0)*x260*x262)));
evalcond[5]=((((-1.0)*x261*x262))+new_r00);
evalcond[6]=(((gconst40*new_r10))+((new_r00*x262))+(((-1.0)*x261)));
evalcond[7]=(((gconst40*new_r11))+((new_r01*x262))+(((-1.0)*x260)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
CheckValue<IkReal> x264=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x264.valid){
continue;
}
if((x264.value) < -0.00001)
continue;
IkReal gconst41=IKsqrt(x264.value);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.0)+(IKsign(sj0)))))+(IKabs(((((-1.0)*gconst41))+cj0)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
if((((1.0)+(((-1.0)*(gconst41*gconst41))))) < -0.00001)
continue;
sj0=IKsqrt(((1.0)+(((-1.0)*(gconst41*gconst41)))));
cj0=gconst41;
if( (gconst41) < -1-IKFAST_SINCOS_THRESH || (gconst41) > 1+IKFAST_SINCOS_THRESH )
    continue;
j0=IKacos(gconst41);
CheckValue<IkReal> x265=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x265.valid){
continue;
}
if((x265.value) < -0.00001)
continue;
IkReal gconst41=IKsqrt(x265.value);
j2eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if((((1.0)+(((-1.0)*(gconst41*gconst41))))) < -0.00001)
continue;
CheckValue<IkReal> x266=IKPowWithIntegerCheck(gconst41,-1);
if(!x266.valid){
continue;
}
if( IKabs(((((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst41*gconst41))))))))+((gconst41*new_r10)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r11*(x266.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst41*gconst41))))))))+((gconst41*new_r10))))+IKsqr((new_r11*(x266.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst41*gconst41))))))))+((gconst41*new_r10))), (new_r11*(x266.value)));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x267=IKcos(j2);
IkReal x268=IKsin(j2);
IkReal x269=((1.0)*gconst41);
if((((1.0)+(((-1.0)*gconst41*x269)))) < -0.00001)
continue;
IkReal x270=IKsqrt(((1.0)+(((-1.0)*gconst41*x269))));
IkReal x271=((1.0)*x270);
evalcond[0]=x268;
evalcond[1]=((-1.0)*x267);
evalcond[2]=((((-1.0)*x267*x269))+new_r11);
evalcond[3]=((((-1.0)*x268*x269))+new_r10);
evalcond[4]=(new_r01+((x267*x270)));
evalcond[5]=(new_r00+((x268*x270)));
evalcond[6]=((((-1.0)*x268))+((gconst41*new_r10))+(((-1.0)*new_r00*x271)));
evalcond[7]=((((-1.0)*x267))+((gconst41*new_r11))+(((-1.0)*new_r01*x271)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x272=IKPowWithIntegerCheck(IKsign(gconst41),-1);
if(!x272.valid){
continue;
}
CheckValue<IkReal> x273 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x273.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x272.value)))+(x273.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x274=IKcos(j2);
IkReal x275=IKsin(j2);
IkReal x276=((1.0)*gconst41);
if((((1.0)+(((-1.0)*gconst41*x276)))) < -0.00001)
continue;
IkReal x277=IKsqrt(((1.0)+(((-1.0)*gconst41*x276))));
IkReal x278=((1.0)*x277);
evalcond[0]=x275;
evalcond[1]=((-1.0)*x274);
evalcond[2]=((((-1.0)*x274*x276))+new_r11);
evalcond[3]=((((-1.0)*x275*x276))+new_r10);
evalcond[4]=(((x274*x277))+new_r01);
evalcond[5]=(((x275*x277))+new_r00);
evalcond[6]=(((gconst41*new_r10))+(((-1.0)*x275))+(((-1.0)*new_r00*x278)));
evalcond[7]=(((gconst41*new_r11))+(((-1.0)*new_r01*x278))+(((-1.0)*x274)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
CheckValue<IkReal> x279=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x279.valid){
continue;
}
if((x279.value) < -0.00001)
continue;
IkReal gconst41=IKsqrt(x279.value);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.0)+(IKsign(sj0)))))+(IKabs(((((-1.0)*gconst41))+cj0)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
if((((1.0)+(((-1.0)*(gconst41*gconst41))))) < -0.00001)
continue;
sj0=((-1.0)*(IKsqrt(((1.0)+(((-1.0)*(gconst41*gconst41)))))));
cj0=gconst41;
if( (gconst41) < -1-IKFAST_SINCOS_THRESH || (gconst41) > 1+IKFAST_SINCOS_THRESH )
    continue;
j0=((-1.0)*(IKacos(gconst41)));
CheckValue<IkReal> x280=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x280.valid){
continue;
}
if((x280.value) < -0.00001)
continue;
IkReal gconst41=IKsqrt(x280.value);
j2eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if((((1.0)+(((-1.0)*(gconst41*gconst41))))) < -0.00001)
continue;
CheckValue<IkReal> x281=IKPowWithIntegerCheck(gconst41,-1);
if(!x281.valid){
continue;
}
if( IKabs((((gconst41*new_r10))+((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst41*gconst41)))))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r11*(x281.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((gconst41*new_r10))+((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst41*gconst41))))))))))+IKsqr((new_r11*(x281.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((((gconst41*new_r10))+((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst41*gconst41))))))))), (new_r11*(x281.value)));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x282=IKcos(j2);
IkReal x283=IKsin(j2);
IkReal x284=((1.0)*gconst41);
IkReal x285=((1.0)*x282);
IkReal x286=((1.0)*x283);
if((((1.0)+(((-1.0)*gconst41*x284)))) < -0.00001)
continue;
IkReal x287=IKsqrt(((1.0)+(((-1.0)*gconst41*x284))));
evalcond[0]=x283;
evalcond[1]=((-1.0)*x282);
evalcond[2]=((((-1.0)*x282*x284))+new_r11);
evalcond[3]=(new_r10+(((-1.0)*x283*x284)));
evalcond[4]=((((-1.0)*x285*x287))+new_r01);
evalcond[5]=(new_r00+(((-1.0)*x286*x287)));
evalcond[6]=(((gconst41*new_r10))+(((-1.0)*x286))+((new_r00*x287)));
evalcond[7]=(((gconst41*new_r11))+(((-1.0)*x285))+((new_r01*x287)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x288=IKPowWithIntegerCheck(IKsign(gconst41),-1);
if(!x288.valid){
continue;
}
CheckValue<IkReal> x289 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x289.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x288.value)))+(x289.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x290=IKcos(j2);
IkReal x291=IKsin(j2);
IkReal x292=((1.0)*gconst41);
IkReal x293=((1.0)*x290);
IkReal x294=((1.0)*x291);
if((((1.0)+(((-1.0)*gconst41*x292)))) < -0.00001)
continue;
IkReal x295=IKsqrt(((1.0)+(((-1.0)*gconst41*x292))));
evalcond[0]=x291;
evalcond[1]=((-1.0)*x290);
evalcond[2]=((((-1.0)*x290*x292))+new_r11);
evalcond[3]=((((-1.0)*x291*x292))+new_r10);
evalcond[4]=((((-1.0)*x293*x295))+new_r01);
evalcond[5]=(new_r00+(((-1.0)*x294*x295)));
evalcond[6]=(((gconst41*new_r10))+(((-1.0)*x294))+((new_r00*x295)));
evalcond[7]=(((gconst41*new_r11))+(((-1.0)*x293))+((new_r01*x295)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j2]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x296=new_r22*new_r22;
CheckValue<IkReal> x297=IKPowWithIntegerCheck((((cj0*x296))+(((-1.0)*cj0))),-1);
if(!x297.valid){
continue;
}
CheckValue<IkReal> x298=IKPowWithIntegerCheck(((((-1.0)*sj0))+((sj0*x296))),-1);
if(!x298.valid){
continue;
}
if( IKabs(((x297.value)*(((((-1.0)*new_r01*new_r22))+(((-1.0)*new_r10)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x298.value)*((((new_r10*new_r22))+new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x297.value)*(((((-1.0)*new_r01*new_r22))+(((-1.0)*new_r10))))))+IKsqr(((x298.value)*((((new_r10*new_r22))+new_r01))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((x297.value)*(((((-1.0)*new_r01*new_r22))+(((-1.0)*new_r10))))), ((x298.value)*((((new_r10*new_r22))+new_r01))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[10];
IkReal x299=IKsin(j2);
IkReal x300=IKcos(j2);
IkReal x301=(cj0*new_r22);
IkReal x302=(new_r22*sj0);
IkReal x303=((1.0)*sj0);
IkReal x304=((1.0)*x300);
IkReal x305=((1.0)*x299);
evalcond[0]=(((new_r11*sj0))+((new_r22*x299))+((cj0*new_r01)));
evalcond[1]=(((new_r01*x301))+((new_r11*x302))+x299);
evalcond[2]=((((-1.0)*new_r00*x303))+((cj0*new_r10))+(((-1.0)*x305)));
evalcond[3]=((((-1.0)*new_r01*x303))+((cj0*new_r11))+(((-1.0)*x304)));
evalcond[4]=(((x299*x301))+((sj0*x300))+new_r01);
evalcond[5]=(((new_r10*sj0))+(((-1.0)*new_r22*x304))+((cj0*new_r00)));
evalcond[6]=((((-1.0)*x301*x304))+((sj0*x299))+new_r00);
evalcond[7]=((((-1.0)*cj0*x304))+((x299*x302))+new_r11);
evalcond[8]=(((new_r00*x301))+((new_r10*x302))+(((-1.0)*x304)));
evalcond[9]=((((-1.0)*cj0*x305))+(((-1.0)*x302*x304))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x306=((1.0)*new_r01);
CheckValue<IkReal> x307=IKPowWithIntegerCheck(new_r22,-1);
if(!x307.valid){
continue;
}
if( IKabs(((x307.value)*(((((-1.0)*cj0*x306))+(((-1.0)*new_r11*sj0)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*sj0*x306))+((cj0*new_r11)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x307.value)*(((((-1.0)*cj0*x306))+(((-1.0)*new_r11*sj0))))))+IKsqr(((((-1.0)*sj0*x306))+((cj0*new_r11))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((x307.value)*(((((-1.0)*cj0*x306))+(((-1.0)*new_r11*sj0))))), ((((-1.0)*sj0*x306))+((cj0*new_r11))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[10];
IkReal x308=IKsin(j2);
IkReal x309=IKcos(j2);
IkReal x310=(cj0*new_r22);
IkReal x311=(new_r22*sj0);
IkReal x312=((1.0)*sj0);
IkReal x313=((1.0)*x309);
IkReal x314=((1.0)*x308);
evalcond[0]=(((new_r11*sj0))+((new_r22*x308))+((cj0*new_r01)));
evalcond[1]=(((new_r01*x310))+x308+((new_r11*x311)));
evalcond[2]=((((-1.0)*new_r00*x312))+(((-1.0)*x314))+((cj0*new_r10)));
evalcond[3]=((((-1.0)*x313))+((cj0*new_r11))+(((-1.0)*new_r01*x312)));
evalcond[4]=(((x308*x310))+((sj0*x309))+new_r01);
evalcond[5]=(((new_r10*sj0))+(((-1.0)*new_r22*x313))+((cj0*new_r00)));
evalcond[6]=((((-1.0)*x310*x313))+((sj0*x308))+new_r00);
evalcond[7]=((((-1.0)*cj0*x313))+((x308*x311))+new_r11);
evalcond[8]=(((new_r00*x310))+(((-1.0)*x313))+((new_r10*x311)));
evalcond[9]=((((-1.0)*cj0*x314))+new_r10+(((-1.0)*x311*x313)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x315=cj0*cj0;
IkReal x316=(cj0*new_r22);
CheckValue<IkReal> x317 = IKatan2WithCheck(IkReal((((new_r01*x316))+((new_r00*sj0)))),IkReal(((((-1.0)*new_r00*x316))+((new_r01*sj0)))),IKFAST_ATAN2_MAGTHRESH);
if(!x317.valid){
continue;
}
CheckValue<IkReal> x318=IKPowWithIntegerCheck(IKsign(((-1.0)+(((-1.0)*x315*(new_r22*new_r22)))+x315)),-1);
if(!x318.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x317.value)+(((1.5707963267949)*(x318.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[10];
IkReal x319=IKsin(j2);
IkReal x320=IKcos(j2);
IkReal x321=(cj0*new_r22);
IkReal x322=(new_r22*sj0);
IkReal x323=((1.0)*sj0);
IkReal x324=((1.0)*x320);
IkReal x325=((1.0)*x319);
evalcond[0]=(((new_r11*sj0))+((cj0*new_r01))+((new_r22*x319)));
evalcond[1]=(((new_r01*x321))+x319+((new_r11*x322)));
evalcond[2]=((((-1.0)*x325))+(((-1.0)*new_r00*x323))+((cj0*new_r10)));
evalcond[3]=((((-1.0)*x324))+(((-1.0)*new_r01*x323))+((cj0*new_r11)));
evalcond[4]=(((sj0*x320))+new_r01+((x319*x321)));
evalcond[5]=((((-1.0)*new_r22*x324))+((new_r10*sj0))+((cj0*new_r00)));
evalcond[6]=((((-1.0)*x321*x324))+((sj0*x319))+new_r00);
evalcond[7]=((((-1.0)*cj0*x324))+new_r11+((x319*x322)));
evalcond[8]=(((new_r00*x321))+(((-1.0)*x324))+((new_r10*x322)));
evalcond[9]=((((-1.0)*x322*x324))+(((-1.0)*cj0*x325))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0, j2]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
CheckValue<IkReal> x327=IKPowWithIntegerCheck(sj1,-1);
if(!x327.valid){
continue;
}
IkReal x326=x327.value;
CheckValue<IkReal> x328=IKPowWithIntegerCheck(new_r12,-1);
if(!x328.valid){
continue;
}
if( IKabs((x326*(x328.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj1*cj1))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r02*x326)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x326*(x328.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj1*cj1)))))))+IKsqr((new_r02*x326))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0array[0]=IKatan2((x326*(x328.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj1*cj1)))))), (new_r02*x326));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[8];
IkReal x329=IKcos(j0);
IkReal x330=IKsin(j0);
IkReal x331=((1.0)*cj1);
IkReal x332=((1.0)*sj1);
IkReal x333=(new_r12*x330);
IkReal x334=(new_r02*x329);
evalcond[0]=((((-1.0)*x329*x332))+new_r02);
evalcond[1]=((((-1.0)*x330*x332))+new_r12);
evalcond[2]=(((new_r12*x329))+(((-1.0)*new_r02*x330)));
evalcond[3]=(x333+x334+(((-1.0)*x332)));
evalcond[4]=((((-1.0)*new_r22*x332))+((cj1*x333))+((cj1*x334)));
evalcond[5]=((((-1.0)*new_r00*x329*x332))+(((-1.0)*new_r20*x331))+(((-1.0)*new_r10*x330*x332)));
evalcond[6]=((((-1.0)*new_r01*x329*x332))+(((-1.0)*new_r21*x331))+(((-1.0)*new_r11*x330*x332)));
evalcond[7]=((1.0)+(((-1.0)*new_r22*x331))+(((-1.0)*x332*x334))+(((-1.0)*x332*x333)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j2eval[3];
j2eval[0]=sj1;
j2eval[1]=IKsign(sj1);
j2eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
j2eval[0]=sj0;
j2eval[1]=sj1;
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal j2eval[3];
j2eval[0]=cj0;
j2eval[1]=cj1;
j2eval[2]=sj1;
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j0)))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[3];
sj0=1.0;
cj0=0;
j0=1.5707963267949;
j2eval[0]=sj1;
j2eval[1]=IKsign(sj1);
j2eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[3];
sj0=1.0;
cj0=0;
j0=1.5707963267949;
j2eval[0]=cj1;
j2eval[1]=IKsign(cj1);
j2eval[2]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[1];
sj0=1.0;
cj0=0;
j0=1.5707963267949;
j2eval[0]=sj1;
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j1))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r12;
evalcond[3]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r11))+IKsqr(new_r10)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r11), new_r10);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x335=IKsin(j2);
IkReal x336=((1.0)*(IKcos(j2)));
evalcond[0]=(x335+new_r11);
evalcond[1]=((((-1.0)*x336))+new_r10);
evalcond[2]=((((-1.0)*x335))+(((-1.0)*new_r00)));
evalcond[3]=((((-1.0)*x336))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j1)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r12;
evalcond[3]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r11)+IKsqr(((-1.0)*new_r10))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(new_r11, ((-1.0)*new_r10));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x337=IKcos(j2);
IkReal x338=((1.0)*(IKsin(j2)));
evalcond[0]=(x337+new_r10);
evalcond[1]=((((-1.0)*x338))+new_r11);
evalcond[2]=((((-1.0)*x338))+(((-1.0)*new_r00)));
evalcond[3]=((((-1.0)*x337))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j1)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r11;
evalcond[3]=new_r10;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x339=IKcos(j2);
IkReal x340=((1.0)*(IKsin(j2)));
evalcond[0]=(x339+new_r20);
evalcond[1]=(new_r21+(((-1.0)*x340)));
evalcond[2]=((((-1.0)*new_r00))+(((-1.0)*x340)));
evalcond[3]=((((-1.0)*x339))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j1)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r11;
evalcond[3]=new_r10;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x341=IKsin(j2);
IkReal x342=((1.0)*(IKcos(j2)));
evalcond[0]=(x341+new_r21);
evalcond[1]=(new_r20+(((-1.0)*x342)));
evalcond[2]=((((-1.0)*new_r00))+(((-1.0)*x341)));
evalcond[3]=((((-1.0)*new_r01))+(((-1.0)*x342)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x343=IKsin(j2);
IkReal x344=IKcos(j2);
IkReal x345=((-1.0)*x344);
evalcond[0]=x343;
evalcond[1]=(new_r22*x343);
evalcond[2]=x345;
evalcond[3]=(new_r22*x345);
evalcond[4]=((((-1.0)*new_r00))+(((-1.0)*x343)));
evalcond[5]=((((-1.0)*new_r01))+(((-1.0)*x344)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j2]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x346=IKPowWithIntegerCheck(sj1,-1);
if(!x346.valid){
continue;
}
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*(x346.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r20*(x346.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r20*(x346.value)));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x347=IKsin(j2);
IkReal x348=IKcos(j2);
IkReal x349=((1.0)*sj1);
IkReal x350=((1.0)*x348);
evalcond[0]=(((sj1*x348))+new_r20);
evalcond[1]=(((cj1*x347))+new_r11);
evalcond[2]=((((-1.0)*x347*x349))+new_r21);
evalcond[3]=((((-1.0)*cj1*x350))+new_r10);
evalcond[4]=((((-1.0)*new_r00))+(((-1.0)*x347)));
evalcond[5]=((((-1.0)*x350))+(((-1.0)*new_r01)));
evalcond[6]=(((cj1*new_r11))+x347+(((-1.0)*new_r21*x349)));
evalcond[7]=((((-1.0)*x350))+((cj1*new_r10))+(((-1.0)*new_r20*x349)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x351=IKPowWithIntegerCheck(IKsign(cj1),-1);
if(!x351.valid){
continue;
}
CheckValue<IkReal> x352 = IKatan2WithCheck(IkReal(((-1.0)*new_r11)),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x352.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x351.value)))+(x352.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x353=IKsin(j2);
IkReal x354=IKcos(j2);
IkReal x355=((1.0)*sj1);
IkReal x356=((1.0)*x354);
evalcond[0]=(((sj1*x354))+new_r20);
evalcond[1]=(((cj1*x353))+new_r11);
evalcond[2]=((((-1.0)*x353*x355))+new_r21);
evalcond[3]=((((-1.0)*cj1*x356))+new_r10);
evalcond[4]=((((-1.0)*x353))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x356))+(((-1.0)*new_r01)));
evalcond[6]=(((cj1*new_r11))+x353+(((-1.0)*new_r21*x355)));
evalcond[7]=((((-1.0)*x356))+((cj1*new_r10))+(((-1.0)*new_r20*x355)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x357=IKPowWithIntegerCheck(IKsign(sj1),-1);
if(!x357.valid){
continue;
}
CheckValue<IkReal> x358 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x358.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x357.value)))+(x358.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x359=IKsin(j2);
IkReal x360=IKcos(j2);
IkReal x361=((1.0)*sj1);
IkReal x362=((1.0)*x360);
evalcond[0]=(((sj1*x360))+new_r20);
evalcond[1]=(((cj1*x359))+new_r11);
evalcond[2]=((((-1.0)*x359*x361))+new_r21);
evalcond[3]=((((-1.0)*cj1*x362))+new_r10);
evalcond[4]=((((-1.0)*x359))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x362))+(((-1.0)*new_r01)));
evalcond[6]=(((cj1*new_r11))+x359+(((-1.0)*new_r21*x361)));
evalcond[7]=((((-1.0)*new_r20*x361))+(((-1.0)*x362))+((cj1*new_r10)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j0)))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(new_r00, new_r01);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x363=IKcos(j2);
IkReal x364=IKsin(j2);
IkReal x365=((1.0)*sj1);
IkReal x366=((1.0)*new_r11);
IkReal x367=((1.0)*new_r10);
IkReal x368=((1.0)*x363);
evalcond[0]=(((sj1*x363))+new_r20);
evalcond[1]=((((-1.0)*x364))+new_r00);
evalcond[2]=((((-1.0)*x368))+new_r01);
evalcond[3]=((((-1.0)*x364*x365))+new_r21);
evalcond[4]=((((-1.0)*x366))+((cj1*x364)));
evalcond[5]=((((-1.0)*x367))+(((-1.0)*cj1*x368)));
evalcond[6]=((((-1.0)*cj1*x366))+x364+(((-1.0)*new_r21*x365)));
evalcond[7]=((((-1.0)*new_r20*x365))+(((-1.0)*x368))+(((-1.0)*cj1*x367)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j1)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x369=IKcos(j2);
IkReal x370=IKsin(j2);
IkReal x371=((1.0)*sj0);
IkReal x372=((1.0)*x370);
IkReal x373=((1.0)*x369);
evalcond[0]=(x369+new_r20);
evalcond[1]=((((-1.0)*x372))+new_r21);
evalcond[2]=(((sj0*x369))+new_r01);
evalcond[3]=(((sj0*x370))+new_r00);
evalcond[4]=(new_r11+(((-1.0)*cj0*x373)));
evalcond[5]=(new_r10+(((-1.0)*new_r02*x372)));
evalcond[6]=((((-1.0)*new_r00*x371))+(((-1.0)*x372))+((cj0*new_r10)));
evalcond[7]=((((-1.0)*x373))+((cj0*new_r11))+(((-1.0)*new_r01*x371)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j1)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x374=IKcos(j2);
IkReal x375=IKsin(j2);
IkReal x376=((1.0)*sj0);
IkReal x377=((1.0)*x374);
evalcond[0]=(x375+new_r21);
evalcond[1]=((((-1.0)*x377))+new_r20);
evalcond[2]=(((sj0*x374))+new_r01);
evalcond[3]=(((sj0*x375))+new_r00);
evalcond[4]=(new_r10+((new_r02*x375)));
evalcond[5]=(new_r11+(((-1.0)*cj0*x377)));
evalcond[6]=((((-1.0)*new_r00*x376))+(((-1.0)*x375))+((cj0*new_r10)));
evalcond[7]=((((-1.0)*x377))+((cj0*new_r11))+(((-1.0)*new_r01*x376)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j1))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x378=((1.0)*new_r01);
if( IKabs(((((-1.0)*new_r00*sj0))+(((-1.0)*cj0*x378)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*sj0*x378))+((cj0*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r00*sj0))+(((-1.0)*cj0*x378))))+IKsqr(((((-1.0)*sj0*x378))+((cj0*new_r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*new_r00*sj0))+(((-1.0)*cj0*x378))), ((((-1.0)*sj0*x378))+((cj0*new_r00))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x379=IKsin(j2);
IkReal x380=IKcos(j2);
IkReal x381=((1.0)*sj0);
IkReal x382=((1.0)*x380);
IkReal x383=(sj0*x379);
IkReal x384=(cj0*x379);
IkReal x385=(cj0*x382);
evalcond[0]=(((new_r11*sj0))+x379+((cj0*new_r01)));
evalcond[1]=(x384+new_r01+((sj0*x380)));
evalcond[2]=(((new_r10*sj0))+(((-1.0)*x382))+((cj0*new_r00)));
evalcond[3]=((((-1.0)*x379))+(((-1.0)*new_r00*x381))+((cj0*new_r10)));
evalcond[4]=((((-1.0)*new_r01*x381))+(((-1.0)*x382))+((cj0*new_r11)));
evalcond[5]=(x383+(((-1.0)*x385))+new_r00);
evalcond[6]=(x383+(((-1.0)*x385))+new_r11);
evalcond[7]=((((-1.0)*x380*x381))+(((-1.0)*x384))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j1)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x386=((1.0)*sj0);
if( IKabs(((((-1.0)*new_r00*x386))+((cj0*new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj0*new_r00))+(((-1.0)*new_r01*x386)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r00*x386))+((cj0*new_r01))))+IKsqr(((((-1.0)*cj0*new_r00))+(((-1.0)*new_r01*x386))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*new_r00*x386))+((cj0*new_r01))), ((((-1.0)*cj0*new_r00))+(((-1.0)*new_r01*x386))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x387=IKsin(j2);
IkReal x388=IKcos(j2);
IkReal x389=((1.0)*sj0);
IkReal x390=((1.0)*x387);
IkReal x391=(sj0*x388);
IkReal x392=((1.0)*x388);
IkReal x393=(cj0*x390);
evalcond[0]=(((new_r10*sj0))+x388+((cj0*new_r00)));
evalcond[1]=((((-1.0)*x390))+((new_r11*sj0))+((cj0*new_r01)));
evalcond[2]=(((cj0*x388))+new_r00+((sj0*x387)));
evalcond[3]=((((-1.0)*x390))+(((-1.0)*new_r00*x389))+((cj0*new_r10)));
evalcond[4]=((((-1.0)*x392))+(((-1.0)*new_r01*x389))+((cj0*new_r11)));
evalcond[5]=((((-1.0)*x393))+x391+new_r01);
evalcond[6]=((((-1.0)*x393))+x391+new_r10);
evalcond[7]=((((-1.0)*cj0*x392))+(((-1.0)*x387*x389))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j0))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(new_r10, new_r11);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x394=IKcos(j2);
IkReal x395=IKsin(j2);
IkReal x396=((1.0)*sj1);
IkReal x397=((1.0)*x394);
evalcond[0]=(((sj1*x394))+new_r20);
evalcond[1]=((((-1.0)*x395))+new_r10);
evalcond[2]=((((-1.0)*x397))+new_r11);
evalcond[3]=(((cj1*x395))+new_r01);
evalcond[4]=((((-1.0)*x395*x396))+new_r21);
evalcond[5]=((((-1.0)*cj1*x397))+new_r00);
evalcond[6]=((((-1.0)*new_r21*x396))+((cj1*new_r01))+x395);
evalcond[7]=((((-1.0)*x397))+((cj1*new_r00))+(((-1.0)*new_r20*x396)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j0)))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[3];
sj0=0;
cj0=-1.0;
j0=3.14159265358979;
j2eval[0]=sj1;
j2eval[1]=IKsign(sj1);
j2eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[1];
sj0=0;
cj0=-1.0;
j0=3.14159265358979;
j2eval[0]=sj1;
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
sj0=0;
cj0=-1.0;
j0=3.14159265358979;
j2eval[0]=cj1;
j2eval[1]=sj1;
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j1)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r01;
evalcond[3]=new_r00;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x398=IKcos(j2);
IkReal x399=((1.0)*(IKsin(j2)));
evalcond[0]=(x398+new_r20);
evalcond[1]=((((-1.0)*x399))+new_r21);
evalcond[2]=((((-1.0)*x399))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x398))+(((-1.0)*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j1)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r01;
evalcond[3]=new_r00;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x400=IKsin(j2);
IkReal x401=((1.0)*(IKcos(j2)));
evalcond[0]=(x400+new_r21);
evalcond[1]=(new_r20+(((-1.0)*x401)));
evalcond[2]=((((-1.0)*new_r10))+(((-1.0)*x400)));
evalcond[3]=((((-1.0)*new_r11))+(((-1.0)*x401)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j1))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(new_r01, ((-1.0)*new_r11));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x402=IKsin(j2);
IkReal x403=((1.0)*(IKcos(j2)));
evalcond[0]=(x402+(((-1.0)*new_r01)));
evalcond[1]=((((-1.0)*new_r10))+(((-1.0)*x402)));
evalcond[2]=((((-1.0)*new_r11))+(((-1.0)*x403)));
evalcond[3]=((((-1.0)*new_r00))+(((-1.0)*x403)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j1)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r10), new_r00);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x404=IKcos(j2);
IkReal x405=((1.0)*(IKsin(j2)));
evalcond[0]=(x404+(((-1.0)*new_r00)));
evalcond[1]=((((-1.0)*new_r10))+(((-1.0)*x405)));
evalcond[2]=((((-1.0)*new_r11))+(((-1.0)*x404)));
evalcond[3]=((((-1.0)*new_r01))+(((-1.0)*x405)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r11));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x406=IKsin(j2);
IkReal x407=IKcos(j2);
IkReal x408=((-1.0)*x407);
evalcond[0]=x406;
evalcond[1]=(new_r22*x406);
evalcond[2]=x408;
evalcond[3]=(new_r22*x408);
evalcond[4]=((((-1.0)*new_r10))+(((-1.0)*x406)));
evalcond[5]=((((-1.0)*new_r11))+(((-1.0)*x407)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j2]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x409=IKPowWithIntegerCheck(cj1,-1);
if(!x409.valid){
continue;
}
CheckValue<IkReal> x410=IKPowWithIntegerCheck(sj1,-1);
if(!x410.valid){
continue;
}
if( IKabs((new_r01*(x409.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*(x410.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r01*(x409.value)))+IKsqr(((-1.0)*new_r20*(x410.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((new_r01*(x409.value)), ((-1.0)*new_r20*(x410.value)));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x411=IKsin(j2);
IkReal x412=IKcos(j2);
IkReal x413=((1.0)*new_r00);
IkReal x414=((1.0)*sj1);
IkReal x415=((1.0)*new_r01);
IkReal x416=((1.0)*x412);
evalcond[0]=(((sj1*x412))+new_r20);
evalcond[1]=((((-1.0)*x411*x414))+new_r21);
evalcond[2]=((((-1.0)*new_r10))+(((-1.0)*x411)));
evalcond[3]=((((-1.0)*new_r11))+(((-1.0)*x416)));
evalcond[4]=((((-1.0)*x415))+((cj1*x411)));
evalcond[5]=((((-1.0)*cj1*x416))+(((-1.0)*x413)));
evalcond[6]=((((-1.0)*cj1*x415))+x411+(((-1.0)*new_r21*x414)));
evalcond[7]=((((-1.0)*cj1*x413))+(((-1.0)*new_r20*x414))+(((-1.0)*x416)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x417=IKPowWithIntegerCheck(sj1,-1);
if(!x417.valid){
continue;
}
if( IKabs((new_r21*(x417.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r21*(x417.value)))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((new_r21*(x417.value)), ((-1.0)*new_r11));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x418=IKsin(j2);
IkReal x419=IKcos(j2);
IkReal x420=((1.0)*new_r00);
IkReal x421=((1.0)*sj1);
IkReal x422=((1.0)*new_r01);
IkReal x423=((1.0)*x419);
evalcond[0]=(((sj1*x419))+new_r20);
evalcond[1]=((((-1.0)*x418*x421))+new_r21);
evalcond[2]=((((-1.0)*new_r10))+(((-1.0)*x418)));
evalcond[3]=((((-1.0)*x423))+(((-1.0)*new_r11)));
evalcond[4]=((((-1.0)*x422))+((cj1*x418)));
evalcond[5]=((((-1.0)*cj1*x423))+(((-1.0)*x420)));
evalcond[6]=((((-1.0)*cj1*x422))+x418+(((-1.0)*new_r21*x421)));
evalcond[7]=((((-1.0)*cj1*x420))+(((-1.0)*x423))+(((-1.0)*new_r20*x421)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x424=IKPowWithIntegerCheck(IKsign(sj1),-1);
if(!x424.valid){
continue;
}
CheckValue<IkReal> x425 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x425.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x424.value)))+(x425.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x426=IKsin(j2);
IkReal x427=IKcos(j2);
IkReal x428=((1.0)*new_r00);
IkReal x429=((1.0)*sj1);
IkReal x430=((1.0)*new_r01);
IkReal x431=((1.0)*x427);
evalcond[0]=(new_r20+((sj1*x427)));
evalcond[1]=((((-1.0)*x426*x429))+new_r21);
evalcond[2]=((((-1.0)*x426))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x431))+(((-1.0)*new_r11)));
evalcond[4]=((((-1.0)*x430))+((cj1*x426)));
evalcond[5]=((((-1.0)*x428))+(((-1.0)*cj1*x431)));
evalcond[6]=((((-1.0)*cj1*x430))+x426+(((-1.0)*new_r21*x429)));
evalcond[7]=((((-1.0)*x431))+(((-1.0)*cj1*x428))+(((-1.0)*new_r20*x429)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[1];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
j2eval[0]=IKabs(new_r22);
if( IKabs(j2eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j2]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
op[0]=new_r22;
op[1]=0;
op[2]=((-1.0)*new_r22);
polyroots2(op,zeror,numroots);
IkReal j2array[2], cj2array[2], sj2array[2], tempj2array[1];
int numsolutions = 0;
for(int ij2 = 0; ij2 < numroots; ++ij2)
{
IkReal htj2 = zeror[ij2];
tempj2array[0]=((2.0)*(atan(htj2)));
for(int kj2 = 0; kj2 < 1; ++kj2)
{
j2array[numsolutions] = tempj2array[kj2];
if( j2array[numsolutions] > IKPI )
{
    j2array[numsolutions]-=IK2PI;
}
else if( j2array[numsolutions] < -IKPI )
{
    j2array[numsolutions]+=IK2PI;
}
sj2array[numsolutions] = IKsin(j2array[numsolutions]);
cj2array[numsolutions] = IKcos(j2array[numsolutions]);
numsolutions++;
}
}
bool j2valid[2]={true,true};
_nj2 = 2;
for(int ij2 = 0; ij2 < numsolutions; ++ij2)
    {
if( !j2valid[ij2] )
{
    continue;
}
    j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
htj2 = IKtan(j2/2);

_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < numsolutions; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j2]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x433=IKPowWithIntegerCheck(sj1,-1);
if(!x433.valid){
continue;
}
IkReal x432=x433.value;
CheckValue<IkReal> x434=IKPowWithIntegerCheck(cj0,-1);
if(!x434.valid){
continue;
}
CheckValue<IkReal> x435=IKPowWithIntegerCheck(cj1,-1);
if(!x435.valid){
continue;
}
if( IKabs((x432*(x434.value)*(x435.value)*((((new_r20*sj0))+(((-1.0)*new_r01*sj1)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x432)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x432*(x434.value)*(x435.value)*((((new_r20*sj0))+(((-1.0)*new_r01*sj1))))))+IKsqr(((-1.0)*new_r20*x432))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((x432*(x434.value)*(x435.value)*((((new_r20*sj0))+(((-1.0)*new_r01*sj1))))), ((-1.0)*new_r20*x432));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[12];
IkReal x436=IKsin(j2);
IkReal x437=IKcos(j2);
IkReal x438=((1.0)*sj1);
IkReal x439=((1.0)*sj0);
IkReal x440=(cj0*new_r00);
IkReal x441=(cj0*cj1);
IkReal x442=(new_r11*sj0);
IkReal x443=(new_r10*sj0);
IkReal x444=((1.0)*x437);
IkReal x445=(cj1*x436);
IkReal x446=((1.0)*x436);
evalcond[0]=(new_r20+((sj1*x437)));
evalcond[1]=((((-1.0)*x436*x438))+new_r21);
evalcond[2]=(x445+x442+((cj0*new_r01)));
evalcond[3]=((((-1.0)*new_r00*x439))+(((-1.0)*x446))+((cj0*new_r10)));
evalcond[4]=((((-1.0)*x444))+(((-1.0)*new_r01*x439))+((cj0*new_r11)));
evalcond[5]=(((sj0*x437))+new_r01+((x436*x441)));
evalcond[6]=((((-1.0)*cj1*x444))+x440+x443);
evalcond[7]=(((sj0*x436))+new_r00+(((-1.0)*x441*x444)));
evalcond[8]=(((sj0*x445))+new_r11+(((-1.0)*cj0*x444)));
evalcond[9]=((((-1.0)*cj1*x437*x439))+new_r10+(((-1.0)*cj0*x446)));
evalcond[10]=(((new_r01*x441))+((cj1*x442))+x436+(((-1.0)*new_r21*x438)));
evalcond[11]=((((-1.0)*x444))+((cj1*x440))+((cj1*x443))+(((-1.0)*new_r20*x438)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x448=IKPowWithIntegerCheck(sj1,-1);
if(!x448.valid){
continue;
}
IkReal x447=x448.value;
CheckValue<IkReal> x449=IKPowWithIntegerCheck(sj0,-1);
if(!x449.valid){
continue;
}
if( IKabs((x447*(x449.value)*(((((-1.0)*cj0*cj1*new_r20))+(((-1.0)*new_r00*sj1)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x447)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x447*(x449.value)*(((((-1.0)*cj0*cj1*new_r20))+(((-1.0)*new_r00*sj1))))))+IKsqr(((-1.0)*new_r20*x447))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((x447*(x449.value)*(((((-1.0)*cj0*cj1*new_r20))+(((-1.0)*new_r00*sj1))))), ((-1.0)*new_r20*x447));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[12];
IkReal x450=IKsin(j2);
IkReal x451=IKcos(j2);
IkReal x452=((1.0)*sj1);
IkReal x453=((1.0)*sj0);
IkReal x454=(cj0*new_r00);
IkReal x455=(cj0*cj1);
IkReal x456=(new_r11*sj0);
IkReal x457=(new_r10*sj0);
IkReal x458=((1.0)*x451);
IkReal x459=(cj1*x450);
IkReal x460=((1.0)*x450);
evalcond[0]=(((sj1*x451))+new_r20);
evalcond[1]=((((-1.0)*x450*x452))+new_r21);
evalcond[2]=(x459+x456+((cj0*new_r01)));
evalcond[3]=((((-1.0)*x460))+(((-1.0)*new_r00*x453))+((cj0*new_r10)));
evalcond[4]=((((-1.0)*new_r01*x453))+(((-1.0)*x458))+((cj0*new_r11)));
evalcond[5]=(((sj0*x451))+((x450*x455))+new_r01);
evalcond[6]=((((-1.0)*cj1*x458))+x457+x454);
evalcond[7]=((((-1.0)*x455*x458))+((sj0*x450))+new_r00);
evalcond[8]=((((-1.0)*cj0*x458))+((sj0*x459))+new_r11);
evalcond[9]=((((-1.0)*cj0*x460))+(((-1.0)*cj1*x451*x453))+new_r10);
evalcond[10]=((((-1.0)*new_r21*x452))+((new_r01*x455))+((cj1*x456))+x450);
evalcond[11]=((((-1.0)*new_r20*x452))+((cj1*x454))+((cj1*x457))+(((-1.0)*x458)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x461=IKPowWithIntegerCheck(IKsign(sj1),-1);
if(!x461.valid){
continue;
}
CheckValue<IkReal> x462 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x462.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x461.value)))+(x462.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[12];
IkReal x463=IKsin(j2);
IkReal x464=IKcos(j2);
IkReal x465=((1.0)*sj1);
IkReal x466=((1.0)*sj0);
IkReal x467=(cj0*new_r00);
IkReal x468=(cj0*cj1);
IkReal x469=(new_r11*sj0);
IkReal x470=(new_r10*sj0);
IkReal x471=((1.0)*x464);
IkReal x472=(cj1*x463);
IkReal x473=((1.0)*x463);
evalcond[0]=(((sj1*x464))+new_r20);
evalcond[1]=((((-1.0)*x463*x465))+new_r21);
evalcond[2]=(x469+x472+((cj0*new_r01)));
evalcond[3]=((((-1.0)*x473))+(((-1.0)*new_r00*x466))+((cj0*new_r10)));
evalcond[4]=((((-1.0)*x471))+(((-1.0)*new_r01*x466))+((cj0*new_r11)));
evalcond[5]=(((x463*x468))+((sj0*x464))+new_r01);
evalcond[6]=((((-1.0)*cj1*x471))+x467+x470);
evalcond[7]=((((-1.0)*x468*x471))+((sj0*x463))+new_r00);
evalcond[8]=((((-1.0)*cj0*x471))+new_r11+((sj0*x472)));
evalcond[9]=((((-1.0)*cj0*x473))+(((-1.0)*cj1*x464*x466))+new_r10);
evalcond[10]=((((-1.0)*new_r21*x465))+((new_r01*x468))+((cj1*x469))+x463);
evalcond[11]=((((-1.0)*new_r20*x465))+((cj1*x467))+(((-1.0)*x471))+((cj1*x470)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x474=IKPowWithIntegerCheck(IKsign(sj1),-1);
if(!x474.valid){
continue;
}
CheckValue<IkReal> x475 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x475.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x474.value)))+(x475.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[2];
evalcond[0]=(((sj1*(IKcos(j2))))+new_r20);
evalcond[1]=((((-1.0)*sj1*(IKsin(j2))))+new_r21);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0eval[3];
j0eval[0]=sj1;
j0eval[1]=((IKabs(new_r12))+(IKabs(new_r02)));
j0eval[2]=IKsign(sj1);
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[2];
j0eval[0]=cj2;
j0eval[1]=sj1;
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j2)))), 6.28318530717959)));
evalcond[1]=new_r20;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(new_r10)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0array[0]=IKatan2(((-1.0)*new_r00), new_r10);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[18];
IkReal x476=IKsin(j0);
IkReal x477=IKcos(j0);
IkReal x478=((1.0)*sj1);
IkReal x479=((1.0)*cj1);
IkReal x480=(new_r10*x476);
IkReal x481=(new_r01*x477);
IkReal x482=(new_r00*x477);
IkReal x483=((1.0)*x476);
IkReal x484=(new_r11*x476);
IkReal x485=(new_r12*x476);
IkReal x486=(cj1*x477);
IkReal x487=(new_r02*x477);
evalcond[0]=(x476+new_r00);
evalcond[1]=(x486+new_r01);
evalcond[2]=(((cj1*x476))+new_r11);
evalcond[3]=((((-1.0)*x477))+new_r10);
evalcond[4]=((((-1.0)*x477*x478))+new_r02);
evalcond[5]=((((-1.0)*x476*x478))+new_r12);
evalcond[6]=(x480+x482);
evalcond[7]=(((new_r12*x477))+(((-1.0)*new_r02*x483)));
evalcond[8]=((((-1.0)*new_r01*x483))+((new_r11*x477)));
evalcond[9]=(cj1+x481+x484);
evalcond[10]=((-1.0)+(((-1.0)*new_r00*x483))+((new_r10*x477)));
evalcond[11]=(((cj1*x482))+((cj1*x480)));
evalcond[12]=((((-1.0)*x478))+x485+x487);
evalcond[13]=((((-1.0)*x478*x480))+(((-1.0)*x478*x482)));
evalcond[14]=(((new_r02*x486))+(((-1.0)*new_r22*x478))+((cj1*x485)));
evalcond[15]=((1.0)+(((-1.0)*new_r21*x478))+((cj1*x484))+((cj1*x481)));
evalcond[16]=((((-1.0)*new_r21*x479))+(((-1.0)*x478*x481))+(((-1.0)*x478*x484)));
evalcond[17]=((1.0)+(((-1.0)*new_r22*x479))+(((-1.0)*x478*x485))+(((-1.0)*x478*x487)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j2)))), 6.28318530717959)));
evalcond[1]=new_r20;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(((-1.0)*new_r10))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0array[0]=IKatan2(new_r00, ((-1.0)*new_r10));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[18];
IkReal x488=IKcos(j0);
IkReal x489=IKsin(j0);
IkReal x490=((1.0)*sj1);
IkReal x491=((1.0)*cj1);
IkReal x492=(new_r10*x489);
IkReal x493=(new_r01*x488);
IkReal x494=(new_r00*x488);
IkReal x495=((1.0)*x489);
IkReal x496=(new_r11*x489);
IkReal x497=(new_r12*x489);
IkReal x498=(new_r02*x488);
evalcond[0]=(x488+new_r10);
evalcond[1]=((((-1.0)*x495))+new_r00);
evalcond[2]=((((-1.0)*x488*x490))+new_r02);
evalcond[3]=((((-1.0)*x489*x490))+new_r12);
evalcond[4]=((((-1.0)*x488*x491))+new_r01);
evalcond[5]=((((-1.0)*x489*x491))+new_r11);
evalcond[6]=(x492+x494);
evalcond[7]=((((-1.0)*new_r02*x495))+((new_r12*x488)));
evalcond[8]=((((-1.0)*new_r01*x495))+((new_r11*x488)));
evalcond[9]=((1.0)+(((-1.0)*new_r00*x495))+((new_r10*x488)));
evalcond[10]=(((cj1*x492))+((cj1*x494)));
evalcond[11]=((((-1.0)*x490))+x498+x497);
evalcond[12]=((((-1.0)*x491))+x493+x496);
evalcond[13]=((((-1.0)*x490*x492))+(((-1.0)*x490*x494)));
evalcond[14]=((((-1.0)*new_r22*x490))+((cj1*x498))+((cj1*x497)));
evalcond[15]=((-1.0)+(sj1*sj1)+((cj1*x493))+((cj1*x496)));
evalcond[16]=((((-1.0)*new_r21*x491))+(((-1.0)*x490*x493))+(((-1.0)*x490*x496)));
evalcond[17]=((1.0)+(((-1.0)*x490*x498))+(((-1.0)*x490*x497))+(((-1.0)*new_r22*x491)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j1))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x499=((1.0)*sj2);
if( IKabs(((((-1.0)*new_r00*x499))+(((-1.0)*cj2*new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*x499))+((cj2*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r00*x499))+(((-1.0)*cj2*new_r01))))+IKsqr(((((-1.0)*new_r01*x499))+((cj2*new_r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0array[0]=IKatan2(((((-1.0)*new_r00*x499))+(((-1.0)*cj2*new_r01))), ((((-1.0)*new_r01*x499))+((cj2*new_r00))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[8];
IkReal x500=IKcos(j0);
IkReal x501=IKsin(j0);
IkReal x502=((1.0)*cj2);
IkReal x503=((1.0)*sj2);
IkReal x504=(sj2*x501);
IkReal x505=((1.0)*x501);
IkReal x506=(x500*x502);
evalcond[0]=(sj2+((new_r11*x501))+((new_r01*x500)));
evalcond[1]=(((sj2*x500))+((cj2*x501))+new_r01);
evalcond[2]=((((-1.0)*x506))+x504+new_r00);
evalcond[3]=((((-1.0)*x506))+x504+new_r11);
evalcond[4]=((((-1.0)*x502))+((new_r10*x501))+((new_r00*x500)));
evalcond[5]=((((-1.0)*x501*x502))+new_r10+(((-1.0)*x500*x503)));
evalcond[6]=((((-1.0)*new_r00*x505))+(((-1.0)*x503))+((new_r10*x500)));
evalcond[7]=((((-1.0)*new_r01*x505))+(((-1.0)*x502))+((new_r11*x500)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j1)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x507=((1.0)*new_r00);
if( IKabs(((((-1.0)*sj2*x507))+(((-1.0)*cj2*new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((new_r01*sj2))+(((-1.0)*cj2*x507)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*sj2*x507))+(((-1.0)*cj2*new_r01))))+IKsqr((((new_r01*sj2))+(((-1.0)*cj2*x507))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0array[0]=IKatan2(((((-1.0)*sj2*x507))+(((-1.0)*cj2*new_r01))), (((new_r01*sj2))+(((-1.0)*cj2*x507))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[8];
IkReal x508=IKcos(j0);
IkReal x509=IKsin(j0);
IkReal x510=((1.0)*sj2);
IkReal x511=(cj2*x509);
IkReal x512=(sj2*x509);
IkReal x513=((1.0)*x508);
IkReal x514=((1.0)*x509);
IkReal x515=(x508*x510);
evalcond[0]=(cj2+((new_r10*x509))+((new_r00*x508)));
evalcond[1]=(((cj2*x508))+x512+new_r00);
evalcond[2]=(x511+new_r01+(((-1.0)*x515)));
evalcond[3]=(x511+new_r10+(((-1.0)*x515)));
evalcond[4]=(((new_r11*x509))+((new_r01*x508))+(((-1.0)*x510)));
evalcond[5]=((((-1.0)*cj2*x513))+new_r11+(((-1.0)*x509*x510)));
evalcond[6]=(((new_r10*x508))+(((-1.0)*new_r00*x514))+(((-1.0)*x510)));
evalcond[7]=(((new_r11*x508))+(((-1.0)*new_r01*x514))+(((-1.0)*cj2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r12))+(IKabs(new_r02)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j0eval[0]=((IKabs(new_r11))+(IKabs(new_r01)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal j0eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j0eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal j0eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j0eval[0]=((IKabs((new_r11*new_r22)))+(IKabs((new_r01*new_r22))));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j0]

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x517 = IKatan2WithCheck(IkReal((new_r01*new_r22)),IkReal((new_r11*new_r22)),IKFAST_ATAN2_MAGTHRESH);
if(!x517.valid){
continue;
}
IkReal x516=x517.value;
j0array[0]=((-1.0)*x516);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x516)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x518=IKcos(j0);
IkReal x519=IKsin(j0);
IkReal x520=(new_r10*x519);
IkReal x521=((1.0)*x519);
IkReal x522=(new_r00*x518);
evalcond[0]=(((new_r01*x518))+((new_r11*x519)));
evalcond[1]=(x522+x520);
evalcond[2]=(((new_r10*x518))+(((-1.0)*new_r00*x521)));
evalcond[3]=(((new_r11*x518))+(((-1.0)*new_r01*x521)));
evalcond[4]=(((new_r22*x522))+((new_r22*x520)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x524 = IKatan2WithCheck(IkReal(new_r00),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x524.valid){
continue;
}
IkReal x523=x524.value;
j0array[0]=((-1.0)*x523);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x523)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x525=IKcos(j0);
IkReal x526=IKsin(j0);
IkReal x527=((1.0)*x526);
IkReal x528=(new_r11*x526);
IkReal x529=(new_r22*x525);
evalcond[0]=(((new_r01*x525))+x528);
evalcond[1]=((((-1.0)*new_r00*x527))+((new_r10*x525)));
evalcond[2]=(((new_r11*x525))+(((-1.0)*new_r01*x527)));
evalcond[3]=(((new_r01*x529))+((new_r22*x528)));
evalcond[4]=(((new_r10*new_r22*x526))+((new_r00*x529)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x531 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x531.valid){
continue;
}
IkReal x530=x531.value;
j0array[0]=((-1.0)*x530);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x530)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x532=IKcos(j0);
IkReal x533=IKsin(j0);
IkReal x534=(new_r10*x533);
IkReal x535=((1.0)*x533);
IkReal x536=(new_r00*x532);
evalcond[0]=(x534+x536);
evalcond[1]=((((-1.0)*new_r00*x535))+((new_r10*x532)));
evalcond[2]=(((new_r11*x532))+(((-1.0)*new_r01*x535)));
evalcond[3]=(((new_r11*new_r22*x533))+((new_r01*new_r22*x532)));
evalcond[4]=(((new_r22*x536))+((new_r22*x534)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
CheckValue<IkReal> x538=IKPowWithIntegerCheck(sj1,-1);
if(!x538.valid){
continue;
}
IkReal x537=x538.value;
CheckValue<IkReal> x539=IKPowWithIntegerCheck(cj2,-1);
if(!x539.valid){
continue;
}
if( IKabs((x537*(x539.value)*(((((-1.0)*new_r01*sj1))+(((-1.0)*cj1*new_r02*sj2)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r02*x537)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x537*(x539.value)*(((((-1.0)*new_r01*sj1))+(((-1.0)*cj1*new_r02*sj2))))))+IKsqr((new_r02*x537))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0array[0]=IKatan2((x537*(x539.value)*(((((-1.0)*new_r01*sj1))+(((-1.0)*cj1*new_r02*sj2))))), (new_r02*x537));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[18];
IkReal x540=IKcos(j0);
IkReal x541=IKsin(j0);
IkReal x542=((1.0)*cj2);
IkReal x543=((1.0)*sj1);
IkReal x544=((1.0)*cj1);
IkReal x545=((1.0)*sj2);
IkReal x546=(new_r10*x541);
IkReal x547=(new_r01*x540);
IkReal x548=(new_r00*x540);
IkReal x549=((1.0)*x541);
IkReal x550=(new_r11*x541);
IkReal x551=(new_r12*x541);
IkReal x552=(sj2*x541);
IkReal x553=(cj1*x540);
IkReal x554=(cj2*x541);
IkReal x555=(new_r02*x540);
evalcond[0]=((((-1.0)*x540*x543))+new_r02);
evalcond[1]=((((-1.0)*x541*x543))+new_r12);
evalcond[2]=(((new_r12*x540))+(((-1.0)*new_r02*x549)));
evalcond[3]=(((sj2*x553))+x554+new_r01);
evalcond[4]=((((-1.0)*x543))+x551+x555);
evalcond[5]=(((cj1*sj2))+x550+x547);
evalcond[6]=(x552+new_r00+(((-1.0)*x542*x553)));
evalcond[7]=((((-1.0)*x540*x542))+((cj1*x552))+new_r11);
evalcond[8]=((((-1.0)*new_r00*x549))+((new_r10*x540))+(((-1.0)*x545)));
evalcond[9]=(((new_r11*x540))+(((-1.0)*new_r01*x549))+(((-1.0)*x542)));
evalcond[10]=((((-1.0)*cj1*x542))+x546+x548);
evalcond[11]=((((-1.0)*cj1*x541*x542))+(((-1.0)*x540*x545))+new_r10);
evalcond[12]=((((-1.0)*new_r22*x543))+((new_r02*x553))+((cj1*x551)));
evalcond[13]=(sj2+((cj1*x550))+((cj1*x547))+(((-1.0)*new_r21*x543)));
evalcond[14]=((((-1.0)*new_r20*x544))+(((-1.0)*x543*x546))+(((-1.0)*x543*x548)));
evalcond[15]=((((-1.0)*new_r21*x544))+(((-1.0)*x543*x550))+(((-1.0)*x543*x547)));
evalcond[16]=((1.0)+(((-1.0)*new_r22*x544))+(((-1.0)*x543*x551))+(((-1.0)*x543*x555)));
evalcond[17]=((((-1.0)*new_r20*x543))+(((-1.0)*x542))+((cj1*x546))+((cj1*x548)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
CheckValue<IkReal> x556=IKPowWithIntegerCheck(IKsign(sj1),-1);
if(!x556.valid){
continue;
}
CheckValue<IkReal> x557 = IKatan2WithCheck(IkReal(new_r12),IkReal(new_r02),IKFAST_ATAN2_MAGTHRESH);
if(!x557.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x556.value)))+(x557.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[18];
IkReal x558=IKcos(j0);
IkReal x559=IKsin(j0);
IkReal x560=((1.0)*cj2);
IkReal x561=((1.0)*sj1);
IkReal x562=((1.0)*cj1);
IkReal x563=((1.0)*sj2);
IkReal x564=(new_r10*x559);
IkReal x565=(new_r01*x558);
IkReal x566=(new_r00*x558);
IkReal x567=((1.0)*x559);
IkReal x568=(new_r11*x559);
IkReal x569=(new_r12*x559);
IkReal x570=(sj2*x559);
IkReal x571=(cj1*x558);
IkReal x572=(cj2*x559);
IkReal x573=(new_r02*x558);
evalcond[0]=((((-1.0)*x558*x561))+new_r02);
evalcond[1]=((((-1.0)*x559*x561))+new_r12);
evalcond[2]=((((-1.0)*new_r02*x567))+((new_r12*x558)));
evalcond[3]=(((sj2*x571))+x572+new_r01);
evalcond[4]=(x573+x569+(((-1.0)*x561)));
evalcond[5]=(((cj1*sj2))+x568+x565);
evalcond[6]=((((-1.0)*x560*x571))+x570+new_r00);
evalcond[7]=((((-1.0)*x558*x560))+new_r11+((cj1*x570)));
evalcond[8]=((((-1.0)*new_r00*x567))+((new_r10*x558))+(((-1.0)*x563)));
evalcond[9]=(((new_r11*x558))+(((-1.0)*x560))+(((-1.0)*new_r01*x567)));
evalcond[10]=((((-1.0)*cj1*x560))+x566+x564);
evalcond[11]=((((-1.0)*cj1*x559*x560))+(((-1.0)*x558*x563))+new_r10);
evalcond[12]=(((cj1*x569))+(((-1.0)*new_r22*x561))+((new_r02*x571)));
evalcond[13]=(((cj1*x565))+((cj1*x568))+sj2+(((-1.0)*new_r21*x561)));
evalcond[14]=((((-1.0)*new_r20*x562))+(((-1.0)*x561*x564))+(((-1.0)*x561*x566)));
evalcond[15]=((((-1.0)*x561*x565))+(((-1.0)*x561*x568))+(((-1.0)*new_r21*x562)));
evalcond[16]=((1.0)+(((-1.0)*x561*x573))+(((-1.0)*new_r22*x562))+(((-1.0)*x561*x569)));
evalcond[17]=(((cj1*x564))+((cj1*x566))+(((-1.0)*new_r20*x561))+(((-1.0)*x560)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
CheckValue<IkReal> x574=IKPowWithIntegerCheck(IKsign(sj1),-1);
if(!x574.valid){
continue;
}
CheckValue<IkReal> x575 = IKatan2WithCheck(IkReal(new_r12),IkReal(new_r02),IKFAST_ATAN2_MAGTHRESH);
if(!x575.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x574.value)))+(x575.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[8];
IkReal x576=IKcos(j0);
IkReal x577=IKsin(j0);
IkReal x578=((1.0)*cj1);
IkReal x579=((1.0)*sj1);
IkReal x580=(new_r12*x577);
IkReal x581=(new_r02*x576);
evalcond[0]=((((-1.0)*x576*x579))+new_r02);
evalcond[1]=((((-1.0)*x577*x579))+new_r12);
evalcond[2]=((((-1.0)*new_r02*x577))+((new_r12*x576)));
evalcond[3]=((((-1.0)*x579))+x580+x581);
evalcond[4]=((((-1.0)*new_r22*x579))+((cj1*x580))+((cj1*x581)));
evalcond[5]=((((-1.0)*new_r00*x576*x579))+(((-1.0)*new_r20*x578))+(((-1.0)*new_r10*x577*x579)));
evalcond[6]=((((-1.0)*new_r01*x576*x579))+(((-1.0)*new_r11*x577*x579))+(((-1.0)*new_r21*x578)));
evalcond[7]=((1.0)+(((-1.0)*new_r22*x578))+(((-1.0)*x579*x581))+(((-1.0)*x579*x580)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j2eval[3];
j2eval[0]=sj1;
j2eval[1]=IKsign(sj1);
j2eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
j2eval[0]=sj0;
j2eval[1]=sj1;
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal j2eval[3];
j2eval[0]=cj0;
j2eval[1]=cj1;
j2eval[2]=sj1;
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j0)))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[3];
sj0=1.0;
cj0=0;
j0=1.5707963267949;
j2eval[0]=sj1;
j2eval[1]=IKsign(sj1);
j2eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[3];
sj0=1.0;
cj0=0;
j0=1.5707963267949;
j2eval[0]=cj1;
j2eval[1]=IKsign(cj1);
j2eval[2]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[1];
sj0=1.0;
cj0=0;
j0=1.5707963267949;
j2eval[0]=sj1;
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j1))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r12;
evalcond[3]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r11))+IKsqr(new_r10)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r11), new_r10);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x582=IKsin(j2);
IkReal x583=((1.0)*(IKcos(j2)));
evalcond[0]=(x582+new_r11);
evalcond[1]=(new_r10+(((-1.0)*x583)));
evalcond[2]=((((-1.0)*x582))+(((-1.0)*new_r00)));
evalcond[3]=((((-1.0)*new_r01))+(((-1.0)*x583)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j1)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r12;
evalcond[3]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r11)+IKsqr(((-1.0)*new_r10))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(new_r11, ((-1.0)*new_r10));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x584=IKcos(j2);
IkReal x585=((1.0)*(IKsin(j2)));
evalcond[0]=(x584+new_r10);
evalcond[1]=(new_r11+(((-1.0)*x585)));
evalcond[2]=((((-1.0)*new_r00))+(((-1.0)*x585)));
evalcond[3]=((((-1.0)*x584))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j1)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r11;
evalcond[3]=new_r10;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x586=IKcos(j2);
IkReal x587=((1.0)*(IKsin(j2)));
evalcond[0]=(x586+new_r20);
evalcond[1]=(new_r21+(((-1.0)*x587)));
evalcond[2]=((((-1.0)*new_r00))+(((-1.0)*x587)));
evalcond[3]=((((-1.0)*x586))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j1)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r11;
evalcond[3]=new_r10;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x588=IKsin(j2);
IkReal x589=((1.0)*(IKcos(j2)));
evalcond[0]=(x588+new_r21);
evalcond[1]=(new_r20+(((-1.0)*x589)));
evalcond[2]=((((-1.0)*x588))+(((-1.0)*new_r00)));
evalcond[3]=((((-1.0)*new_r01))+(((-1.0)*x589)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x590=IKsin(j2);
IkReal x591=IKcos(j2);
IkReal x592=((-1.0)*x591);
evalcond[0]=x590;
evalcond[1]=(new_r22*x590);
evalcond[2]=x592;
evalcond[3]=(new_r22*x592);
evalcond[4]=((((-1.0)*x590))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x591))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j2]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x593=IKPowWithIntegerCheck(sj1,-1);
if(!x593.valid){
continue;
}
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*(x593.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r20*(x593.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r20*(x593.value)));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x594=IKsin(j2);
IkReal x595=IKcos(j2);
IkReal x596=((1.0)*sj1);
IkReal x597=((1.0)*x595);
evalcond[0]=(((sj1*x595))+new_r20);
evalcond[1]=(((cj1*x594))+new_r11);
evalcond[2]=((((-1.0)*x594*x596))+new_r21);
evalcond[3]=((((-1.0)*cj1*x597))+new_r10);
evalcond[4]=((((-1.0)*x594))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x597))+(((-1.0)*new_r01)));
evalcond[6]=((((-1.0)*new_r21*x596))+((cj1*new_r11))+x594);
evalcond[7]=((((-1.0)*new_r20*x596))+((cj1*new_r10))+(((-1.0)*x597)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x598=IKPowWithIntegerCheck(IKsign(cj1),-1);
if(!x598.valid){
continue;
}
CheckValue<IkReal> x599 = IKatan2WithCheck(IkReal(((-1.0)*new_r11)),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x599.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x598.value)))+(x599.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x600=IKsin(j2);
IkReal x601=IKcos(j2);
IkReal x602=((1.0)*sj1);
IkReal x603=((1.0)*x601);
evalcond[0]=(((sj1*x601))+new_r20);
evalcond[1]=(((cj1*x600))+new_r11);
evalcond[2]=((((-1.0)*x600*x602))+new_r21);
evalcond[3]=((((-1.0)*cj1*x603))+new_r10);
evalcond[4]=((((-1.0)*x600))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x603))+(((-1.0)*new_r01)));
evalcond[6]=(((cj1*new_r11))+x600+(((-1.0)*new_r21*x602)));
evalcond[7]=((((-1.0)*new_r20*x602))+((cj1*new_r10))+(((-1.0)*x603)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x604=IKPowWithIntegerCheck(IKsign(sj1),-1);
if(!x604.valid){
continue;
}
CheckValue<IkReal> x605 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x605.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x604.value)))+(x605.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x606=IKsin(j2);
IkReal x607=IKcos(j2);
IkReal x608=((1.0)*sj1);
IkReal x609=((1.0)*x607);
evalcond[0]=(((sj1*x607))+new_r20);
evalcond[1]=(((cj1*x606))+new_r11);
evalcond[2]=(new_r21+(((-1.0)*x606*x608)));
evalcond[3]=((((-1.0)*cj1*x609))+new_r10);
evalcond[4]=((((-1.0)*x606))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x609))+(((-1.0)*new_r01)));
evalcond[6]=(((cj1*new_r11))+x606+(((-1.0)*new_r21*x608)));
evalcond[7]=((((-1.0)*new_r20*x608))+((cj1*new_r10))+(((-1.0)*x609)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j0)))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(new_r00, new_r01);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x610=IKcos(j2);
IkReal x611=IKsin(j2);
IkReal x612=((1.0)*sj1);
IkReal x613=((1.0)*new_r11);
IkReal x614=((1.0)*new_r10);
IkReal x615=((1.0)*x610);
evalcond[0]=(((sj1*x610))+new_r20);
evalcond[1]=((((-1.0)*x611))+new_r00);
evalcond[2]=((((-1.0)*x615))+new_r01);
evalcond[3]=((((-1.0)*x611*x612))+new_r21);
evalcond[4]=((((-1.0)*x613))+((cj1*x611)));
evalcond[5]=((((-1.0)*cj1*x615))+(((-1.0)*x614)));
evalcond[6]=((((-1.0)*new_r21*x612))+(((-1.0)*cj1*x613))+x611);
evalcond[7]=((((-1.0)*cj1*x614))+(((-1.0)*x615))+(((-1.0)*new_r20*x612)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j1)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x616=IKcos(j2);
IkReal x617=IKsin(j2);
IkReal x618=((1.0)*sj0);
IkReal x619=((1.0)*x617);
IkReal x620=((1.0)*x616);
evalcond[0]=(x616+new_r20);
evalcond[1]=((((-1.0)*x619))+new_r21);
evalcond[2]=(((sj0*x616))+new_r01);
evalcond[3]=(((sj0*x617))+new_r00);
evalcond[4]=((((-1.0)*cj0*x620))+new_r11);
evalcond[5]=((((-1.0)*new_r02*x619))+new_r10);
evalcond[6]=((((-1.0)*x619))+(((-1.0)*new_r00*x618))+((cj0*new_r10)));
evalcond[7]=((((-1.0)*x620))+((cj0*new_r11))+(((-1.0)*new_r01*x618)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j1)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x621=IKcos(j2);
IkReal x622=IKsin(j2);
IkReal x623=((1.0)*sj0);
IkReal x624=((1.0)*x621);
evalcond[0]=(x622+new_r21);
evalcond[1]=((((-1.0)*x624))+new_r20);
evalcond[2]=(((sj0*x621))+new_r01);
evalcond[3]=(((sj0*x622))+new_r00);
evalcond[4]=(((new_r02*x622))+new_r10);
evalcond[5]=((((-1.0)*cj0*x624))+new_r11);
evalcond[6]=((((-1.0)*new_r00*x623))+(((-1.0)*x622))+((cj0*new_r10)));
evalcond[7]=((((-1.0)*new_r01*x623))+(((-1.0)*x624))+((cj0*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j1))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x625=((1.0)*new_r01);
if( IKabs(((((-1.0)*cj0*x625))+(((-1.0)*new_r00*sj0)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj0*new_r00))+(((-1.0)*sj0*x625)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj0*x625))+(((-1.0)*new_r00*sj0))))+IKsqr((((cj0*new_r00))+(((-1.0)*sj0*x625))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*cj0*x625))+(((-1.0)*new_r00*sj0))), (((cj0*new_r00))+(((-1.0)*sj0*x625))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x626=IKsin(j2);
IkReal x627=IKcos(j2);
IkReal x628=((1.0)*sj0);
IkReal x629=((1.0)*x627);
IkReal x630=(sj0*x626);
IkReal x631=(cj0*x626);
IkReal x632=(cj0*x629);
evalcond[0]=(((new_r11*sj0))+x626+((cj0*new_r01)));
evalcond[1]=(((sj0*x627))+x631+new_r01);
evalcond[2]=(((new_r10*sj0))+(((-1.0)*x629))+((cj0*new_r00)));
evalcond[3]=((((-1.0)*new_r00*x628))+(((-1.0)*x626))+((cj0*new_r10)));
evalcond[4]=((((-1.0)*new_r01*x628))+(((-1.0)*x629))+((cj0*new_r11)));
evalcond[5]=((((-1.0)*x632))+x630+new_r00);
evalcond[6]=((((-1.0)*x632))+x630+new_r11);
evalcond[7]=((((-1.0)*x627*x628))+(((-1.0)*x631))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j1)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x633=((1.0)*sj0);
if( IKabs(((((-1.0)*new_r00*x633))+((cj0*new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*x633))+(((-1.0)*cj0*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r00*x633))+((cj0*new_r01))))+IKsqr(((((-1.0)*new_r01*x633))+(((-1.0)*cj0*new_r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*new_r00*x633))+((cj0*new_r01))), ((((-1.0)*new_r01*x633))+(((-1.0)*cj0*new_r00))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x634=IKsin(j2);
IkReal x635=IKcos(j2);
IkReal x636=((1.0)*sj0);
IkReal x637=((1.0)*x634);
IkReal x638=(sj0*x635);
IkReal x639=((1.0)*x635);
IkReal x640=(cj0*x637);
evalcond[0]=(((new_r10*sj0))+x635+((cj0*new_r00)));
evalcond[1]=(((new_r11*sj0))+(((-1.0)*x637))+((cj0*new_r01)));
evalcond[2]=(((cj0*x635))+((sj0*x634))+new_r00);
evalcond[3]=((((-1.0)*new_r00*x636))+(((-1.0)*x637))+((cj0*new_r10)));
evalcond[4]=((((-1.0)*new_r01*x636))+(((-1.0)*x639))+((cj0*new_r11)));
evalcond[5]=((((-1.0)*x640))+x638+new_r01);
evalcond[6]=((((-1.0)*x640))+x638+new_r10);
evalcond[7]=((((-1.0)*cj0*x639))+(((-1.0)*x634*x636))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j0))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(new_r10, new_r11);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x641=IKcos(j2);
IkReal x642=IKsin(j2);
IkReal x643=((1.0)*sj1);
IkReal x644=((1.0)*x641);
evalcond[0]=(((sj1*x641))+new_r20);
evalcond[1]=((((-1.0)*x642))+new_r10);
evalcond[2]=((((-1.0)*x644))+new_r11);
evalcond[3]=(((cj1*x642))+new_r01);
evalcond[4]=((((-1.0)*x642*x643))+new_r21);
evalcond[5]=((((-1.0)*cj1*x644))+new_r00);
evalcond[6]=(((cj1*new_r01))+(((-1.0)*new_r21*x643))+x642);
evalcond[7]=(((cj1*new_r00))+(((-1.0)*x644))+(((-1.0)*new_r20*x643)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j0)))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[3];
sj0=0;
cj0=-1.0;
j0=3.14159265358979;
j2eval[0]=sj1;
j2eval[1]=IKsign(sj1);
j2eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[1];
sj0=0;
cj0=-1.0;
j0=3.14159265358979;
j2eval[0]=sj1;
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
sj0=0;
cj0=-1.0;
j0=3.14159265358979;
j2eval[0]=cj1;
j2eval[1]=sj1;
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j1)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r01;
evalcond[3]=new_r00;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x645=IKcos(j2);
IkReal x646=((1.0)*(IKsin(j2)));
evalcond[0]=(x645+new_r20);
evalcond[1]=((((-1.0)*x646))+new_r21);
evalcond[2]=((((-1.0)*x646))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x645))+(((-1.0)*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j1)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r01;
evalcond[3]=new_r00;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x647=IKsin(j2);
IkReal x648=((1.0)*(IKcos(j2)));
evalcond[0]=(x647+new_r21);
evalcond[1]=((((-1.0)*x648))+new_r20);
evalcond[2]=((((-1.0)*x647))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x648))+(((-1.0)*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j1))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(new_r01, ((-1.0)*new_r11));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x649=IKsin(j2);
IkReal x650=((1.0)*(IKcos(j2)));
evalcond[0]=(x649+(((-1.0)*new_r01)));
evalcond[1]=((((-1.0)*x649))+(((-1.0)*new_r10)));
evalcond[2]=((((-1.0)*x650))+(((-1.0)*new_r11)));
evalcond[3]=((((-1.0)*x650))+(((-1.0)*new_r00)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j1)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r10), new_r00);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x651=IKcos(j2);
IkReal x652=((1.0)*(IKsin(j2)));
evalcond[0]=(x651+(((-1.0)*new_r00)));
evalcond[1]=((((-1.0)*x652))+(((-1.0)*new_r10)));
evalcond[2]=((((-1.0)*x651))+(((-1.0)*new_r11)));
evalcond[3]=((((-1.0)*x652))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r11));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x653=IKsin(j2);
IkReal x654=IKcos(j2);
IkReal x655=((-1.0)*x654);
evalcond[0]=x653;
evalcond[1]=(new_r22*x653);
evalcond[2]=x655;
evalcond[3]=(new_r22*x655);
evalcond[4]=((((-1.0)*x653))+(((-1.0)*new_r10)));
evalcond[5]=((((-1.0)*x654))+(((-1.0)*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j2]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x656=IKPowWithIntegerCheck(cj1,-1);
if(!x656.valid){
continue;
}
CheckValue<IkReal> x657=IKPowWithIntegerCheck(sj1,-1);
if(!x657.valid){
continue;
}
if( IKabs((new_r01*(x656.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*(x657.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r01*(x656.value)))+IKsqr(((-1.0)*new_r20*(x657.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((new_r01*(x656.value)), ((-1.0)*new_r20*(x657.value)));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x658=IKsin(j2);
IkReal x659=IKcos(j2);
IkReal x660=((1.0)*new_r00);
IkReal x661=((1.0)*sj1);
IkReal x662=((1.0)*new_r01);
IkReal x663=((1.0)*x659);
evalcond[0]=(((sj1*x659))+new_r20);
evalcond[1]=((((-1.0)*x658*x661))+new_r21);
evalcond[2]=((((-1.0)*x658))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x663))+(((-1.0)*new_r11)));
evalcond[4]=(((cj1*x658))+(((-1.0)*x662)));
evalcond[5]=((((-1.0)*cj1*x663))+(((-1.0)*x660)));
evalcond[6]=((((-1.0)*new_r21*x661))+(((-1.0)*cj1*x662))+x658);
evalcond[7]=((((-1.0)*cj1*x660))+(((-1.0)*x663))+(((-1.0)*new_r20*x661)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x664=IKPowWithIntegerCheck(sj1,-1);
if(!x664.valid){
continue;
}
if( IKabs((new_r21*(x664.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r21*(x664.value)))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((new_r21*(x664.value)), ((-1.0)*new_r11));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x665=IKsin(j2);
IkReal x666=IKcos(j2);
IkReal x667=((1.0)*new_r00);
IkReal x668=((1.0)*sj1);
IkReal x669=((1.0)*new_r01);
IkReal x670=((1.0)*x666);
evalcond[0]=(((sj1*x666))+new_r20);
evalcond[1]=((((-1.0)*x665*x668))+new_r21);
evalcond[2]=((((-1.0)*x665))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*new_r11))+(((-1.0)*x670)));
evalcond[4]=((((-1.0)*x669))+((cj1*x665)));
evalcond[5]=((((-1.0)*x667))+(((-1.0)*cj1*x670)));
evalcond[6]=((((-1.0)*new_r21*x668))+(((-1.0)*cj1*x669))+x665);
evalcond[7]=((((-1.0)*cj1*x667))+(((-1.0)*x670))+(((-1.0)*new_r20*x668)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x671=IKPowWithIntegerCheck(IKsign(sj1),-1);
if(!x671.valid){
continue;
}
CheckValue<IkReal> x672 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x672.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x671.value)))+(x672.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x673=IKsin(j2);
IkReal x674=IKcos(j2);
IkReal x675=((1.0)*new_r00);
IkReal x676=((1.0)*sj1);
IkReal x677=((1.0)*new_r01);
IkReal x678=((1.0)*x674);
evalcond[0]=(((sj1*x674))+new_r20);
evalcond[1]=(new_r21+(((-1.0)*x673*x676)));
evalcond[2]=((((-1.0)*x673))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*new_r11))+(((-1.0)*x678)));
evalcond[4]=(((cj1*x673))+(((-1.0)*x677)));
evalcond[5]=((((-1.0)*cj1*x678))+(((-1.0)*x675)));
evalcond[6]=((((-1.0)*new_r21*x676))+(((-1.0)*cj1*x677))+x673);
evalcond[7]=((((-1.0)*new_r20*x676))+(((-1.0)*cj1*x675))+(((-1.0)*x678)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[1];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
j2eval[0]=IKabs(new_r22);
if( IKabs(j2eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j2]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
op[0]=new_r22;
op[1]=0;
op[2]=((-1.0)*new_r22);
polyroots2(op,zeror,numroots);
IkReal j2array[2], cj2array[2], sj2array[2], tempj2array[1];
int numsolutions = 0;
for(int ij2 = 0; ij2 < numroots; ++ij2)
{
IkReal htj2 = zeror[ij2];
tempj2array[0]=((2.0)*(atan(htj2)));
for(int kj2 = 0; kj2 < 1; ++kj2)
{
j2array[numsolutions] = tempj2array[kj2];
if( j2array[numsolutions] > IKPI )
{
    j2array[numsolutions]-=IK2PI;
}
else if( j2array[numsolutions] < -IKPI )
{
    j2array[numsolutions]+=IK2PI;
}
sj2array[numsolutions] = IKsin(j2array[numsolutions]);
cj2array[numsolutions] = IKcos(j2array[numsolutions]);
numsolutions++;
}
}
bool j2valid[2]={true,true};
_nj2 = 2;
for(int ij2 = 0; ij2 < numsolutions; ++ij2)
    {
if( !j2valid[ij2] )
{
    continue;
}
    j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
htj2 = IKtan(j2/2);

_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < numsolutions; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j2]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x680=IKPowWithIntegerCheck(sj1,-1);
if(!x680.valid){
continue;
}
IkReal x679=x680.value;
CheckValue<IkReal> x681=IKPowWithIntegerCheck(cj0,-1);
if(!x681.valid){
continue;
}
CheckValue<IkReal> x682=IKPowWithIntegerCheck(cj1,-1);
if(!x682.valid){
continue;
}
if( IKabs((x679*(x681.value)*(x682.value)*((((new_r20*sj0))+(((-1.0)*new_r01*sj1)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x679)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x679*(x681.value)*(x682.value)*((((new_r20*sj0))+(((-1.0)*new_r01*sj1))))))+IKsqr(((-1.0)*new_r20*x679))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((x679*(x681.value)*(x682.value)*((((new_r20*sj0))+(((-1.0)*new_r01*sj1))))), ((-1.0)*new_r20*x679));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[12];
IkReal x683=IKsin(j2);
IkReal x684=IKcos(j2);
IkReal x685=((1.0)*sj1);
IkReal x686=((1.0)*sj0);
IkReal x687=(cj0*new_r00);
IkReal x688=(cj0*cj1);
IkReal x689=(new_r11*sj0);
IkReal x690=(new_r10*sj0);
IkReal x691=((1.0)*x684);
IkReal x692=(cj1*x683);
IkReal x693=((1.0)*x683);
evalcond[0]=(((sj1*x684))+new_r20);
evalcond[1]=((((-1.0)*x683*x685))+new_r21);
evalcond[2]=(x689+x692+((cj0*new_r01)));
evalcond[3]=((((-1.0)*x693))+((cj0*new_r10))+(((-1.0)*new_r00*x686)));
evalcond[4]=((((-1.0)*new_r01*x686))+(((-1.0)*x691))+((cj0*new_r11)));
evalcond[5]=(((x683*x688))+((sj0*x684))+new_r01);
evalcond[6]=((((-1.0)*cj1*x691))+x687+x690);
evalcond[7]=((((-1.0)*x688*x691))+((sj0*x683))+new_r00);
evalcond[8]=(((sj0*x692))+(((-1.0)*cj0*x691))+new_r11);
evalcond[9]=((((-1.0)*cj1*x684*x686))+(((-1.0)*cj0*x693))+new_r10);
evalcond[10]=(((cj1*x689))+((new_r01*x688))+(((-1.0)*new_r21*x685))+x683);
evalcond[11]=(((cj1*x687))+((cj1*x690))+(((-1.0)*new_r20*x685))+(((-1.0)*x691)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x695=IKPowWithIntegerCheck(sj1,-1);
if(!x695.valid){
continue;
}
IkReal x694=x695.value;
CheckValue<IkReal> x696=IKPowWithIntegerCheck(sj0,-1);
if(!x696.valid){
continue;
}
if( IKabs((x694*(x696.value)*(((((-1.0)*cj0*cj1*new_r20))+(((-1.0)*new_r00*sj1)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x694)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x694*(x696.value)*(((((-1.0)*cj0*cj1*new_r20))+(((-1.0)*new_r00*sj1))))))+IKsqr(((-1.0)*new_r20*x694))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((x694*(x696.value)*(((((-1.0)*cj0*cj1*new_r20))+(((-1.0)*new_r00*sj1))))), ((-1.0)*new_r20*x694));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[12];
IkReal x697=IKsin(j2);
IkReal x698=IKcos(j2);
IkReal x699=((1.0)*sj1);
IkReal x700=((1.0)*sj0);
IkReal x701=(cj0*new_r00);
IkReal x702=(cj0*cj1);
IkReal x703=(new_r11*sj0);
IkReal x704=(new_r10*sj0);
IkReal x705=((1.0)*x698);
IkReal x706=(cj1*x697);
IkReal x707=((1.0)*x697);
evalcond[0]=(((sj1*x698))+new_r20);
evalcond[1]=((((-1.0)*x697*x699))+new_r21);
evalcond[2]=(x703+x706+((cj0*new_r01)));
evalcond[3]=((((-1.0)*x707))+((cj0*new_r10))+(((-1.0)*new_r00*x700)));
evalcond[4]=((((-1.0)*x705))+(((-1.0)*new_r01*x700))+((cj0*new_r11)));
evalcond[5]=(((sj0*x698))+((x697*x702))+new_r01);
evalcond[6]=((((-1.0)*cj1*x705))+x701+x704);
evalcond[7]=((((-1.0)*x702*x705))+((sj0*x697))+new_r00);
evalcond[8]=((((-1.0)*cj0*x705))+((sj0*x706))+new_r11);
evalcond[9]=((((-1.0)*cj0*x707))+new_r10+(((-1.0)*cj1*x698*x700)));
evalcond[10]=(((new_r01*x702))+x697+(((-1.0)*new_r21*x699))+((cj1*x703)));
evalcond[11]=((((-1.0)*x705))+((cj1*x704))+((cj1*x701))+(((-1.0)*new_r20*x699)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x708=IKPowWithIntegerCheck(IKsign(sj1),-1);
if(!x708.valid){
continue;
}
CheckValue<IkReal> x709 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x709.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x708.value)))+(x709.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[12];
IkReal x710=IKsin(j2);
IkReal x711=IKcos(j2);
IkReal x712=((1.0)*sj1);
IkReal x713=((1.0)*sj0);
IkReal x714=(cj0*new_r00);
IkReal x715=(cj0*cj1);
IkReal x716=(new_r11*sj0);
IkReal x717=(new_r10*sj0);
IkReal x718=((1.0)*x711);
IkReal x719=(cj1*x710);
IkReal x720=((1.0)*x710);
evalcond[0]=(((sj1*x711))+new_r20);
evalcond[1]=((((-1.0)*x710*x712))+new_r21);
evalcond[2]=(x719+x716+((cj0*new_r01)));
evalcond[3]=((((-1.0)*x720))+((cj0*new_r10))+(((-1.0)*new_r00*x713)));
evalcond[4]=((((-1.0)*x718))+((cj0*new_r11))+(((-1.0)*new_r01*x713)));
evalcond[5]=(((x710*x715))+((sj0*x711))+new_r01);
evalcond[6]=((((-1.0)*cj1*x718))+x714+x717);
evalcond[7]=(((sj0*x710))+new_r00+(((-1.0)*x715*x718)));
evalcond[8]=(((sj0*x719))+new_r11+(((-1.0)*cj0*x718)));
evalcond[9]=((((-1.0)*cj1*x711*x713))+(((-1.0)*cj0*x720))+new_r10);
evalcond[10]=((((-1.0)*new_r21*x712))+((new_r01*x715))+x710+((cj1*x716)));
evalcond[11]=((((-1.0)*new_r20*x712))+(((-1.0)*x718))+((cj1*x717))+((cj1*x714)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
}
}
}static inline void polyroots3(IkReal rawcoeffs[3+1], IkReal rawroots[3], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots2(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[3];
    const int maxsteps = 110;
    for(int i = 0; i < 3; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[3];
    IkReal err[3];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 3; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 3; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 3; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 3; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[3] = {false};
    for(int i = 0; i < 3; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 3; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {
    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];
    if( det < 0 ) {
        numroots=0;
    }
    else if( det == 0 ) {
        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];
        numroots = 1;
    }
    else {
        det = IKsqrt(det);
        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);
        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);
        numroots = 2;
    }
}
static inline void polyroots5(IkReal rawcoeffs[5+1], IkReal rawroots[5], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots4(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[5];
    const int maxsteps = 110;
    for(int i = 0; i < 5; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[5];
    IkReal err[5];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 5; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 5; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 5; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 5; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[5] = {false};
    for(int i = 0; i < 5; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 5; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots4(IkReal rawcoeffs[4+1], IkReal rawroots[4], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots3(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[4];
    const int maxsteps = 110;
    for(int i = 0; i < 4; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[4];
    IkReal err[4];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 4; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 4; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 4; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 4; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[4] = {false};
    for(int i = 0; i < 4; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 4; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots7(IkReal rawcoeffs[7+1], IkReal rawroots[7], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots6(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[7];
    const int maxsteps = 110;
    for(int i = 0; i < 7; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[7];
    IkReal err[7];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 7; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 7; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 7; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 7; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[7] = {false};
    for(int i = 0; i < 7; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 7; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots6(IkReal rawcoeffs[6+1], IkReal rawroots[6], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots5(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[6];
    const int maxsteps = 110;
    for(int i = 0; i < 6; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[6];
    IkReal err[6];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 6; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 6; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 6; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 6; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[6] = {false};
    for(int i = 0; i < 6; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 6; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots8(IkReal rawcoeffs[8+1], IkReal rawroots[8], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots7(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[8];
    const int maxsteps = 110;
    for(int i = 0; i < 8; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[8];
    IkReal err[8];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 8; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 8; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 8; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 8; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[8] = {false};
    for(int i = 0; i < 8; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 8; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "<robot:GenericRobot - xarm7_with_gripper (b0c22985b5978e1acf2a611482b6a182)>"; }

IKFAST_API const char* GetIkFastVersion() { return "0x10000049"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif
